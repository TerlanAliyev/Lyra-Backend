
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ProfileOption
 * 
 */
export type ProfileOption = $Result.DefaultSelection<Prisma.$ProfileOptionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Interest
 * 
 */
export type Interest = $Result.DefaultSelection<Prisma.$InterestPayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model ActiveSession
 * 
 */
export type ActiveSession = $Result.DefaultSelection<Prisma.$ActiveSessionPayload>
/**
 * Model Signal
 * 
 */
export type Signal = $Result.DefaultSelection<Prisma.$SignalPayload>
/**
 * Model Connection
 * 
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Device
 * 
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model BroadcastNotification
 * 
 */
export type BroadcastNotification = $Result.DefaultSelection<Prisma.$BroadcastNotificationPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Photo
 * 
 */
export type Photo = $Result.DefaultSelection<Prisma.$PhotoPayload>
/**
 * Model IcebreakerQuestion
 * 
 */
export type IcebreakerQuestion = $Result.DefaultSelection<Prisma.$IcebreakerQuestionPayload>
/**
 * Model ProfileView
 * 
 */
export type ProfileView = $Result.DefaultSelection<Prisma.$ProfileViewPayload>
/**
 * Model VenueGroupMessage
 * 
 */
export type VenueGroupMessage = $Result.DefaultSelection<Prisma.$VenueGroupMessagePayload>
/**
 * Model AccountDeletionToken
 * 
 */
export type AccountDeletionToken = $Result.DefaultSelection<Prisma.$AccountDeletionTokenPayload>
/**
 * Model EmailChangeToken
 * 
 */
export type EmailChangeToken = $Result.DefaultSelection<Prisma.$EmailChangeTokenPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model GroupMessageReaction
 * 
 */
export type GroupMessageReaction = $Result.DefaultSelection<Prisma.$GroupMessageReactionPayload>
/**
 * Model CheckInHistory
 * 
 */
export type CheckInHistory = $Result.DefaultSelection<Prisma.$CheckInHistoryPayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model BadgeRule
 * 
 */
export type BadgeRule = $Result.DefaultSelection<Prisma.$BadgeRulePayload>
/**
 * Model ChallengeTemplate
 * 
 */
export type ChallengeTemplate = $Result.DefaultSelection<Prisma.$ChallengeTemplatePayload>
/**
 * Model ChallengeInstance
 * 
 */
export type ChallengeInstance = $Result.DefaultSelection<Prisma.$ChallengeInstancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  EMAIL: 'EMAIL',
  GOOGLE: 'GOOGLE',
  APPLE: 'APPLE'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const ReportStatus: {
  PENDING: 'PENDING',
  RESOLVED: 'RESOLVED',
  REJECTED: 'REJECTED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const PersonalityType: {
  INTROVERT: 'INTROVERT',
  EXTROVERT: 'EXTROVERT',
  AMBIVERT: 'AMBIVERT'
};

export type PersonalityType = (typeof PersonalityType)[keyof typeof PersonalityType]


export const SubscriptionPlan: {
  FREE: 'FREE',
  PREMIUM_MONTHLY: 'PREMIUM_MONTHLY',
  PREMIUM_YEARLY: 'PREMIUM_YEARLY'
};

export type SubscriptionPlan = (typeof SubscriptionPlan)[keyof typeof SubscriptionPlan]


export const VenueCategory: {
  GENERAL: 'GENERAL',
  CAFE: 'CAFE',
  RESTAURANT: 'RESTAURANT',
  UNIVERSITY: 'UNIVERSITY',
  BAR: 'BAR',
  EVENT_SPACE: 'EVENT_SPACE',
  CLUB: 'CLUB'
};

export type VenueCategory = (typeof VenueCategory)[keyof typeof VenueCategory]


export const IcebreakerCategory: {
  GENERAL: 'GENERAL',
  FOOD_DRINK: 'FOOD_DRINK',
  STUDENT_LIFE: 'STUDENT_LIFE',
  NIGHTLIFE: 'NIGHTLIFE',
  DEEP_TALK: 'DEEP_TALK'
};

export type IcebreakerCategory = (typeof IcebreakerCategory)[keyof typeof IcebreakerCategory]


export const VerificationStatus: {
  NOT_SUBMITTED: 'NOT_SUBMITTED',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const ChallengeInstanceStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED'
};

export type ChallengeInstanceStatus = (typeof ChallengeInstanceStatus)[keyof typeof ChallengeInstanceStatus]


export const OptionType: {
  SEXUAL_ORIENTATION: 'SEXUAL_ORIENTATION',
  RELATIONSHIP_GOAL: 'RELATIONSHIP_GOAL'
};

export type OptionType = (typeof OptionType)[keyof typeof OptionType]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type PersonalityType = $Enums.PersonalityType

export const PersonalityType: typeof $Enums.PersonalityType

export type SubscriptionPlan = $Enums.SubscriptionPlan

export const SubscriptionPlan: typeof $Enums.SubscriptionPlan

export type VenueCategory = $Enums.VenueCategory

export const VenueCategory: typeof $Enums.VenueCategory

export type IcebreakerCategory = $Enums.IcebreakerCategory

export const IcebreakerCategory: typeof $Enums.IcebreakerCategory

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type ChallengeInstanceStatus = $Enums.ChallengeInstanceStatus

export const ChallengeInstanceStatus: typeof $Enums.ChallengeInstanceStatus

export type OptionType = $Enums.OptionType

export const OptionType: typeof $Enums.OptionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ProfileOptions
 * const profileOptions = await prisma.profileOption.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ProfileOptions
   * const profileOptions = await prisma.profileOption.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.profileOption`: Exposes CRUD operations for the **ProfileOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileOptions
    * const profileOptions = await prisma.profileOption.findMany()
    * ```
    */
  get profileOption(): Prisma.ProfileOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interest`: Exposes CRUD operations for the **Interest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interests
    * const interests = await prisma.interest.findMany()
    * ```
    */
  get interest(): Prisma.InterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activeSession`: Exposes CRUD operations for the **ActiveSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActiveSessions
    * const activeSessions = await prisma.activeSession.findMany()
    * ```
    */
  get activeSession(): Prisma.ActiveSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signal`: Exposes CRUD operations for the **Signal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signals
    * const signals = await prisma.signal.findMany()
    * ```
    */
  get signal(): Prisma.SignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Connections
    * const connections = await prisma.connection.findMany()
    * ```
    */
  get connection(): Prisma.ConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.broadcastNotification`: Exposes CRUD operations for the **BroadcastNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BroadcastNotifications
    * const broadcastNotifications = await prisma.broadcastNotification.findMany()
    * ```
    */
  get broadcastNotification(): Prisma.BroadcastNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.icebreakerQuestion`: Exposes CRUD operations for the **IcebreakerQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IcebreakerQuestions
    * const icebreakerQuestions = await prisma.icebreakerQuestion.findMany()
    * ```
    */
  get icebreakerQuestion(): Prisma.IcebreakerQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileView`: Exposes CRUD operations for the **ProfileView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileViews
    * const profileViews = await prisma.profileView.findMany()
    * ```
    */
  get profileView(): Prisma.ProfileViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venueGroupMessage`: Exposes CRUD operations for the **VenueGroupMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VenueGroupMessages
    * const venueGroupMessages = await prisma.venueGroupMessage.findMany()
    * ```
    */
  get venueGroupMessage(): Prisma.VenueGroupMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountDeletionToken`: Exposes CRUD operations for the **AccountDeletionToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountDeletionTokens
    * const accountDeletionTokens = await prisma.accountDeletionToken.findMany()
    * ```
    */
  get accountDeletionToken(): Prisma.AccountDeletionTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailChangeToken`: Exposes CRUD operations for the **EmailChangeToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailChangeTokens
    * const emailChangeTokens = await prisma.emailChangeToken.findMany()
    * ```
    */
  get emailChangeToken(): Prisma.EmailChangeTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupMessageReaction`: Exposes CRUD operations for the **GroupMessageReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupMessageReactions
    * const groupMessageReactions = await prisma.groupMessageReaction.findMany()
    * ```
    */
  get groupMessageReaction(): Prisma.GroupMessageReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkInHistory`: Exposes CRUD operations for the **CheckInHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckInHistories
    * const checkInHistories = await prisma.checkInHistory.findMany()
    * ```
    */
  get checkInHistory(): Prisma.CheckInHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badgeRule`: Exposes CRUD operations for the **BadgeRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BadgeRules
    * const badgeRules = await prisma.badgeRule.findMany()
    * ```
    */
  get badgeRule(): Prisma.BadgeRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeTemplate`: Exposes CRUD operations for the **ChallengeTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeTemplates
    * const challengeTemplates = await prisma.challengeTemplate.findMany()
    * ```
    */
  get challengeTemplate(): Prisma.ChallengeTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeInstance`: Exposes CRUD operations for the **ChallengeInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeInstances
    * const challengeInstances = await prisma.challengeInstance.findMany()
    * ```
    */
  get challengeInstance(): Prisma.ChallengeInstanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ProfileOption: 'ProfileOption',
    User: 'User',
    Profile: 'Profile',
    Category: 'Category',
    Interest: 'Interest',
    Venue: 'Venue',
    ActiveSession: 'ActiveSession',
    Signal: 'Signal',
    Connection: 'Connection',
    Message: 'Message',
    Block: 'Block',
    Report: 'Report',
    Device: 'Device',
    Notification: 'Notification',
    Feedback: 'Feedback',
    Role: 'Role',
    AuditLog: 'AuditLog',
    BroadcastNotification: 'BroadcastNotification',
    PasswordResetToken: 'PasswordResetToken',
    Photo: 'Photo',
    IcebreakerQuestion: 'IcebreakerQuestion',
    ProfileView: 'ProfileView',
    VenueGroupMessage: 'VenueGroupMessage',
    AccountDeletionToken: 'AccountDeletionToken',
    EmailChangeToken: 'EmailChangeToken',
    RefreshToken: 'RefreshToken',
    GroupMessageReaction: 'GroupMessageReaction',
    CheckInHistory: 'CheckInHistory',
    Badge: 'Badge',
    UserBadge: 'UserBadge',
    BadgeRule: 'BadgeRule',
    ChallengeTemplate: 'ChallengeTemplate',
    ChallengeInstance: 'ChallengeInstance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "profileOption" | "user" | "profile" | "category" | "interest" | "venue" | "activeSession" | "signal" | "connection" | "message" | "block" | "report" | "device" | "notification" | "feedback" | "role" | "auditLog" | "broadcastNotification" | "passwordResetToken" | "photo" | "icebreakerQuestion" | "profileView" | "venueGroupMessage" | "accountDeletionToken" | "emailChangeToken" | "refreshToken" | "groupMessageReaction" | "checkInHistory" | "badge" | "userBadge" | "badgeRule" | "challengeTemplate" | "challengeInstance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ProfileOption: {
        payload: Prisma.$ProfileOptionPayload<ExtArgs>
        fields: Prisma.ProfileOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>
          }
          findFirst: {
            args: Prisma.ProfileOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>
          }
          findMany: {
            args: Prisma.ProfileOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>[]
          }
          create: {
            args: Prisma.ProfileOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>
          }
          createMany: {
            args: Prisma.ProfileOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfileOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>
          }
          update: {
            args: Prisma.ProfileOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>
          }
          deleteMany: {
            args: Prisma.ProfileOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileOptionPayload>
          }
          aggregate: {
            args: Prisma.ProfileOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileOption>
          }
          groupBy: {
            args: Prisma.ProfileOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileOptionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Interest: {
        payload: Prisma.$InterestPayload<ExtArgs>
        fields: Prisma.InterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findFirst: {
            args: Prisma.InterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findMany: {
            args: Prisma.InterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          create: {
            args: Prisma.InterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          createMany: {
            args: Prisma.InterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          update: {
            args: Prisma.InterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          deleteMany: {
            args: Prisma.InterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          aggregate: {
            args: Prisma.InterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterest>
          }
          groupBy: {
            args: Prisma.InterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestCountArgs<ExtArgs>
            result: $Utils.Optional<InterestCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      ActiveSession: {
        payload: Prisma.$ActiveSessionPayload<ExtArgs>
        fields: Prisma.ActiveSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActiveSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActiveSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>
          }
          findFirst: {
            args: Prisma.ActiveSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActiveSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>
          }
          findMany: {
            args: Prisma.ActiveSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>[]
          }
          create: {
            args: Prisma.ActiveSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>
          }
          createMany: {
            args: Prisma.ActiveSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActiveSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>
          }
          update: {
            args: Prisma.ActiveSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>
          }
          deleteMany: {
            args: Prisma.ActiveSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActiveSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActiveSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiveSessionPayload>
          }
          aggregate: {
            args: Prisma.ActiveSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActiveSession>
          }
          groupBy: {
            args: Prisma.ActiveSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActiveSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActiveSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ActiveSessionCountAggregateOutputType> | number
          }
        }
      }
      Signal: {
        payload: Prisma.$SignalPayload<ExtArgs>
        fields: Prisma.SignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findFirst: {
            args: Prisma.SignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          findMany: {
            args: Prisma.SignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>[]
          }
          create: {
            args: Prisma.SignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          createMany: {
            args: Prisma.SignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          update: {
            args: Prisma.SignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          deleteMany: {
            args: Prisma.SignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignalPayload>
          }
          aggregate: {
            args: Prisma.SignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignal>
          }
          groupBy: {
            args: Prisma.SignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignalCountArgs<ExtArgs>
            result: $Utils.Optional<SignalCountAggregateOutputType> | number
          }
        }
      }
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>
        fields: Prisma.ConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnection>
          }
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      BroadcastNotification: {
        payload: Prisma.$BroadcastNotificationPayload<ExtArgs>
        fields: Prisma.BroadcastNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BroadcastNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BroadcastNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>
          }
          findFirst: {
            args: Prisma.BroadcastNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BroadcastNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>
          }
          findMany: {
            args: Prisma.BroadcastNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>[]
          }
          create: {
            args: Prisma.BroadcastNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>
          }
          createMany: {
            args: Prisma.BroadcastNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BroadcastNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>
          }
          update: {
            args: Prisma.BroadcastNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>
          }
          deleteMany: {
            args: Prisma.BroadcastNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BroadcastNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BroadcastNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BroadcastNotificationPayload>
          }
          aggregate: {
            args: Prisma.BroadcastNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBroadcastNotification>
          }
          groupBy: {
            args: Prisma.BroadcastNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BroadcastNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BroadcastNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<BroadcastNotificationCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Photo: {
        payload: Prisma.$PhotoPayload<ExtArgs>
        fields: Prisma.PhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findFirst: {
            args: Prisma.PhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findMany: {
            args: Prisma.PhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          create: {
            args: Prisma.PhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          createMany: {
            args: Prisma.PhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          update: {
            args: Prisma.PhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          deleteMany: {
            args: Prisma.PhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          aggregate: {
            args: Prisma.PhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhoto>
          }
          groupBy: {
            args: Prisma.PhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoCountArgs<ExtArgs>
            result: $Utils.Optional<PhotoCountAggregateOutputType> | number
          }
        }
      }
      IcebreakerQuestion: {
        payload: Prisma.$IcebreakerQuestionPayload<ExtArgs>
        fields: Prisma.IcebreakerQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IcebreakerQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IcebreakerQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>
          }
          findFirst: {
            args: Prisma.IcebreakerQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IcebreakerQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>
          }
          findMany: {
            args: Prisma.IcebreakerQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>[]
          }
          create: {
            args: Prisma.IcebreakerQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>
          }
          createMany: {
            args: Prisma.IcebreakerQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.IcebreakerQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>
          }
          update: {
            args: Prisma.IcebreakerQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>
          }
          deleteMany: {
            args: Prisma.IcebreakerQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IcebreakerQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IcebreakerQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IcebreakerQuestionPayload>
          }
          aggregate: {
            args: Prisma.IcebreakerQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIcebreakerQuestion>
          }
          groupBy: {
            args: Prisma.IcebreakerQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<IcebreakerQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.IcebreakerQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<IcebreakerQuestionCountAggregateOutputType> | number
          }
        }
      }
      ProfileView: {
        payload: Prisma.$ProfileViewPayload<ExtArgs>
        fields: Prisma.ProfileViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          findFirst: {
            args: Prisma.ProfileViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          findMany: {
            args: Prisma.ProfileViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>[]
          }
          create: {
            args: Prisma.ProfileViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          createMany: {
            args: Prisma.ProfileViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProfileViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          update: {
            args: Prisma.ProfileViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          deleteMany: {
            args: Prisma.ProfileViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileViewPayload>
          }
          aggregate: {
            args: Prisma.ProfileViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileView>
          }
          groupBy: {
            args: Prisma.ProfileViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileViewCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileViewCountAggregateOutputType> | number
          }
        }
      }
      VenueGroupMessage: {
        payload: Prisma.$VenueGroupMessagePayload<ExtArgs>
        fields: Prisma.VenueGroupMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueGroupMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueGroupMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>
          }
          findFirst: {
            args: Prisma.VenueGroupMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueGroupMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>
          }
          findMany: {
            args: Prisma.VenueGroupMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>[]
          }
          create: {
            args: Prisma.VenueGroupMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>
          }
          createMany: {
            args: Prisma.VenueGroupMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VenueGroupMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>
          }
          update: {
            args: Prisma.VenueGroupMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>
          }
          deleteMany: {
            args: Prisma.VenueGroupMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueGroupMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VenueGroupMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenueGroupMessagePayload>
          }
          aggregate: {
            args: Prisma.VenueGroupMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenueGroupMessage>
          }
          groupBy: {
            args: Prisma.VenueGroupMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueGroupMessageCountArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupMessageCountAggregateOutputType> | number
          }
        }
      }
      AccountDeletionToken: {
        payload: Prisma.$AccountDeletionTokenPayload<ExtArgs>
        fields: Prisma.AccountDeletionTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountDeletionTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountDeletionTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>
          }
          findFirst: {
            args: Prisma.AccountDeletionTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountDeletionTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>
          }
          findMany: {
            args: Prisma.AccountDeletionTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>[]
          }
          create: {
            args: Prisma.AccountDeletionTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>
          }
          createMany: {
            args: Prisma.AccountDeletionTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeletionTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>
          }
          update: {
            args: Prisma.AccountDeletionTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeletionTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountDeletionTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountDeletionTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountDeletionTokenPayload>
          }
          aggregate: {
            args: Prisma.AccountDeletionTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountDeletionToken>
          }
          groupBy: {
            args: Prisma.AccountDeletionTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountDeletionTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountDeletionTokenCountArgs<ExtArgs>
            result: $Utils.Optional<AccountDeletionTokenCountAggregateOutputType> | number
          }
        }
      }
      EmailChangeToken: {
        payload: Prisma.$EmailChangeTokenPayload<ExtArgs>
        fields: Prisma.EmailChangeTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailChangeTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailChangeTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>
          }
          findFirst: {
            args: Prisma.EmailChangeTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailChangeTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>
          }
          findMany: {
            args: Prisma.EmailChangeTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>[]
          }
          create: {
            args: Prisma.EmailChangeTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>
          }
          createMany: {
            args: Prisma.EmailChangeTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailChangeTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>
          }
          update: {
            args: Prisma.EmailChangeTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>
          }
          deleteMany: {
            args: Prisma.EmailChangeTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailChangeTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailChangeTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeTokenPayload>
          }
          aggregate: {
            args: Prisma.EmailChangeTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailChangeToken>
          }
          groupBy: {
            args: Prisma.EmailChangeTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailChangeTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailChangeTokenCountArgs<ExtArgs>
            result: $Utils.Optional<EmailChangeTokenCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      GroupMessageReaction: {
        payload: Prisma.$GroupMessageReactionPayload<ExtArgs>
        fields: Prisma.GroupMessageReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupMessageReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupMessageReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>
          }
          findFirst: {
            args: Prisma.GroupMessageReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupMessageReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>
          }
          findMany: {
            args: Prisma.GroupMessageReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>[]
          }
          create: {
            args: Prisma.GroupMessageReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>
          }
          createMany: {
            args: Prisma.GroupMessageReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GroupMessageReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>
          }
          update: {
            args: Prisma.GroupMessageReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>
          }
          deleteMany: {
            args: Prisma.GroupMessageReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupMessageReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupMessageReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupMessageReactionPayload>
          }
          aggregate: {
            args: Prisma.GroupMessageReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupMessageReaction>
          }
          groupBy: {
            args: Prisma.GroupMessageReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupMessageReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupMessageReactionCountArgs<ExtArgs>
            result: $Utils.Optional<GroupMessageReactionCountAggregateOutputType> | number
          }
        }
      }
      CheckInHistory: {
        payload: Prisma.$CheckInHistoryPayload<ExtArgs>
        fields: Prisma.CheckInHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckInHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckInHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>
          }
          findFirst: {
            args: Prisma.CheckInHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckInHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>
          }
          findMany: {
            args: Prisma.CheckInHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>[]
          }
          create: {
            args: Prisma.CheckInHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>
          }
          createMany: {
            args: Prisma.CheckInHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CheckInHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>
          }
          update: {
            args: Prisma.CheckInHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CheckInHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckInHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheckInHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckInHistoryPayload>
          }
          aggregate: {
            args: Prisma.CheckInHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckInHistory>
          }
          groupBy: {
            args: Prisma.CheckInHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckInHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckInHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CheckInHistoryCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      BadgeRule: {
        payload: Prisma.$BadgeRulePayload<ExtArgs>
        fields: Prisma.BadgeRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>
          }
          findFirst: {
            args: Prisma.BadgeRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>
          }
          findMany: {
            args: Prisma.BadgeRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>[]
          }
          create: {
            args: Prisma.BadgeRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>
          }
          createMany: {
            args: Prisma.BadgeRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BadgeRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>
          }
          update: {
            args: Prisma.BadgeRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>
          }
          deleteMany: {
            args: Prisma.BadgeRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BadgeRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgeRulePayload>
          }
          aggregate: {
            args: Prisma.BadgeRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadgeRule>
          }
          groupBy: {
            args: Prisma.BadgeRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeRuleCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeRuleCountAggregateOutputType> | number
          }
        }
      }
      ChallengeTemplate: {
        payload: Prisma.$ChallengeTemplatePayload<ExtArgs>
        fields: Prisma.ChallengeTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>
          }
          findFirst: {
            args: Prisma.ChallengeTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>
          }
          findMany: {
            args: Prisma.ChallengeTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>[]
          }
          create: {
            args: Prisma.ChallengeTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>
          }
          createMany: {
            args: Prisma.ChallengeTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChallengeTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>
          }
          update: {
            args: Prisma.ChallengeTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTemplatePayload>
          }
          aggregate: {
            args: Prisma.ChallengeTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeTemplate>
          }
          groupBy: {
            args: Prisma.ChallengeTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTemplateCountAggregateOutputType> | number
          }
        }
      }
      ChallengeInstance: {
        payload: Prisma.$ChallengeInstancePayload<ExtArgs>
        fields: Prisma.ChallengeInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>
          }
          findFirst: {
            args: Prisma.ChallengeInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>
          }
          findMany: {
            args: Prisma.ChallengeInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>[]
          }
          create: {
            args: Prisma.ChallengeInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>
          }
          createMany: {
            args: Prisma.ChallengeInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChallengeInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>
          }
          update: {
            args: Prisma.ChallengeInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeInstancePayload>
          }
          aggregate: {
            args: Prisma.ChallengeInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeInstance>
          }
          groupBy: {
            args: Prisma.ChallengeInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeInstanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    profileOption?: ProfileOptionOmit
    user?: UserOmit
    profile?: ProfileOmit
    category?: CategoryOmit
    interest?: InterestOmit
    venue?: VenueOmit
    activeSession?: ActiveSessionOmit
    signal?: SignalOmit
    connection?: ConnectionOmit
    message?: MessageOmit
    block?: BlockOmit
    report?: ReportOmit
    device?: DeviceOmit
    notification?: NotificationOmit
    feedback?: FeedbackOmit
    role?: RoleOmit
    auditLog?: AuditLogOmit
    broadcastNotification?: BroadcastNotificationOmit
    passwordResetToken?: PasswordResetTokenOmit
    photo?: PhotoOmit
    icebreakerQuestion?: IcebreakerQuestionOmit
    profileView?: ProfileViewOmit
    venueGroupMessage?: VenueGroupMessageOmit
    accountDeletionToken?: AccountDeletionTokenOmit
    emailChangeToken?: EmailChangeTokenOmit
    refreshToken?: RefreshTokenOmit
    groupMessageReaction?: GroupMessageReactionOmit
    checkInHistory?: CheckInHistoryOmit
    badge?: BadgeOmit
    userBadge?: UserBadgeOmit
    badgeRule?: BadgeRuleOmit
    challengeTemplate?: ChallengeTemplateOmit
    challengeInstance?: ChallengeInstanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileOptionCountOutputType
   */

  export type ProfileOptionCountOutputType = {
    profilesByOrientation: number
    profilesByGoal: number
  }

  export type ProfileOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profilesByOrientation?: boolean | ProfileOptionCountOutputTypeCountProfilesByOrientationArgs
    profilesByGoal?: boolean | ProfileOptionCountOutputTypeCountProfilesByGoalArgs
  }

  // Custom InputTypes
  /**
   * ProfileOptionCountOutputType without action
   */
  export type ProfileOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOptionCountOutputType
     */
    select?: ProfileOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileOptionCountOutputType without action
   */
  export type ProfileOptionCountOutputTypeCountProfilesByOrientationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }

  /**
   * ProfileOptionCountOutputType without action
   */
  export type ProfileOptionCountOutputTypeCountProfilesByGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sentSignals: number
    receivedSignals: number
    connectionsA: number
    connectionsB: number
    messages: number
    blockedBy: number
    blocking: number
    reportsMade: number
    reportsReceived: number
    devices: number
    notifications: number
    feedbacks: number
    auditLogs: number
    sentBroadcasts: number
    passwordResetTokens: number
    viewsMade: number
    viewsReceived: number
    venueGroupMessages: number
    refreshTokens: number
    groupMessageReactions: number
    checkInHistory: number
    badges: number
    sentChallenges: number
    receivedChallenges: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentSignals?: boolean | UserCountOutputTypeCountSentSignalsArgs
    receivedSignals?: boolean | UserCountOutputTypeCountReceivedSignalsArgs
    connectionsA?: boolean | UserCountOutputTypeCountConnectionsAArgs
    connectionsB?: boolean | UserCountOutputTypeCountConnectionsBArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    blockedBy?: boolean | UserCountOutputTypeCountBlockedByArgs
    blocking?: boolean | UserCountOutputTypeCountBlockingArgs
    reportsMade?: boolean | UserCountOutputTypeCountReportsMadeArgs
    reportsReceived?: boolean | UserCountOutputTypeCountReportsReceivedArgs
    devices?: boolean | UserCountOutputTypeCountDevicesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    feedbacks?: boolean | UserCountOutputTypeCountFeedbacksArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    sentBroadcasts?: boolean | UserCountOutputTypeCountSentBroadcastsArgs
    passwordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    viewsMade?: boolean | UserCountOutputTypeCountViewsMadeArgs
    viewsReceived?: boolean | UserCountOutputTypeCountViewsReceivedArgs
    venueGroupMessages?: boolean | UserCountOutputTypeCountVenueGroupMessagesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    groupMessageReactions?: boolean | UserCountOutputTypeCountGroupMessageReactionsArgs
    checkInHistory?: boolean | UserCountOutputTypeCountCheckInHistoryArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    sentChallenges?: boolean | UserCountOutputTypeCountSentChallengesArgs
    receivedChallenges?: boolean | UserCountOutputTypeCountReceivedChallengesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectionsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentBroadcastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadcastNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountViewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVenueGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueGroupMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupMessageReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessageReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCheckInHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstanceWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    interests: number
    photos: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | ProfileCountOutputTypeCountInterestsArgs
    photos?: boolean | ProfileCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    interests: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | CategoryCountOutputTypeCountInterestsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
  }


  /**
   * Count Type InterestCountOutputType
   */

  export type InterestCountOutputType = {
    profiles: number
  }

  export type InterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profiles?: boolean | InterestCountOutputTypeCountProfilesArgs
  }

  // Custom InputTypes
  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestCountOutputType
     */
    select?: InterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    activeSessions: number
    groupMessages: number
    checkInHistory: number
    challenges: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activeSessions?: boolean | VenueCountOutputTypeCountActiveSessionsArgs
    groupMessages?: boolean | VenueCountOutputTypeCountGroupMessagesArgs
    checkInHistory?: boolean | VenueCountOutputTypeCountCheckInHistoryArgs
    challenges?: boolean | VenueCountOutputTypeCountChallengesArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountActiveSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveSessionWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueGroupMessageWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountCheckInHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInHistoryWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstanceWhereInput
  }


  /**
   * Count Type ConnectionCountOutputType
   */

  export type ConnectionCountOutputType = {
    messages: number
    challenges: number
  }

  export type ConnectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConnectionCountOutputTypeCountMessagesArgs
    challenges?: boolean | ConnectionCountOutputTypeCountChallengesArgs
  }

  // Custom InputTypes
  /**
   * ConnectionCountOutputType without action
   */
  export type ConnectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionCountOutputType
     */
    select?: ConnectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConnectionCountOutputType without action
   */
  export type ConnectionCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ConnectionCountOutputType without action
   */
  export type ConnectionCountOutputTypeCountChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstanceWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    reports: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | MessageCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type VenueGroupMessageCountOutputType
   */

  export type VenueGroupMessageCountOutputType = {
    reports: number
    reactions: number
  }

  export type VenueGroupMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | VenueGroupMessageCountOutputTypeCountReportsArgs
    reactions?: boolean | VenueGroupMessageCountOutputTypeCountReactionsArgs
  }

  // Custom InputTypes
  /**
   * VenueGroupMessageCountOutputType without action
   */
  export type VenueGroupMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessageCountOutputType
     */
    select?: VenueGroupMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueGroupMessageCountOutputType without action
   */
  export type VenueGroupMessageCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * VenueGroupMessageCountOutputType without action
   */
  export type VenueGroupMessageCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessageReactionWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    users: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BadgeCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type BadgeRuleCountOutputType
   */

  export type BadgeRuleCountOutputType = {
    badges: number
  }

  export type BadgeRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeRuleCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeRuleCountOutputType without action
   */
  export type BadgeRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRuleCountOutputType
     */
    select?: BadgeRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeRuleCountOutputType without action
   */
  export type BadgeRuleCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
  }


  /**
   * Count Type ChallengeTemplateCountOutputType
   */

  export type ChallengeTemplateCountOutputType = {
    instances: number
  }

  export type ChallengeTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | ChallengeTemplateCountOutputTypeCountInstancesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeTemplateCountOutputType without action
   */
  export type ChallengeTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplateCountOutputType
     */
    select?: ChallengeTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeTemplateCountOutputType without action
   */
  export type ChallengeTemplateCountOutputTypeCountInstancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ProfileOption
   */

  export type AggregateProfileOption = {
    _count: ProfileOptionCountAggregateOutputType | null
    _avg: ProfileOptionAvgAggregateOutputType | null
    _sum: ProfileOptionSumAggregateOutputType | null
    _min: ProfileOptionMinAggregateOutputType | null
    _max: ProfileOptionMaxAggregateOutputType | null
  }

  export type ProfileOptionAvgAggregateOutputType = {
    id: number | null
  }

  export type ProfileOptionSumAggregateOutputType = {
    id: number | null
  }

  export type ProfileOptionMinAggregateOutputType = {
    id: number | null
    type: $Enums.OptionType | null
    code: string | null
    name: string | null
  }

  export type ProfileOptionMaxAggregateOutputType = {
    id: number | null
    type: $Enums.OptionType | null
    code: string | null
    name: string | null
  }

  export type ProfileOptionCountAggregateOutputType = {
    id: number
    type: number
    code: number
    name: number
    _all: number
  }


  export type ProfileOptionAvgAggregateInputType = {
    id?: true
  }

  export type ProfileOptionSumAggregateInputType = {
    id?: true
  }

  export type ProfileOptionMinAggregateInputType = {
    id?: true
    type?: true
    code?: true
    name?: true
  }

  export type ProfileOptionMaxAggregateInputType = {
    id?: true
    type?: true
    code?: true
    name?: true
  }

  export type ProfileOptionCountAggregateInputType = {
    id?: true
    type?: true
    code?: true
    name?: true
    _all?: true
  }

  export type ProfileOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileOption to aggregate.
     */
    where?: ProfileOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileOptions to fetch.
     */
    orderBy?: ProfileOptionOrderByWithRelationInput | ProfileOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileOptions
    **/
    _count?: true | ProfileOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileOptionMaxAggregateInputType
  }

  export type GetProfileOptionAggregateType<T extends ProfileOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileOption[P]>
      : GetScalarType<T[P], AggregateProfileOption[P]>
  }




  export type ProfileOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileOptionWhereInput
    orderBy?: ProfileOptionOrderByWithAggregationInput | ProfileOptionOrderByWithAggregationInput[]
    by: ProfileOptionScalarFieldEnum[] | ProfileOptionScalarFieldEnum
    having?: ProfileOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileOptionCountAggregateInputType | true
    _avg?: ProfileOptionAvgAggregateInputType
    _sum?: ProfileOptionSumAggregateInputType
    _min?: ProfileOptionMinAggregateInputType
    _max?: ProfileOptionMaxAggregateInputType
  }

  export type ProfileOptionGroupByOutputType = {
    id: number
    type: $Enums.OptionType
    code: string
    name: string
    _count: ProfileOptionCountAggregateOutputType | null
    _avg: ProfileOptionAvgAggregateOutputType | null
    _sum: ProfileOptionSumAggregateOutputType | null
    _min: ProfileOptionMinAggregateOutputType | null
    _max: ProfileOptionMaxAggregateOutputType | null
  }

  type GetProfileOptionGroupByPayload<T extends ProfileOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileOptionGroupByOutputType[P]>
        }
      >
    >


  export type ProfileOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    code?: boolean
    name?: boolean
    profilesByOrientation?: boolean | ProfileOption$profilesByOrientationArgs<ExtArgs>
    profilesByGoal?: boolean | ProfileOption$profilesByGoalArgs<ExtArgs>
    _count?: boolean | ProfileOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileOption"]>



  export type ProfileOptionSelectScalar = {
    id?: boolean
    type?: boolean
    code?: boolean
    name?: boolean
  }

  export type ProfileOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "code" | "name", ExtArgs["result"]["profileOption"]>
  export type ProfileOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profilesByOrientation?: boolean | ProfileOption$profilesByOrientationArgs<ExtArgs>
    profilesByGoal?: boolean | ProfileOption$profilesByGoalArgs<ExtArgs>
    _count?: boolean | ProfileOptionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProfileOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileOption"
    objects: {
      profilesByOrientation: Prisma.$ProfilePayload<ExtArgs>[]
      profilesByGoal: Prisma.$ProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.OptionType
      code: string
      name: string
    }, ExtArgs["result"]["profileOption"]>
    composites: {}
  }

  type ProfileOptionGetPayload<S extends boolean | null | undefined | ProfileOptionDefaultArgs> = $Result.GetResult<Prisma.$ProfileOptionPayload, S>

  type ProfileOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileOptionCountAggregateInputType | true
    }

  export interface ProfileOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileOption'], meta: { name: 'ProfileOption' } }
    /**
     * Find zero or one ProfileOption that matches the filter.
     * @param {ProfileOptionFindUniqueArgs} args - Arguments to find a ProfileOption
     * @example
     * // Get one ProfileOption
     * const profileOption = await prisma.profileOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileOptionFindUniqueArgs>(args: SelectSubset<T, ProfileOptionFindUniqueArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileOptionFindUniqueOrThrowArgs} args - Arguments to find a ProfileOption
     * @example
     * // Get one ProfileOption
     * const profileOption = await prisma.profileOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionFindFirstArgs} args - Arguments to find a ProfileOption
     * @example
     * // Get one ProfileOption
     * const profileOption = await prisma.profileOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileOptionFindFirstArgs>(args?: SelectSubset<T, ProfileOptionFindFirstArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionFindFirstOrThrowArgs} args - Arguments to find a ProfileOption
     * @example
     * // Get one ProfileOption
     * const profileOption = await prisma.profileOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileOptions
     * const profileOptions = await prisma.profileOption.findMany()
     * 
     * // Get first 10 ProfileOptions
     * const profileOptions = await prisma.profileOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileOptionWithIdOnly = await prisma.profileOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileOptionFindManyArgs>(args?: SelectSubset<T, ProfileOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileOption.
     * @param {ProfileOptionCreateArgs} args - Arguments to create a ProfileOption.
     * @example
     * // Create one ProfileOption
     * const ProfileOption = await prisma.profileOption.create({
     *   data: {
     *     // ... data to create a ProfileOption
     *   }
     * })
     * 
     */
    create<T extends ProfileOptionCreateArgs>(args: SelectSubset<T, ProfileOptionCreateArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileOptions.
     * @param {ProfileOptionCreateManyArgs} args - Arguments to create many ProfileOptions.
     * @example
     * // Create many ProfileOptions
     * const profileOption = await prisma.profileOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileOptionCreateManyArgs>(args?: SelectSubset<T, ProfileOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProfileOption.
     * @param {ProfileOptionDeleteArgs} args - Arguments to delete one ProfileOption.
     * @example
     * // Delete one ProfileOption
     * const ProfileOption = await prisma.profileOption.delete({
     *   where: {
     *     // ... filter to delete one ProfileOption
     *   }
     * })
     * 
     */
    delete<T extends ProfileOptionDeleteArgs>(args: SelectSubset<T, ProfileOptionDeleteArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileOption.
     * @param {ProfileOptionUpdateArgs} args - Arguments to update one ProfileOption.
     * @example
     * // Update one ProfileOption
     * const profileOption = await prisma.profileOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileOptionUpdateArgs>(args: SelectSubset<T, ProfileOptionUpdateArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileOptions.
     * @param {ProfileOptionDeleteManyArgs} args - Arguments to filter ProfileOptions to delete.
     * @example
     * // Delete a few ProfileOptions
     * const { count } = await prisma.profileOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileOptionDeleteManyArgs>(args?: SelectSubset<T, ProfileOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileOptions
     * const profileOption = await prisma.profileOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileOptionUpdateManyArgs>(args: SelectSubset<T, ProfileOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileOption.
     * @param {ProfileOptionUpsertArgs} args - Arguments to update or create a ProfileOption.
     * @example
     * // Update or create a ProfileOption
     * const profileOption = await prisma.profileOption.upsert({
     *   create: {
     *     // ... data to create a ProfileOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileOption we want to update
     *   }
     * })
     */
    upsert<T extends ProfileOptionUpsertArgs>(args: SelectSubset<T, ProfileOptionUpsertArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionCountArgs} args - Arguments to filter ProfileOptions to count.
     * @example
     * // Count the number of ProfileOptions
     * const count = await prisma.profileOption.count({
     *   where: {
     *     // ... the filter for the ProfileOptions we want to count
     *   }
     * })
    **/
    count<T extends ProfileOptionCountArgs>(
      args?: Subset<T, ProfileOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileOptionAggregateArgs>(args: Subset<T, ProfileOptionAggregateArgs>): Prisma.PrismaPromise<GetProfileOptionAggregateType<T>>

    /**
     * Group by ProfileOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileOptionGroupByArgs['orderBy'] }
        : { orderBy?: ProfileOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileOption model
   */
  readonly fields: ProfileOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profilesByOrientation<T extends ProfileOption$profilesByOrientationArgs<ExtArgs> = {}>(args?: Subset<T, ProfileOption$profilesByOrientationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    profilesByGoal<T extends ProfileOption$profilesByGoalArgs<ExtArgs> = {}>(args?: Subset<T, ProfileOption$profilesByGoalArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileOption model
   */
  interface ProfileOptionFieldRefs {
    readonly id: FieldRef<"ProfileOption", 'Int'>
    readonly type: FieldRef<"ProfileOption", 'OptionType'>
    readonly code: FieldRef<"ProfileOption", 'String'>
    readonly name: FieldRef<"ProfileOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProfileOption findUnique
   */
  export type ProfileOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProfileOption to fetch.
     */
    where: ProfileOptionWhereUniqueInput
  }

  /**
   * ProfileOption findUniqueOrThrow
   */
  export type ProfileOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProfileOption to fetch.
     */
    where: ProfileOptionWhereUniqueInput
  }

  /**
   * ProfileOption findFirst
   */
  export type ProfileOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProfileOption to fetch.
     */
    where?: ProfileOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileOptions to fetch.
     */
    orderBy?: ProfileOptionOrderByWithRelationInput | ProfileOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileOptions.
     */
    cursor?: ProfileOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileOptions.
     */
    distinct?: ProfileOptionScalarFieldEnum | ProfileOptionScalarFieldEnum[]
  }

  /**
   * ProfileOption findFirstOrThrow
   */
  export type ProfileOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProfileOption to fetch.
     */
    where?: ProfileOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileOptions to fetch.
     */
    orderBy?: ProfileOptionOrderByWithRelationInput | ProfileOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileOptions.
     */
    cursor?: ProfileOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileOptions.
     */
    distinct?: ProfileOptionScalarFieldEnum | ProfileOptionScalarFieldEnum[]
  }

  /**
   * ProfileOption findMany
   */
  export type ProfileOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProfileOptions to fetch.
     */
    where?: ProfileOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileOptions to fetch.
     */
    orderBy?: ProfileOptionOrderByWithRelationInput | ProfileOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileOptions.
     */
    cursor?: ProfileOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileOptions.
     */
    skip?: number
    distinct?: ProfileOptionScalarFieldEnum | ProfileOptionScalarFieldEnum[]
  }

  /**
   * ProfileOption create
   */
  export type ProfileOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileOption.
     */
    data: XOR<ProfileOptionCreateInput, ProfileOptionUncheckedCreateInput>
  }

  /**
   * ProfileOption createMany
   */
  export type ProfileOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileOptions.
     */
    data: ProfileOptionCreateManyInput | ProfileOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileOption update
   */
  export type ProfileOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileOption.
     */
    data: XOR<ProfileOptionUpdateInput, ProfileOptionUncheckedUpdateInput>
    /**
     * Choose, which ProfileOption to update.
     */
    where: ProfileOptionWhereUniqueInput
  }

  /**
   * ProfileOption updateMany
   */
  export type ProfileOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileOptions.
     */
    data: XOR<ProfileOptionUpdateManyMutationInput, ProfileOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProfileOptions to update
     */
    where?: ProfileOptionWhereInput
    /**
     * Limit how many ProfileOptions to update.
     */
    limit?: number
  }

  /**
   * ProfileOption upsert
   */
  export type ProfileOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileOption to update in case it exists.
     */
    where: ProfileOptionWhereUniqueInput
    /**
     * In case the ProfileOption found by the `where` argument doesn't exist, create a new ProfileOption with this data.
     */
    create: XOR<ProfileOptionCreateInput, ProfileOptionUncheckedCreateInput>
    /**
     * In case the ProfileOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileOptionUpdateInput, ProfileOptionUncheckedUpdateInput>
  }

  /**
   * ProfileOption delete
   */
  export type ProfileOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    /**
     * Filter which ProfileOption to delete.
     */
    where: ProfileOptionWhereUniqueInput
  }

  /**
   * ProfileOption deleteMany
   */
  export type ProfileOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileOptions to delete
     */
    where?: ProfileOptionWhereInput
    /**
     * Limit how many ProfileOptions to delete.
     */
    limit?: number
  }

  /**
   * ProfileOption.profilesByOrientation
   */
  export type ProfileOption$profilesByOrientationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * ProfileOption.profilesByGoal
   */
  export type ProfileOption$profilesByGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * ProfileOption without action
   */
  export type ProfileOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    authProvider: $Enums.AuthProvider | null
    googleId: string | null
    appleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: number | null
    isActive: boolean | null
    subscription: $Enums.SubscriptionPlan | null
    subscriptionExpiresAt: Date | null
    premiumExpiresAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    authProvider: $Enums.AuthProvider | null
    googleId: string | null
    appleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    roleId: number | null
    isActive: boolean | null
    subscription: $Enums.SubscriptionPlan | null
    subscriptionExpiresAt: Date | null
    premiumExpiresAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    authProvider: number
    googleId: number
    appleId: number
    createdAt: number
    updatedAt: number
    roleId: number
    isActive: number
    subscription: number
    subscriptionExpiresAt: number
    premiumExpiresAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    authProvider?: true
    googleId?: true
    appleId?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    isActive?: true
    subscription?: true
    subscriptionExpiresAt?: true
    premiumExpiresAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    authProvider?: true
    googleId?: true
    appleId?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    isActive?: true
    subscription?: true
    subscriptionExpiresAt?: true
    premiumExpiresAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    authProvider?: true
    googleId?: true
    appleId?: true
    createdAt?: true
    updatedAt?: true
    roleId?: true
    isActive?: true
    subscription?: true
    subscriptionExpiresAt?: true
    premiumExpiresAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    authProvider: $Enums.AuthProvider
    googleId: string | null
    appleId: string | null
    createdAt: Date
    updatedAt: Date
    roleId: number
    isActive: boolean
    subscription: $Enums.SubscriptionPlan
    subscriptionExpiresAt: Date | null
    premiumExpiresAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    authProvider?: boolean
    googleId?: boolean
    appleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    isActive?: boolean
    subscription?: boolean
    subscriptionExpiresAt?: boolean
    premiumExpiresAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    activeSession?: boolean | User$activeSessionArgs<ExtArgs>
    sentSignals?: boolean | User$sentSignalsArgs<ExtArgs>
    receivedSignals?: boolean | User$receivedSignalsArgs<ExtArgs>
    connectionsA?: boolean | User$connectionsAArgs<ExtArgs>
    connectionsB?: boolean | User$connectionsBArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    blockedBy?: boolean | User$blockedByArgs<ExtArgs>
    blocking?: boolean | User$blockingArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sentBroadcasts?: boolean | User$sentBroadcastsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    viewsMade?: boolean | User$viewsMadeArgs<ExtArgs>
    viewsReceived?: boolean | User$viewsReceivedArgs<ExtArgs>
    venueGroupMessages?: boolean | User$venueGroupMessagesArgs<ExtArgs>
    accountDeletionToken?: boolean | User$accountDeletionTokenArgs<ExtArgs>
    emailChangeToken?: boolean | User$emailChangeTokenArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    groupMessageReactions?: boolean | User$groupMessageReactionsArgs<ExtArgs>
    checkInHistory?: boolean | User$checkInHistoryArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    sentChallenges?: boolean | User$sentChallengesArgs<ExtArgs>
    receivedChallenges?: boolean | User$receivedChallengesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    authProvider?: boolean
    googleId?: boolean
    appleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roleId?: boolean
    isActive?: boolean
    subscription?: boolean
    subscriptionExpiresAt?: boolean
    premiumExpiresAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "authProvider" | "googleId" | "appleId" | "createdAt" | "updatedAt" | "roleId" | "isActive" | "subscription" | "subscriptionExpiresAt" | "premiumExpiresAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    activeSession?: boolean | User$activeSessionArgs<ExtArgs>
    sentSignals?: boolean | User$sentSignalsArgs<ExtArgs>
    receivedSignals?: boolean | User$receivedSignalsArgs<ExtArgs>
    connectionsA?: boolean | User$connectionsAArgs<ExtArgs>
    connectionsB?: boolean | User$connectionsBArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    blockedBy?: boolean | User$blockedByArgs<ExtArgs>
    blocking?: boolean | User$blockingArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    reportsReceived?: boolean | User$reportsReceivedArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    feedbacks?: boolean | User$feedbacksArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    sentBroadcasts?: boolean | User$sentBroadcastsArgs<ExtArgs>
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>
    viewsMade?: boolean | User$viewsMadeArgs<ExtArgs>
    viewsReceived?: boolean | User$viewsReceivedArgs<ExtArgs>
    venueGroupMessages?: boolean | User$venueGroupMessagesArgs<ExtArgs>
    accountDeletionToken?: boolean | User$accountDeletionTokenArgs<ExtArgs>
    emailChangeToken?: boolean | User$emailChangeTokenArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    groupMessageReactions?: boolean | User$groupMessageReactionsArgs<ExtArgs>
    checkInHistory?: boolean | User$checkInHistoryArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    sentChallenges?: boolean | User$sentChallengesArgs<ExtArgs>
    receivedChallenges?: boolean | User$receivedChallengesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      activeSession: Prisma.$ActiveSessionPayload<ExtArgs> | null
      sentSignals: Prisma.$SignalPayload<ExtArgs>[]
      receivedSignals: Prisma.$SignalPayload<ExtArgs>[]
      connectionsA: Prisma.$ConnectionPayload<ExtArgs>[]
      connectionsB: Prisma.$ConnectionPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      blockedBy: Prisma.$BlockPayload<ExtArgs>[]
      blocking: Prisma.$BlockPayload<ExtArgs>[]
      reportsMade: Prisma.$ReportPayload<ExtArgs>[]
      reportsReceived: Prisma.$ReportPayload<ExtArgs>[]
      devices: Prisma.$DevicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      feedbacks: Prisma.$FeedbackPayload<ExtArgs>[]
      role: Prisma.$RolePayload<ExtArgs>
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      sentBroadcasts: Prisma.$BroadcastNotificationPayload<ExtArgs>[]
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      viewsMade: Prisma.$ProfileViewPayload<ExtArgs>[]
      viewsReceived: Prisma.$ProfileViewPayload<ExtArgs>[]
      venueGroupMessages: Prisma.$VenueGroupMessagePayload<ExtArgs>[]
      accountDeletionToken: Prisma.$AccountDeletionTokenPayload<ExtArgs> | null
      emailChangeToken: Prisma.$EmailChangeTokenPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      groupMessageReactions: Prisma.$GroupMessageReactionPayload<ExtArgs>[]
      checkInHistory: Prisma.$CheckInHistoryPayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      sentChallenges: Prisma.$ChallengeInstancePayload<ExtArgs>[]
      receivedChallenges: Prisma.$ChallengeInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      authProvider: $Enums.AuthProvider
      googleId: string | null
      appleId: string | null
      createdAt: Date
      updatedAt: Date
      roleId: number
      isActive: boolean
      subscription: $Enums.SubscriptionPlan
      subscriptionExpiresAt: Date | null
      premiumExpiresAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activeSession<T extends User$activeSessionArgs<ExtArgs> = {}>(args?: Subset<T, User$activeSessionArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sentSignals<T extends User$sentSignalsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentSignalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedSignals<T extends User$receivedSignalsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedSignalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    connectionsA<T extends User$connectionsAArgs<ExtArgs> = {}>(args?: Subset<T, User$connectionsAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    connectionsB<T extends User$connectionsBArgs<ExtArgs> = {}>(args?: Subset<T, User$connectionsBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedBy<T extends User$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, User$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocking<T extends User$blockingArgs<ExtArgs> = {}>(args?: Subset<T, User$blockingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsMade<T extends User$reportsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportsReceived<T extends User$reportsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends User$devicesArgs<ExtArgs> = {}>(args?: Subset<T, User$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends User$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, User$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentBroadcasts<T extends User$sentBroadcastsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentBroadcastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewsMade<T extends User$viewsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$viewsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    viewsReceived<T extends User$viewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$viewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    venueGroupMessages<T extends User$venueGroupMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$venueGroupMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accountDeletionToken<T extends User$accountDeletionTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$accountDeletionTokenArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailChangeToken<T extends User$emailChangeTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$emailChangeTokenArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMessageReactions<T extends User$groupMessageReactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$groupMessageReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkInHistory<T extends User$checkInHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$checkInHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentChallenges<T extends User$sentChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedChallenges<T extends User$receivedChallengesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly authProvider: FieldRef<"User", 'AuthProvider'>
    readonly googleId: FieldRef<"User", 'String'>
    readonly appleId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly subscription: FieldRef<"User", 'SubscriptionPlan'>
    readonly subscriptionExpiresAt: FieldRef<"User", 'DateTime'>
    readonly premiumExpiresAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.activeSession
   */
  export type User$activeSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    where?: ActiveSessionWhereInput
  }

  /**
   * User.sentSignals
   */
  export type User$sentSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    cursor?: SignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * User.receivedSignals
   */
  export type User$receivedSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    cursor?: SignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * User.connectionsA
   */
  export type User$connectionsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * User.connectionsB
   */
  export type User$connectionsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.blockedBy
   */
  export type User$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * User.blocking
   */
  export type User$blockingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * User.reportsMade
   */
  export type User$reportsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.reportsReceived
   */
  export type User$reportsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.devices
   */
  export type User$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.feedbacks
   */
  export type User$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.sentBroadcasts
   */
  export type User$sentBroadcastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    where?: BroadcastNotificationWhereInput
    orderBy?: BroadcastNotificationOrderByWithRelationInput | BroadcastNotificationOrderByWithRelationInput[]
    cursor?: BroadcastNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BroadcastNotificationScalarFieldEnum | BroadcastNotificationScalarFieldEnum[]
  }

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.viewsMade
   */
  export type User$viewsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    where?: ProfileViewWhereInput
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    cursor?: ProfileViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * User.viewsReceived
   */
  export type User$viewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    where?: ProfileViewWhereInput
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    cursor?: ProfileViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * User.venueGroupMessages
   */
  export type User$venueGroupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    where?: VenueGroupMessageWhereInput
    orderBy?: VenueGroupMessageOrderByWithRelationInput | VenueGroupMessageOrderByWithRelationInput[]
    cursor?: VenueGroupMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueGroupMessageScalarFieldEnum | VenueGroupMessageScalarFieldEnum[]
  }

  /**
   * User.accountDeletionToken
   */
  export type User$accountDeletionTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    where?: AccountDeletionTokenWhereInput
  }

  /**
   * User.emailChangeToken
   */
  export type User$emailChangeTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    where?: EmailChangeTokenWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.groupMessageReactions
   */
  export type User$groupMessageReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    where?: GroupMessageReactionWhereInput
    orderBy?: GroupMessageReactionOrderByWithRelationInput | GroupMessageReactionOrderByWithRelationInput[]
    cursor?: GroupMessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessageReactionScalarFieldEnum | GroupMessageReactionScalarFieldEnum[]
  }

  /**
   * User.checkInHistory
   */
  export type User$checkInHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    where?: CheckInHistoryWhereInput
    orderBy?: CheckInHistoryOrderByWithRelationInput | CheckInHistoryOrderByWithRelationInput[]
    cursor?: CheckInHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInHistoryScalarFieldEnum | CheckInHistoryScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.sentChallenges
   */
  export type User$sentChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    where?: ChallengeInstanceWhereInput
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    cursor?: ChallengeInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * User.receivedChallenges
   */
  export type User$receivedChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    where?: ChallengeInstanceWhereInput
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    cursor?: ChallengeInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    age: number | null
    extraSignalCredits: number | null
    preferredMinAge: number | null
    preferredMaxAge: number | null
    provisionalSignalsUsed: number | null
    sexualOrientationId: number | null
    relationshipGoalId: number | null
  }

  export type ProfileSumAggregateOutputType = {
    age: number | null
    extraSignalCredits: number | null
    preferredMinAge: number | null
    preferredMaxAge: number | null
    provisionalSignalsUsed: number | null
    sexualOrientationId: number | null
    relationshipGoalId: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    gender: string | null
    bio: string | null
    university: string | null
    city: string | null
    personality: $Enums.PersonalityType | null
    userId: string | null
    phoneNumber: string | null
    extraSignalCredits: number | null
    hideViewFootprints: boolean | null
    preferredMinAge: number | null
    preferredMaxAge: number | null
    notifyOnNewSignal: boolean | null
    notifyOnNewMatch: boolean | null
    notifyOnNewMessage: boolean | null
    isVerified: boolean | null
    verificationStatus: $Enums.VerificationStatus | null
    verificationPhotoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    provisionalSignalsUsed: number | null
    currentStatus: string | null
    statusExpiresAt: Date | null
    sexualOrientationId: number | null
    relationshipGoalId: number | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    age: number | null
    gender: string | null
    bio: string | null
    university: string | null
    city: string | null
    personality: $Enums.PersonalityType | null
    userId: string | null
    phoneNumber: string | null
    extraSignalCredits: number | null
    hideViewFootprints: boolean | null
    preferredMinAge: number | null
    preferredMaxAge: number | null
    notifyOnNewSignal: boolean | null
    notifyOnNewMatch: boolean | null
    notifyOnNewMessage: boolean | null
    isVerified: boolean | null
    verificationStatus: $Enums.VerificationStatus | null
    verificationPhotoUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    provisionalSignalsUsed: number | null
    currentStatus: string | null
    statusExpiresAt: Date | null
    sexualOrientationId: number | null
    relationshipGoalId: number | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    name: number
    age: number
    gender: number
    bio: number
    university: number
    city: number
    personality: number
    userId: number
    phoneNumber: number
    extraSignalCredits: number
    hideViewFootprints: number
    preferredMinAge: number
    preferredMaxAge: number
    notifyOnNewSignal: number
    notifyOnNewMatch: number
    notifyOnNewMessage: number
    isVerified: number
    verificationStatus: number
    verificationPhotoUrl: number
    createdAt: number
    updatedAt: number
    provisionalSignalsUsed: number
    currentStatus: number
    statusExpiresAt: number
    sexualOrientationId: number
    relationshipGoalId: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    age?: true
    extraSignalCredits?: true
    preferredMinAge?: true
    preferredMaxAge?: true
    provisionalSignalsUsed?: true
    sexualOrientationId?: true
    relationshipGoalId?: true
  }

  export type ProfileSumAggregateInputType = {
    age?: true
    extraSignalCredits?: true
    preferredMinAge?: true
    preferredMaxAge?: true
    provisionalSignalsUsed?: true
    sexualOrientationId?: true
    relationshipGoalId?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    bio?: true
    university?: true
    city?: true
    personality?: true
    userId?: true
    phoneNumber?: true
    extraSignalCredits?: true
    hideViewFootprints?: true
    preferredMinAge?: true
    preferredMaxAge?: true
    notifyOnNewSignal?: true
    notifyOnNewMatch?: true
    notifyOnNewMessage?: true
    isVerified?: true
    verificationStatus?: true
    verificationPhotoUrl?: true
    createdAt?: true
    updatedAt?: true
    provisionalSignalsUsed?: true
    currentStatus?: true
    statusExpiresAt?: true
    sexualOrientationId?: true
    relationshipGoalId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    bio?: true
    university?: true
    city?: true
    personality?: true
    userId?: true
    phoneNumber?: true
    extraSignalCredits?: true
    hideViewFootprints?: true
    preferredMinAge?: true
    preferredMaxAge?: true
    notifyOnNewSignal?: true
    notifyOnNewMatch?: true
    notifyOnNewMessage?: true
    isVerified?: true
    verificationStatus?: true
    verificationPhotoUrl?: true
    createdAt?: true
    updatedAt?: true
    provisionalSignalsUsed?: true
    currentStatus?: true
    statusExpiresAt?: true
    sexualOrientationId?: true
    relationshipGoalId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    name?: true
    age?: true
    gender?: true
    bio?: true
    university?: true
    city?: true
    personality?: true
    userId?: true
    phoneNumber?: true
    extraSignalCredits?: true
    hideViewFootprints?: true
    preferredMinAge?: true
    preferredMaxAge?: true
    notifyOnNewSignal?: true
    notifyOnNewMatch?: true
    notifyOnNewMessage?: true
    isVerified?: true
    verificationStatus?: true
    verificationPhotoUrl?: true
    createdAt?: true
    updatedAt?: true
    provisionalSignalsUsed?: true
    currentStatus?: true
    statusExpiresAt?: true
    sexualOrientationId?: true
    relationshipGoalId?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    name: string
    age: number
    gender: string
    bio: string | null
    university: string | null
    city: string | null
    personality: $Enums.PersonalityType | null
    userId: string
    phoneNumber: string | null
    extraSignalCredits: number
    hideViewFootprints: boolean
    preferredMinAge: number | null
    preferredMaxAge: number | null
    notifyOnNewSignal: boolean
    notifyOnNewMatch: boolean
    notifyOnNewMessage: boolean
    isVerified: boolean
    verificationStatus: $Enums.VerificationStatus
    verificationPhotoUrl: string | null
    createdAt: Date
    updatedAt: Date | null
    provisionalSignalsUsed: number
    currentStatus: string | null
    statusExpiresAt: Date | null
    sexualOrientationId: number | null
    relationshipGoalId: number | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    bio?: boolean
    university?: boolean
    city?: boolean
    personality?: boolean
    userId?: boolean
    phoneNumber?: boolean
    extraSignalCredits?: boolean
    hideViewFootprints?: boolean
    preferredMinAge?: boolean
    preferredMaxAge?: boolean
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: boolean
    verificationPhotoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provisionalSignalsUsed?: boolean
    currentStatus?: boolean
    statusExpiresAt?: boolean
    sexualOrientationId?: boolean
    relationshipGoalId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    interests?: boolean | Profile$interestsArgs<ExtArgs>
    photos?: boolean | Profile$photosArgs<ExtArgs>
    sexualOrientation?: boolean | Profile$sexualOrientationArgs<ExtArgs>
    relationshipGoal?: boolean | Profile$relationshipGoalArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>



  export type ProfileSelectScalar = {
    id?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    bio?: boolean
    university?: boolean
    city?: boolean
    personality?: boolean
    userId?: boolean
    phoneNumber?: boolean
    extraSignalCredits?: boolean
    hideViewFootprints?: boolean
    preferredMinAge?: boolean
    preferredMaxAge?: boolean
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: boolean
    verificationPhotoUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provisionalSignalsUsed?: boolean
    currentStatus?: boolean
    statusExpiresAt?: boolean
    sexualOrientationId?: boolean
    relationshipGoalId?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "age" | "gender" | "bio" | "university" | "city" | "personality" | "userId" | "phoneNumber" | "extraSignalCredits" | "hideViewFootprints" | "preferredMinAge" | "preferredMaxAge" | "notifyOnNewSignal" | "notifyOnNewMatch" | "notifyOnNewMessage" | "isVerified" | "verificationStatus" | "verificationPhotoUrl" | "createdAt" | "updatedAt" | "provisionalSignalsUsed" | "currentStatus" | "statusExpiresAt" | "sexualOrientationId" | "relationshipGoalId", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    interests?: boolean | Profile$interestsArgs<ExtArgs>
    photos?: boolean | Profile$photosArgs<ExtArgs>
    sexualOrientation?: boolean | Profile$sexualOrientationArgs<ExtArgs>
    relationshipGoal?: boolean | Profile$relationshipGoalArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      interests: Prisma.$InterestPayload<ExtArgs>[]
      photos: Prisma.$PhotoPayload<ExtArgs>[]
      sexualOrientation: Prisma.$ProfileOptionPayload<ExtArgs> | null
      relationshipGoal: Prisma.$ProfileOptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      age: number
      gender: string
      bio: string | null
      university: string | null
      city: string | null
      personality: $Enums.PersonalityType | null
      userId: string
      phoneNumber: string | null
      extraSignalCredits: number
      hideViewFootprints: boolean
      preferredMinAge: number | null
      preferredMaxAge: number | null
      notifyOnNewSignal: boolean
      notifyOnNewMatch: boolean
      notifyOnNewMessage: boolean
      isVerified: boolean
      verificationStatus: $Enums.VerificationStatus
      verificationPhotoUrl: string | null
      createdAt: Date
      updatedAt: Date | null
      provisionalSignalsUsed: number
      currentStatus: string | null
      statusExpiresAt: Date | null
      sexualOrientationId: number | null
      relationshipGoalId: number | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interests<T extends Profile$interestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    photos<T extends Profile$photosArgs<ExtArgs> = {}>(args?: Subset<T, Profile$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sexualOrientation<T extends Profile$sexualOrientationArgs<ExtArgs> = {}>(args?: Subset<T, Profile$sexualOrientationArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    relationshipGoal<T extends Profile$relationshipGoalArgs<ExtArgs> = {}>(args?: Subset<T, Profile$relationshipGoalArgs<ExtArgs>>): Prisma__ProfileOptionClient<$Result.GetResult<Prisma.$ProfileOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly name: FieldRef<"Profile", 'String'>
    readonly age: FieldRef<"Profile", 'Int'>
    readonly gender: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly university: FieldRef<"Profile", 'String'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly personality: FieldRef<"Profile", 'PersonalityType'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly phoneNumber: FieldRef<"Profile", 'String'>
    readonly extraSignalCredits: FieldRef<"Profile", 'Int'>
    readonly hideViewFootprints: FieldRef<"Profile", 'Boolean'>
    readonly preferredMinAge: FieldRef<"Profile", 'Int'>
    readonly preferredMaxAge: FieldRef<"Profile", 'Int'>
    readonly notifyOnNewSignal: FieldRef<"Profile", 'Boolean'>
    readonly notifyOnNewMatch: FieldRef<"Profile", 'Boolean'>
    readonly notifyOnNewMessage: FieldRef<"Profile", 'Boolean'>
    readonly isVerified: FieldRef<"Profile", 'Boolean'>
    readonly verificationStatus: FieldRef<"Profile", 'VerificationStatus'>
    readonly verificationPhotoUrl: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly provisionalSignalsUsed: FieldRef<"Profile", 'Int'>
    readonly currentStatus: FieldRef<"Profile", 'String'>
    readonly statusExpiresAt: FieldRef<"Profile", 'DateTime'>
    readonly sexualOrientationId: FieldRef<"Profile", 'Int'>
    readonly relationshipGoalId: FieldRef<"Profile", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.interests
   */
  export type Profile$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    cursor?: InterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Profile.photos
   */
  export type Profile$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    cursor?: PhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Profile.sexualOrientation
   */
  export type Profile$sexualOrientationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    where?: ProfileOptionWhereInput
  }

  /**
   * Profile.relationshipGoal
   */
  export type Profile$relationshipGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileOption
     */
    select?: ProfileOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileOption
     */
    omit?: ProfileOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileOptionInclude<ExtArgs> | null
    where?: ProfileOptionWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    interests?: boolean | Category$interestsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | Category$interestsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      interests: Prisma.$InterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interests<T extends Category$interestsArgs<ExtArgs> = {}>(args?: Subset<T, Category$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.interests
   */
  export type Category$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    cursor?: InterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Interest
   */

  export type AggregateInterest = {
    _count: InterestCountAggregateOutputType | null
    _avg: InterestAvgAggregateOutputType | null
    _sum: InterestSumAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  export type InterestAvgAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type InterestSumAggregateOutputType = {
    id: number | null
    categoryId: number | null
  }

  export type InterestMinAggregateOutputType = {
    id: number | null
    name: string | null
    categoryId: number | null
  }

  export type InterestMaxAggregateOutputType = {
    id: number | null
    name: string | null
    categoryId: number | null
  }

  export type InterestCountAggregateOutputType = {
    id: number
    name: number
    categoryId: number
    _all: number
  }


  export type InterestAvgAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type InterestSumAggregateInputType = {
    id?: true
    categoryId?: true
  }

  export type InterestMinAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
  }

  export type InterestMaxAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
  }

  export type InterestCountAggregateInputType = {
    id?: true
    name?: true
    categoryId?: true
    _all?: true
  }

  export type InterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interest to aggregate.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interests
    **/
    _count?: true | InterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestMaxAggregateInputType
  }

  export type GetInterestAggregateType<T extends InterestAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest[P]>
      : GetScalarType<T[P], AggregateInterest[P]>
  }




  export type InterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithAggregationInput | InterestOrderByWithAggregationInput[]
    by: InterestScalarFieldEnum[] | InterestScalarFieldEnum
    having?: InterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestCountAggregateInputType | true
    _avg?: InterestAvgAggregateInputType
    _sum?: InterestSumAggregateInputType
    _min?: InterestMinAggregateInputType
    _max?: InterestMaxAggregateInputType
  }

  export type InterestGroupByOutputType = {
    id: number
    name: string
    categoryId: number
    _count: InterestCountAggregateOutputType | null
    _avg: InterestAvgAggregateOutputType | null
    _sum: InterestSumAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  type GetInterestGroupByPayload<T extends InterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestGroupByOutputType[P]>
            : GetScalarType<T[P], InterestGroupByOutputType[P]>
        }
      >
    >


  export type InterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    profiles?: boolean | Interest$profilesArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interest"]>



  export type InterestSelectScalar = {
    id?: boolean
    name?: boolean
    categoryId?: boolean
  }

  export type InterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "categoryId", ExtArgs["result"]["interest"]>
  export type InterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    profiles?: boolean | Interest$profilesArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interest"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      profiles: Prisma.$ProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      categoryId: number
    }, ExtArgs["result"]["interest"]>
    composites: {}
  }

  type InterestGetPayload<S extends boolean | null | undefined | InterestDefaultArgs> = $Result.GetResult<Prisma.$InterestPayload, S>

  type InterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestCountAggregateInputType | true
    }

  export interface InterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interest'], meta: { name: 'Interest' } }
    /**
     * Find zero or one Interest that matches the filter.
     * @param {InterestFindUniqueArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestFindUniqueArgs>(args: SelectSubset<T, InterestFindUniqueArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestFindUniqueOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestFindFirstArgs>(args?: SelectSubset<T, InterestFindFirstArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interests
     * const interests = await prisma.interest.findMany()
     * 
     * // Get first 10 Interests
     * const interests = await prisma.interest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestWithIdOnly = await prisma.interest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestFindManyArgs>(args?: SelectSubset<T, InterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interest.
     * @param {InterestCreateArgs} args - Arguments to create a Interest.
     * @example
     * // Create one Interest
     * const Interest = await prisma.interest.create({
     *   data: {
     *     // ... data to create a Interest
     *   }
     * })
     * 
     */
    create<T extends InterestCreateArgs>(args: SelectSubset<T, InterestCreateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interests.
     * @param {InterestCreateManyArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestCreateManyArgs>(args?: SelectSubset<T, InterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Interest.
     * @param {InterestDeleteArgs} args - Arguments to delete one Interest.
     * @example
     * // Delete one Interest
     * const Interest = await prisma.interest.delete({
     *   where: {
     *     // ... filter to delete one Interest
     *   }
     * })
     * 
     */
    delete<T extends InterestDeleteArgs>(args: SelectSubset<T, InterestDeleteArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interest.
     * @param {InterestUpdateArgs} args - Arguments to update one Interest.
     * @example
     * // Update one Interest
     * const interest = await prisma.interest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestUpdateArgs>(args: SelectSubset<T, InterestUpdateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interests.
     * @param {InterestDeleteManyArgs} args - Arguments to filter Interests to delete.
     * @example
     * // Delete a few Interests
     * const { count } = await prisma.interest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDeleteManyArgs>(args?: SelectSubset<T, InterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestUpdateManyArgs>(args: SelectSubset<T, InterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interest.
     * @param {InterestUpsertArgs} args - Arguments to update or create a Interest.
     * @example
     * // Update or create a Interest
     * const interest = await prisma.interest.upsert({
     *   create: {
     *     // ... data to create a Interest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest we want to update
     *   }
     * })
     */
    upsert<T extends InterestUpsertArgs>(args: SelectSubset<T, InterestUpsertArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestCountArgs} args - Arguments to filter Interests to count.
     * @example
     * // Count the number of Interests
     * const count = await prisma.interest.count({
     *   where: {
     *     // ... the filter for the Interests we want to count
     *   }
     * })
    **/
    count<T extends InterestCountArgs>(
      args?: Subset<T, InterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestAggregateArgs>(args: Subset<T, InterestAggregateArgs>): Prisma.PrismaPromise<GetInterestAggregateType<T>>

    /**
     * Group by Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestGroupByArgs['orderBy'] }
        : { orderBy?: InterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interest model
   */
  readonly fields: InterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profiles<T extends Interest$profilesArgs<ExtArgs> = {}>(args?: Subset<T, Interest$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interest model
   */
  interface InterestFieldRefs {
    readonly id: FieldRef<"Interest", 'Int'>
    readonly name: FieldRef<"Interest", 'String'>
    readonly categoryId: FieldRef<"Interest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Interest findUnique
   */
  export type InterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findUniqueOrThrow
   */
  export type InterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findFirst
   */
  export type InterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findFirstOrThrow
   */
  export type InterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findMany
   */
  export type InterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interests to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest create
   */
  export type InterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to create a Interest.
     */
    data: XOR<InterestCreateInput, InterestUncheckedCreateInput>
  }

  /**
   * Interest createMany
   */
  export type InterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest update
   */
  export type InterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to update a Interest.
     */
    data: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
    /**
     * Choose, which Interest to update.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest updateMany
   */
  export type InterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest upsert
   */
  export type InterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The filter to search for the Interest to update in case it exists.
     */
    where: InterestWhereUniqueInput
    /**
     * In case the Interest found by the `where` argument doesn't exist, create a new Interest with this data.
     */
    create: XOR<InterestCreateInput, InterestUncheckedCreateInput>
    /**
     * In case the Interest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
  }

  /**
   * Interest delete
   */
  export type InterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter which Interest to delete.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest deleteMany
   */
  export type InterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interests to delete
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to delete.
     */
    limit?: number
  }

  /**
   * Interest.profiles
   */
  export type Interest$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Interest without action
   */
  export type InterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type VenueSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    description: string | null
    latitude: number | null
    longitude: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    category: $Enums.VenueCategory | null
  }

  export type VenueMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    description: string | null
    latitude: number | null
    longitude: number | null
    isActive: boolean | null
    isFeatured: boolean | null
    category: $Enums.VenueCategory | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    name: number
    address: number
    description: number
    latitude: number
    longitude: number
    isActive: number
    isFeatured: number
    category: number
    statsSummary: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type VenueSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    description?: true
    latitude?: true
    longitude?: true
    isActive?: true
    isFeatured?: true
    category?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    description?: true
    latitude?: true
    longitude?: true
    isActive?: true
    isFeatured?: true
    category?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    description?: true
    latitude?: true
    longitude?: true
    isActive?: true
    isFeatured?: true
    category?: true
    statsSummary?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: number
    name: string
    address: string | null
    description: string | null
    latitude: number
    longitude: number
    isActive: boolean
    isFeatured: boolean
    category: $Enums.VenueCategory
    statsSummary: JsonValue | null
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    isActive?: boolean
    isFeatured?: boolean
    category?: boolean
    statsSummary?: boolean
    activeSessions?: boolean | Venue$activeSessionsArgs<ExtArgs>
    groupMessages?: boolean | Venue$groupMessagesArgs<ExtArgs>
    checkInHistory?: boolean | Venue$checkInHistoryArgs<ExtArgs>
    challenges?: boolean | Venue$challengesArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>



  export type VenueSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    description?: boolean
    latitude?: boolean
    longitude?: boolean
    isActive?: boolean
    isFeatured?: boolean
    category?: boolean
    statsSummary?: boolean
  }

  export type VenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "description" | "latitude" | "longitude" | "isActive" | "isFeatured" | "category" | "statsSummary", ExtArgs["result"]["venue"]>
  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activeSessions?: boolean | Venue$activeSessionsArgs<ExtArgs>
    groupMessages?: boolean | Venue$groupMessagesArgs<ExtArgs>
    checkInHistory?: boolean | Venue$checkInHistoryArgs<ExtArgs>
    challenges?: boolean | Venue$challengesArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      activeSessions: Prisma.$ActiveSessionPayload<ExtArgs>[]
      groupMessages: Prisma.$VenueGroupMessagePayload<ExtArgs>[]
      checkInHistory: Prisma.$CheckInHistoryPayload<ExtArgs>[]
      challenges: Prisma.$ChallengeInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      description: string | null
      latitude: number
      longitude: number
      isActive: boolean
      isFeatured: boolean
      category: $Enums.VenueCategory
      statsSummary: Prisma.JsonValue | null
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activeSessions<T extends Venue$activeSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$activeSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupMessages<T extends Venue$groupMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$groupMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    checkInHistory<T extends Venue$checkInHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Venue$checkInHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenges<T extends Venue$challengesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'Int'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly address: FieldRef<"Venue", 'String'>
    readonly description: FieldRef<"Venue", 'String'>
    readonly latitude: FieldRef<"Venue", 'Float'>
    readonly longitude: FieldRef<"Venue", 'Float'>
    readonly isActive: FieldRef<"Venue", 'Boolean'>
    readonly isFeatured: FieldRef<"Venue", 'Boolean'>
    readonly category: FieldRef<"Venue", 'VenueCategory'>
    readonly statsSummary: FieldRef<"Venue", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to delete.
     */
    limit?: number
  }

  /**
   * Venue.activeSessions
   */
  export type Venue$activeSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    where?: ActiveSessionWhereInput
    orderBy?: ActiveSessionOrderByWithRelationInput | ActiveSessionOrderByWithRelationInput[]
    cursor?: ActiveSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActiveSessionScalarFieldEnum | ActiveSessionScalarFieldEnum[]
  }

  /**
   * Venue.groupMessages
   */
  export type Venue$groupMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    where?: VenueGroupMessageWhereInput
    orderBy?: VenueGroupMessageOrderByWithRelationInput | VenueGroupMessageOrderByWithRelationInput[]
    cursor?: VenueGroupMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueGroupMessageScalarFieldEnum | VenueGroupMessageScalarFieldEnum[]
  }

  /**
   * Venue.checkInHistory
   */
  export type Venue$checkInHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    where?: CheckInHistoryWhereInput
    orderBy?: CheckInHistoryOrderByWithRelationInput | CheckInHistoryOrderByWithRelationInput[]
    cursor?: CheckInHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckInHistoryScalarFieldEnum | CheckInHistoryScalarFieldEnum[]
  }

  /**
   * Venue.challenges
   */
  export type Venue$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    where?: ChallengeInstanceWhereInput
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    cursor?: ChallengeInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model ActiveSession
   */

  export type AggregateActiveSession = {
    _count: ActiveSessionCountAggregateOutputType | null
    _avg: ActiveSessionAvgAggregateOutputType | null
    _sum: ActiveSessionSumAggregateOutputType | null
    _min: ActiveSessionMinAggregateOutputType | null
    _max: ActiveSessionMaxAggregateOutputType | null
  }

  export type ActiveSessionAvgAggregateOutputType = {
    venueId: number | null
  }

  export type ActiveSessionSumAggregateOutputType = {
    venueId: number | null
  }

  export type ActiveSessionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    isIncognito: boolean | null
    userId: string | null
    venueId: number | null
  }

  export type ActiveSessionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    expiresAt: Date | null
    isIncognito: boolean | null
    userId: string | null
    venueId: number | null
  }

  export type ActiveSessionCountAggregateOutputType = {
    id: number
    createdAt: number
    expiresAt: number
    isIncognito: number
    userId: number
    venueId: number
    _all: number
  }


  export type ActiveSessionAvgAggregateInputType = {
    venueId?: true
  }

  export type ActiveSessionSumAggregateInputType = {
    venueId?: true
  }

  export type ActiveSessionMinAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    isIncognito?: true
    userId?: true
    venueId?: true
  }

  export type ActiveSessionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    isIncognito?: true
    userId?: true
    venueId?: true
  }

  export type ActiveSessionCountAggregateInputType = {
    id?: true
    createdAt?: true
    expiresAt?: true
    isIncognito?: true
    userId?: true
    venueId?: true
    _all?: true
  }

  export type ActiveSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveSession to aggregate.
     */
    where?: ActiveSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveSessions to fetch.
     */
    orderBy?: ActiveSessionOrderByWithRelationInput | ActiveSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActiveSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActiveSessions
    **/
    _count?: true | ActiveSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActiveSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActiveSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActiveSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActiveSessionMaxAggregateInputType
  }

  export type GetActiveSessionAggregateType<T extends ActiveSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateActiveSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActiveSession[P]>
      : GetScalarType<T[P], AggregateActiveSession[P]>
  }




  export type ActiveSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiveSessionWhereInput
    orderBy?: ActiveSessionOrderByWithAggregationInput | ActiveSessionOrderByWithAggregationInput[]
    by: ActiveSessionScalarFieldEnum[] | ActiveSessionScalarFieldEnum
    having?: ActiveSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActiveSessionCountAggregateInputType | true
    _avg?: ActiveSessionAvgAggregateInputType
    _sum?: ActiveSessionSumAggregateInputType
    _min?: ActiveSessionMinAggregateInputType
    _max?: ActiveSessionMaxAggregateInputType
  }

  export type ActiveSessionGroupByOutputType = {
    id: string
    createdAt: Date
    expiresAt: Date
    isIncognito: boolean
    userId: string
    venueId: number
    _count: ActiveSessionCountAggregateOutputType | null
    _avg: ActiveSessionAvgAggregateOutputType | null
    _sum: ActiveSessionSumAggregateOutputType | null
    _min: ActiveSessionMinAggregateOutputType | null
    _max: ActiveSessionMaxAggregateOutputType | null
  }

  type GetActiveSessionGroupByPayload<T extends ActiveSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActiveSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActiveSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActiveSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ActiveSessionGroupByOutputType[P]>
        }
      >
    >


  export type ActiveSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    isIncognito?: boolean
    userId?: boolean
    venueId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activeSession"]>



  export type ActiveSessionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    isIncognito?: boolean
    userId?: boolean
    venueId?: boolean
  }

  export type ActiveSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "expiresAt" | "isIncognito" | "userId" | "venueId", ExtArgs["result"]["activeSession"]>
  export type ActiveSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $ActiveSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActiveSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      expiresAt: Date
      isIncognito: boolean
      userId: string
      venueId: number
    }, ExtArgs["result"]["activeSession"]>
    composites: {}
  }

  type ActiveSessionGetPayload<S extends boolean | null | undefined | ActiveSessionDefaultArgs> = $Result.GetResult<Prisma.$ActiveSessionPayload, S>

  type ActiveSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActiveSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActiveSessionCountAggregateInputType | true
    }

  export interface ActiveSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActiveSession'], meta: { name: 'ActiveSession' } }
    /**
     * Find zero or one ActiveSession that matches the filter.
     * @param {ActiveSessionFindUniqueArgs} args - Arguments to find a ActiveSession
     * @example
     * // Get one ActiveSession
     * const activeSession = await prisma.activeSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActiveSessionFindUniqueArgs>(args: SelectSubset<T, ActiveSessionFindUniqueArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActiveSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActiveSessionFindUniqueOrThrowArgs} args - Arguments to find a ActiveSession
     * @example
     * // Get one ActiveSession
     * const activeSession = await prisma.activeSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActiveSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActiveSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActiveSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionFindFirstArgs} args - Arguments to find a ActiveSession
     * @example
     * // Get one ActiveSession
     * const activeSession = await prisma.activeSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActiveSessionFindFirstArgs>(args?: SelectSubset<T, ActiveSessionFindFirstArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActiveSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionFindFirstOrThrowArgs} args - Arguments to find a ActiveSession
     * @example
     * // Get one ActiveSession
     * const activeSession = await prisma.activeSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActiveSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActiveSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActiveSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActiveSessions
     * const activeSessions = await prisma.activeSession.findMany()
     * 
     * // Get first 10 ActiveSessions
     * const activeSessions = await prisma.activeSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activeSessionWithIdOnly = await prisma.activeSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActiveSessionFindManyArgs>(args?: SelectSubset<T, ActiveSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActiveSession.
     * @param {ActiveSessionCreateArgs} args - Arguments to create a ActiveSession.
     * @example
     * // Create one ActiveSession
     * const ActiveSession = await prisma.activeSession.create({
     *   data: {
     *     // ... data to create a ActiveSession
     *   }
     * })
     * 
     */
    create<T extends ActiveSessionCreateArgs>(args: SelectSubset<T, ActiveSessionCreateArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActiveSessions.
     * @param {ActiveSessionCreateManyArgs} args - Arguments to create many ActiveSessions.
     * @example
     * // Create many ActiveSessions
     * const activeSession = await prisma.activeSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActiveSessionCreateManyArgs>(args?: SelectSubset<T, ActiveSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActiveSession.
     * @param {ActiveSessionDeleteArgs} args - Arguments to delete one ActiveSession.
     * @example
     * // Delete one ActiveSession
     * const ActiveSession = await prisma.activeSession.delete({
     *   where: {
     *     // ... filter to delete one ActiveSession
     *   }
     * })
     * 
     */
    delete<T extends ActiveSessionDeleteArgs>(args: SelectSubset<T, ActiveSessionDeleteArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActiveSession.
     * @param {ActiveSessionUpdateArgs} args - Arguments to update one ActiveSession.
     * @example
     * // Update one ActiveSession
     * const activeSession = await prisma.activeSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActiveSessionUpdateArgs>(args: SelectSubset<T, ActiveSessionUpdateArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActiveSessions.
     * @param {ActiveSessionDeleteManyArgs} args - Arguments to filter ActiveSessions to delete.
     * @example
     * // Delete a few ActiveSessions
     * const { count } = await prisma.activeSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActiveSessionDeleteManyArgs>(args?: SelectSubset<T, ActiveSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiveSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActiveSessions
     * const activeSession = await prisma.activeSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActiveSessionUpdateManyArgs>(args: SelectSubset<T, ActiveSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActiveSession.
     * @param {ActiveSessionUpsertArgs} args - Arguments to update or create a ActiveSession.
     * @example
     * // Update or create a ActiveSession
     * const activeSession = await prisma.activeSession.upsert({
     *   create: {
     *     // ... data to create a ActiveSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActiveSession we want to update
     *   }
     * })
     */
    upsert<T extends ActiveSessionUpsertArgs>(args: SelectSubset<T, ActiveSessionUpsertArgs<ExtArgs>>): Prisma__ActiveSessionClient<$Result.GetResult<Prisma.$ActiveSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActiveSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionCountArgs} args - Arguments to filter ActiveSessions to count.
     * @example
     * // Count the number of ActiveSessions
     * const count = await prisma.activeSession.count({
     *   where: {
     *     // ... the filter for the ActiveSessions we want to count
     *   }
     * })
    **/
    count<T extends ActiveSessionCountArgs>(
      args?: Subset<T, ActiveSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActiveSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActiveSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActiveSessionAggregateArgs>(args: Subset<T, ActiveSessionAggregateArgs>): Prisma.PrismaPromise<GetActiveSessionAggregateType<T>>

    /**
     * Group by ActiveSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiveSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActiveSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActiveSessionGroupByArgs['orderBy'] }
        : { orderBy?: ActiveSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActiveSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActiveSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActiveSession model
   */
  readonly fields: ActiveSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActiveSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActiveSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActiveSession model
   */
  interface ActiveSessionFieldRefs {
    readonly id: FieldRef<"ActiveSession", 'String'>
    readonly createdAt: FieldRef<"ActiveSession", 'DateTime'>
    readonly expiresAt: FieldRef<"ActiveSession", 'DateTime'>
    readonly isIncognito: FieldRef<"ActiveSession", 'Boolean'>
    readonly userId: FieldRef<"ActiveSession", 'String'>
    readonly venueId: FieldRef<"ActiveSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ActiveSession findUnique
   */
  export type ActiveSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * Filter, which ActiveSession to fetch.
     */
    where: ActiveSessionWhereUniqueInput
  }

  /**
   * ActiveSession findUniqueOrThrow
   */
  export type ActiveSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * Filter, which ActiveSession to fetch.
     */
    where: ActiveSessionWhereUniqueInput
  }

  /**
   * ActiveSession findFirst
   */
  export type ActiveSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * Filter, which ActiveSession to fetch.
     */
    where?: ActiveSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveSessions to fetch.
     */
    orderBy?: ActiveSessionOrderByWithRelationInput | ActiveSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveSessions.
     */
    cursor?: ActiveSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveSessions.
     */
    distinct?: ActiveSessionScalarFieldEnum | ActiveSessionScalarFieldEnum[]
  }

  /**
   * ActiveSession findFirstOrThrow
   */
  export type ActiveSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * Filter, which ActiveSession to fetch.
     */
    where?: ActiveSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveSessions to fetch.
     */
    orderBy?: ActiveSessionOrderByWithRelationInput | ActiveSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiveSessions.
     */
    cursor?: ActiveSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiveSessions.
     */
    distinct?: ActiveSessionScalarFieldEnum | ActiveSessionScalarFieldEnum[]
  }

  /**
   * ActiveSession findMany
   */
  export type ActiveSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * Filter, which ActiveSessions to fetch.
     */
    where?: ActiveSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiveSessions to fetch.
     */
    orderBy?: ActiveSessionOrderByWithRelationInput | ActiveSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActiveSessions.
     */
    cursor?: ActiveSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiveSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiveSessions.
     */
    skip?: number
    distinct?: ActiveSessionScalarFieldEnum | ActiveSessionScalarFieldEnum[]
  }

  /**
   * ActiveSession create
   */
  export type ActiveSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ActiveSession.
     */
    data: XOR<ActiveSessionCreateInput, ActiveSessionUncheckedCreateInput>
  }

  /**
   * ActiveSession createMany
   */
  export type ActiveSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActiveSessions.
     */
    data: ActiveSessionCreateManyInput | ActiveSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActiveSession update
   */
  export type ActiveSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ActiveSession.
     */
    data: XOR<ActiveSessionUpdateInput, ActiveSessionUncheckedUpdateInput>
    /**
     * Choose, which ActiveSession to update.
     */
    where: ActiveSessionWhereUniqueInput
  }

  /**
   * ActiveSession updateMany
   */
  export type ActiveSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActiveSessions.
     */
    data: XOR<ActiveSessionUpdateManyMutationInput, ActiveSessionUncheckedUpdateManyInput>
    /**
     * Filter which ActiveSessions to update
     */
    where?: ActiveSessionWhereInput
    /**
     * Limit how many ActiveSessions to update.
     */
    limit?: number
  }

  /**
   * ActiveSession upsert
   */
  export type ActiveSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ActiveSession to update in case it exists.
     */
    where: ActiveSessionWhereUniqueInput
    /**
     * In case the ActiveSession found by the `where` argument doesn't exist, create a new ActiveSession with this data.
     */
    create: XOR<ActiveSessionCreateInput, ActiveSessionUncheckedCreateInput>
    /**
     * In case the ActiveSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActiveSessionUpdateInput, ActiveSessionUncheckedUpdateInput>
  }

  /**
   * ActiveSession delete
   */
  export type ActiveSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
    /**
     * Filter which ActiveSession to delete.
     */
    where: ActiveSessionWhereUniqueInput
  }

  /**
   * ActiveSession deleteMany
   */
  export type ActiveSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiveSessions to delete
     */
    where?: ActiveSessionWhereInput
    /**
     * Limit how many ActiveSessions to delete.
     */
    limit?: number
  }

  /**
   * ActiveSession without action
   */
  export type ActiveSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiveSession
     */
    select?: ActiveSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActiveSession
     */
    omit?: ActiveSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiveSessionInclude<ExtArgs> | null
  }


  /**
   * Model Signal
   */

  export type AggregateSignal = {
    _count: SignalCountAggregateOutputType | null
    _avg: SignalAvgAggregateOutputType | null
    _sum: SignalSumAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  export type SignalAvgAggregateOutputType = {
    id: number | null
  }

  export type SignalSumAggregateOutputType = {
    id: number | null
  }

  export type SignalMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    senderId: string | null
    receiverId: string | null
  }

  export type SignalMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    senderId: string | null
    receiverId: string | null
  }

  export type SignalCountAggregateOutputType = {
    id: number
    createdAt: number
    senderId: number
    receiverId: number
    _all: number
  }


  export type SignalAvgAggregateInputType = {
    id?: true
  }

  export type SignalSumAggregateInputType = {
    id?: true
  }

  export type SignalMinAggregateInputType = {
    id?: true
    createdAt?: true
    senderId?: true
    receiverId?: true
  }

  export type SignalMaxAggregateInputType = {
    id?: true
    createdAt?: true
    senderId?: true
    receiverId?: true
  }

  export type SignalCountAggregateInputType = {
    id?: true
    createdAt?: true
    senderId?: true
    receiverId?: true
    _all?: true
  }

  export type SignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signal to aggregate.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signals
    **/
    _count?: true | SignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalMaxAggregateInputType
  }

  export type GetSignalAggregateType<T extends SignalAggregateArgs> = {
        [P in keyof T & keyof AggregateSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignal[P]>
      : GetScalarType<T[P], AggregateSignal[P]>
  }




  export type SignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignalWhereInput
    orderBy?: SignalOrderByWithAggregationInput | SignalOrderByWithAggregationInput[]
    by: SignalScalarFieldEnum[] | SignalScalarFieldEnum
    having?: SignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalCountAggregateInputType | true
    _avg?: SignalAvgAggregateInputType
    _sum?: SignalSumAggregateInputType
    _min?: SignalMinAggregateInputType
    _max?: SignalMaxAggregateInputType
  }

  export type SignalGroupByOutputType = {
    id: number
    createdAt: Date
    senderId: string
    receiverId: string
    _count: SignalCountAggregateOutputType | null
    _avg: SignalAvgAggregateOutputType | null
    _sum: SignalSumAggregateOutputType | null
    _min: SignalMinAggregateOutputType | null
    _max: SignalMaxAggregateOutputType | null
  }

  type GetSignalGroupByPayload<T extends SignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalGroupByOutputType[P]>
            : GetScalarType<T[P], SignalGroupByOutputType[P]>
        }
      >
    >


  export type SignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    senderId?: boolean
    receiverId?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["signal"]>



  export type SignalSelectScalar = {
    id?: boolean
    createdAt?: boolean
    senderId?: boolean
    receiverId?: boolean
  }

  export type SignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "senderId" | "receiverId", ExtArgs["result"]["signal"]>
  export type SignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signal"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      senderId: string
      receiverId: string
    }, ExtArgs["result"]["signal"]>
    composites: {}
  }

  type SignalGetPayload<S extends boolean | null | undefined | SignalDefaultArgs> = $Result.GetResult<Prisma.$SignalPayload, S>

  type SignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignalCountAggregateInputType | true
    }

  export interface SignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signal'], meta: { name: 'Signal' } }
    /**
     * Find zero or one Signal that matches the filter.
     * @param {SignalFindUniqueArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignalFindUniqueArgs>(args: SelectSubset<T, SignalFindUniqueArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SignalFindUniqueOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignalFindUniqueOrThrowArgs>(args: SelectSubset<T, SignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignalFindFirstArgs>(args?: SelectSubset<T, SignalFindFirstArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindFirstOrThrowArgs} args - Arguments to find a Signal
     * @example
     * // Get one Signal
     * const signal = await prisma.signal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignalFindFirstOrThrowArgs>(args?: SelectSubset<T, SignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signals
     * const signals = await prisma.signal.findMany()
     * 
     * // Get first 10 Signals
     * const signals = await prisma.signal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalWithIdOnly = await prisma.signal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignalFindManyArgs>(args?: SelectSubset<T, SignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signal.
     * @param {SignalCreateArgs} args - Arguments to create a Signal.
     * @example
     * // Create one Signal
     * const Signal = await prisma.signal.create({
     *   data: {
     *     // ... data to create a Signal
     *   }
     * })
     * 
     */
    create<T extends SignalCreateArgs>(args: SelectSubset<T, SignalCreateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signals.
     * @param {SignalCreateManyArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signal = await prisma.signal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignalCreateManyArgs>(args?: SelectSubset<T, SignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Signal.
     * @param {SignalDeleteArgs} args - Arguments to delete one Signal.
     * @example
     * // Delete one Signal
     * const Signal = await prisma.signal.delete({
     *   where: {
     *     // ... filter to delete one Signal
     *   }
     * })
     * 
     */
    delete<T extends SignalDeleteArgs>(args: SelectSubset<T, SignalDeleteArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signal.
     * @param {SignalUpdateArgs} args - Arguments to update one Signal.
     * @example
     * // Update one Signal
     * const signal = await prisma.signal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignalUpdateArgs>(args: SelectSubset<T, SignalUpdateArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signals.
     * @param {SignalDeleteManyArgs} args - Arguments to filter Signals to delete.
     * @example
     * // Delete a few Signals
     * const { count } = await prisma.signal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignalDeleteManyArgs>(args?: SelectSubset<T, SignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signals
     * const signal = await prisma.signal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignalUpdateManyArgs>(args: SelectSubset<T, SignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Signal.
     * @param {SignalUpsertArgs} args - Arguments to update or create a Signal.
     * @example
     * // Update or create a Signal
     * const signal = await prisma.signal.upsert({
     *   create: {
     *     // ... data to create a Signal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signal we want to update
     *   }
     * })
     */
    upsert<T extends SignalUpsertArgs>(args: SelectSubset<T, SignalUpsertArgs<ExtArgs>>): Prisma__SignalClient<$Result.GetResult<Prisma.$SignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalCountArgs} args - Arguments to filter Signals to count.
     * @example
     * // Count the number of Signals
     * const count = await prisma.signal.count({
     *   where: {
     *     // ... the filter for the Signals we want to count
     *   }
     * })
    **/
    count<T extends SignalCountArgs>(
      args?: Subset<T, SignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalAggregateArgs>(args: Subset<T, SignalAggregateArgs>): Prisma.PrismaPromise<GetSignalAggregateType<T>>

    /**
     * Group by Signal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignalGroupByArgs['orderBy'] }
        : { orderBy?: SignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signal model
   */
  readonly fields: SignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signal model
   */
  interface SignalFieldRefs {
    readonly id: FieldRef<"Signal", 'Int'>
    readonly createdAt: FieldRef<"Signal", 'DateTime'>
    readonly senderId: FieldRef<"Signal", 'String'>
    readonly receiverId: FieldRef<"Signal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Signal findUnique
   */
  export type SignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findUniqueOrThrow
   */
  export type SignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal findFirst
   */
  export type SignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findFirstOrThrow
   */
  export type SignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signal to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signals.
     */
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal findMany
   */
  export type SignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter, which Signals to fetch.
     */
    where?: SignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signals to fetch.
     */
    orderBy?: SignalOrderByWithRelationInput | SignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signals.
     */
    cursor?: SignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signals.
     */
    skip?: number
    distinct?: SignalScalarFieldEnum | SignalScalarFieldEnum[]
  }

  /**
   * Signal create
   */
  export type SignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The data needed to create a Signal.
     */
    data: XOR<SignalCreateInput, SignalUncheckedCreateInput>
  }

  /**
   * Signal createMany
   */
  export type SignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signals.
     */
    data: SignalCreateManyInput | SignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signal update
   */
  export type SignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The data needed to update a Signal.
     */
    data: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
    /**
     * Choose, which Signal to update.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal updateMany
   */
  export type SignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signals.
     */
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyInput>
    /**
     * Filter which Signals to update
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to update.
     */
    limit?: number
  }

  /**
   * Signal upsert
   */
  export type SignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * The filter to search for the Signal to update in case it exists.
     */
    where: SignalWhereUniqueInput
    /**
     * In case the Signal found by the `where` argument doesn't exist, create a new Signal with this data.
     */
    create: XOR<SignalCreateInput, SignalUncheckedCreateInput>
    /**
     * In case the Signal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignalUpdateInput, SignalUncheckedUpdateInput>
  }

  /**
   * Signal delete
   */
  export type SignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
    /**
     * Filter which Signal to delete.
     */
    where: SignalWhereUniqueInput
  }

  /**
   * Signal deleteMany
   */
  export type SignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signals to delete
     */
    where?: SignalWhereInput
    /**
     * Limit how many Signals to delete.
     */
    limit?: number
  }

  /**
   * Signal without action
   */
  export type SignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signal
     */
    select?: SignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Signal
     */
    omit?: SignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignalInclude<ExtArgs> | null
  }


  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null
    _avg: ConnectionAvgAggregateOutputType | null
    _sum: ConnectionSumAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  export type ConnectionAvgAggregateOutputType = {
    id: number | null
  }

  export type ConnectionSumAggregateOutputType = {
    id: number | null
  }

  export type ConnectionMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userAId: string | null
    userBId: string | null
  }

  export type ConnectionMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userAId: string | null
    userBId: string | null
  }

  export type ConnectionCountAggregateOutputType = {
    id: number
    createdAt: number
    userAId: number
    userBId: number
    _all: number
  }


  export type ConnectionAvgAggregateInputType = {
    id?: true
  }

  export type ConnectionSumAggregateInputType = {
    id?: true
  }

  export type ConnectionMinAggregateInputType = {
    id?: true
    createdAt?: true
    userAId?: true
    userBId?: true
  }

  export type ConnectionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userAId?: true
    userBId?: true
  }

  export type ConnectionCountAggregateInputType = {
    id?: true
    createdAt?: true
    userAId?: true
    userBId?: true
    _all?: true
  }

  export type ConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Connections
    **/
    _count?: true | ConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConnectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConnectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionMaxAggregateInputType
  }

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>
  }




  export type ConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[]
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum
    having?: ConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionCountAggregateInputType | true
    _avg?: ConnectionAvgAggregateInputType
    _sum?: ConnectionSumAggregateInputType
    _min?: ConnectionMinAggregateInputType
    _max?: ConnectionMaxAggregateInputType
  }

  export type ConnectionGroupByOutputType = {
    id: number
    createdAt: Date
    userAId: string
    userBId: string
    _count: ConnectionCountAggregateOutputType | null
    _avg: ConnectionAvgAggregateOutputType | null
    _sum: ConnectionSumAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userAId?: boolean
    userBId?: boolean
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Connection$messagesArgs<ExtArgs>
    challenges?: boolean | Connection$challengesArgs<ExtArgs>
    _count?: boolean | ConnectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>



  export type ConnectionSelectScalar = {
    id?: boolean
    createdAt?: boolean
    userAId?: boolean
    userBId?: boolean
  }

  export type ConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userAId" | "userBId", ExtArgs["result"]["connection"]>
  export type ConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userA?: boolean | UserDefaultArgs<ExtArgs>
    userB?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Connection$messagesArgs<ExtArgs>
    challenges?: boolean | Connection$challengesArgs<ExtArgs>
    _count?: boolean | ConnectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Connection"
    objects: {
      userA: Prisma.$UserPayload<ExtArgs>
      userB: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      challenges: Prisma.$ChallengeInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      userAId: string
      userBId: string
    }, ExtArgs["result"]["connection"]>
    composites: {}
  }

  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> = $Result.GetResult<Prisma.$ConnectionPayload, S>

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectionCountAggregateInputType | true
    }

  export interface ConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Connection'], meta: { name: 'Connection' } }
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionFindUniqueArgs>(args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Connection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionFindFirstArgs>(args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     * 
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionWithIdOnly = await prisma.connection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionFindManyArgs>(args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     * 
     */
    create<T extends ConnectionCreateArgs>(args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Connections.
     * @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     * @example
     * // Create many Connections
     * const connection = await prisma.connection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionCreateManyArgs>(args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     * 
     */
    delete<T extends ConnectionDeleteArgs>(args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionUpdateArgs>(args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionDeleteManyArgs>(args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionUpdateManyArgs>(args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionUpsertArgs>(args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
    **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionAggregateArgs>(args: Subset<T, ConnectionAggregateArgs>): Prisma.PrismaPromise<GetConnectionAggregateType<T>>

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Connection model
   */
  readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userA<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userB<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Connection$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Connection$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    challenges<T extends Connection$challengesArgs<ExtArgs> = {}>(args?: Subset<T, Connection$challengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Connection model
   */
  interface ConnectionFieldRefs {
    readonly id: FieldRef<"Connection", 'Int'>
    readonly createdAt: FieldRef<"Connection", 'DateTime'>
    readonly userAId: FieldRef<"Connection", 'String'>
    readonly userBId: FieldRef<"Connection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }

  /**
   * Connection create
   */
  export type ConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
  }

  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to update.
     */
    limit?: number
  }

  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
  }

  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput
  }

  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput
    /**
     * Limit how many Connections to delete.
     */
    limit?: number
  }

  /**
   * Connection.messages
   */
  export type Connection$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Connection.challenges
   */
  export type Connection$challengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    where?: ChallengeInstanceWhereInput
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    cursor?: ChallengeInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Connection
     */
    omit?: ConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    connectionId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    connectionId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    content: string | null
    imageUrl: string | null
    audioUrl: string | null
    createdAt: Date | null
    senderId: string | null
    connectionId: number | null
    isRead: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    content: string | null
    imageUrl: string | null
    audioUrl: string | null
    createdAt: Date | null
    senderId: string | null
    connectionId: number | null
    isRead: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    imageUrl: number
    audioUrl: number
    createdAt: number
    senderId: number
    connectionId: number
    isRead: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    connectionId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    connectionId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    audioUrl?: true
    createdAt?: true
    senderId?: true
    connectionId?: true
    isRead?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    audioUrl?: true
    createdAt?: true
    senderId?: true
    connectionId?: true
    isRead?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    audioUrl?: true
    createdAt?: true
    senderId?: true
    connectionId?: true
    isRead?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    content: string | null
    imageUrl: string | null
    audioUrl: string | null
    createdAt: Date
    senderId: string
    connectionId: number
    isRead: boolean
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    audioUrl?: boolean
    createdAt?: boolean
    senderId?: boolean
    connectionId?: boolean
    isRead?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    connection?: boolean | ConnectionDefaultArgs<ExtArgs>
    reports?: boolean | Message$reportsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>



  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    audioUrl?: boolean
    createdAt?: boolean
    senderId?: boolean
    connectionId?: boolean
    isRead?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "imageUrl" | "audioUrl" | "createdAt" | "senderId" | "connectionId" | "isRead", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    connection?: boolean | ConnectionDefaultArgs<ExtArgs>
    reports?: boolean | Message$reportsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      connection: Prisma.$ConnectionPayload<ExtArgs>
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string | null
      imageUrl: string | null
      audioUrl: string | null
      createdAt: Date
      senderId: string
      connectionId: number
      isRead: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    connection<T extends ConnectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConnectionDefaultArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reports<T extends Message$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Message$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly content: FieldRef<"Message", 'String'>
    readonly imageUrl: FieldRef<"Message", 'String'>
    readonly audioUrl: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly connectionId: FieldRef<"Message", 'Int'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.reports
   */
  export type Message$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockAvgAggregateOutputType = {
    id: number | null
  }

  export type BlockSumAggregateOutputType = {
    id: number | null
  }

  export type BlockMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blockerId: string | null
    blockedId: string | null
  }

  export type BlockMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blockerId: string | null
    blockedId: string | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    createdAt: number
    blockerId: number
    blockedId: number
    _all: number
  }


  export type BlockAvgAggregateInputType = {
    id?: true
  }

  export type BlockSumAggregateInputType = {
    id?: true
  }

  export type BlockMinAggregateInputType = {
    id?: true
    createdAt?: true
    blockerId?: true
    blockedId?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    createdAt?: true
    blockerId?: true
    blockedId?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    createdAt?: true
    blockerId?: true
    blockedId?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _avg?: BlockAvgAggregateInputType
    _sum?: BlockSumAggregateInputType
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: number
    createdAt: Date
    blockerId: string
    blockedId: string
    _count: BlockCountAggregateOutputType | null
    _avg: BlockAvgAggregateOutputType | null
    _sum: BlockSumAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blockerId?: boolean
    blockedId?: boolean
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>



  export type BlockSelectScalar = {
    id?: boolean
    createdAt?: boolean
    blockerId?: boolean
    blockedId?: boolean
  }

  export type BlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "blockerId" | "blockedId", ExtArgs["result"]["block"]>
  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | UserDefaultArgs<ExtArgs>
    blocked?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blocker: Prisma.$UserPayload<ExtArgs>
      blocked: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      blockerId: string
      blockedId: string
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blocked<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'Int'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
    readonly blockerId: FieldRef<"Block", 'String'>
    readonly blockedId: FieldRef<"Block", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    reportedMessageId: number | null
    reportedGroupMessageId: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    reportedMessageId: number | null
    reportedGroupMessageId: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    reason: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reporterId: string | null
    reportedUserId: string | null
    reportedMessageId: number | null
    reportedGroupMessageId: number | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    reason: string | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reporterId: string | null
    reportedUserId: string | null
    reportedMessageId: number | null
    reportedGroupMessageId: number | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    reporterId: number
    reportedUserId: number
    reportedMessageId: number
    reportedGroupMessageId: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    reportedMessageId?: true
    reportedGroupMessageId?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    reportedMessageId?: true
    reportedGroupMessageId?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reporterId?: true
    reportedUserId?: true
    reportedMessageId?: true
    reportedGroupMessageId?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reporterId?: true
    reportedUserId?: true
    reportedMessageId?: true
    reportedGroupMessageId?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reporterId?: true
    reportedUserId?: true
    reportedMessageId?: true
    reportedGroupMessageId?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    reason: string
    status: $Enums.ReportStatus
    createdAt: Date
    updatedAt: Date
    reporterId: string
    reportedUserId: string
    reportedMessageId: number | null
    reportedGroupMessageId: number | null
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedMessageId?: boolean
    reportedGroupMessageId?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reportedGroupMessage?: boolean | Report$reportedGroupMessageArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>



  export type ReportSelectScalar = {
    id?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporterId?: boolean
    reportedUserId?: boolean
    reportedMessageId?: boolean
    reportedGroupMessageId?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reason" | "status" | "createdAt" | "updatedAt" | "reporterId" | "reportedUserId" | "reportedMessageId" | "reportedGroupMessageId", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    reportedUser?: boolean | UserDefaultArgs<ExtArgs>
    reportedMessage?: boolean | Report$reportedMessageArgs<ExtArgs>
    reportedGroupMessage?: boolean | Report$reportedGroupMessageArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>
      reportedUser: Prisma.$UserPayload<ExtArgs>
      reportedMessage: Prisma.$MessagePayload<ExtArgs> | null
      reportedGroupMessage: Prisma.$VenueGroupMessagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reason: string
      status: $Enums.ReportStatus
      createdAt: Date
      updatedAt: Date
      reporterId: string
      reportedUserId: string
      reportedMessageId: number | null
      reportedGroupMessageId: number | null
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedMessage<T extends Report$reportedMessageArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedMessageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reportedGroupMessage<T extends Report$reportedGroupMessageArgs<ExtArgs> = {}>(args?: Subset<T, Report$reportedGroupMessageArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly reporterId: FieldRef<"Report", 'String'>
    readonly reportedUserId: FieldRef<"Report", 'String'>
    readonly reportedMessageId: FieldRef<"Report", 'Int'>
    readonly reportedGroupMessageId: FieldRef<"Report", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.reportedMessage
   */
  export type Report$reportedMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Report.reportedGroupMessage
   */
  export type Report$reportedGroupMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    where?: VenueGroupMessageWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceAvgAggregateOutputType = {
    id: number | null
  }

  export type DeviceSumAggregateOutputType = {
    id: number | null
  }

  export type DeviceMinAggregateOutputType = {
    id: number | null
    token: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: number | null
    token: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    token: number
    createdAt: number
    userId: number
    _all: number
  }


  export type DeviceAvgAggregateInputType = {
    id?: true
  }

  export type DeviceSumAggregateInputType = {
    id?: true
  }

  export type DeviceMinAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    userId?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    userId?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _avg?: DeviceAvgAggregateInputType
    _sum?: DeviceSumAggregateInputType
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: number
    token: string
    createdAt: Date
    userId: string
    _count: DeviceCountAggregateOutputType | null
    _avg: DeviceAvgAggregateOutputType | null
    _sum: DeviceSumAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>



  export type DeviceSelectScalar = {
    id?: boolean
    token?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "createdAt" | "userId", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'Int'>
    readonly token: FieldRef<"Device", 'String'>
    readonly createdAt: FieldRef<"Device", 'DateTime'>
    readonly userId: FieldRef<"Device", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    type: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    type: string | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    userId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    content: number
    isRead: number
    createdAt: number
    userId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    content?: true
    isRead?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    type: string
    content: string
    isRead: boolean
    createdAt: Date
    userId: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "content" | "isRead" | "createdAt" | "userId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      content: string
      isRead: boolean
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly userId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    id: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    id: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: number | null
    description: string | null
    screenshotUrl: string | null
    createdAt: Date | null
    authorId: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: number | null
    description: string | null
    screenshotUrl: string | null
    createdAt: Date | null
    authorId: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    description: number
    screenshotUrl: number
    createdAt: number
    authorId: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    id?: true
  }

  export type FeedbackSumAggregateInputType = {
    id?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    description?: true
    screenshotUrl?: true
    createdAt?: true
    authorId?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    description?: true
    screenshotUrl?: true
    createdAt?: true
    authorId?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    description?: true
    screenshotUrl?: true
    createdAt?: true
    authorId?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: number
    description: string
    screenshotUrl: string | null
    createdAt: Date
    authorId: string
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    screenshotUrl?: boolean
    createdAt?: boolean
    authorId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>



  export type FeedbackSelectScalar = {
    id?: boolean
    description?: boolean
    screenshotUrl?: boolean
    createdAt?: boolean
    authorId?: boolean
  }

  export type FeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "screenshotUrl" | "createdAt" | "authorId", ExtArgs["result"]["feedback"]>
  export type FeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      screenshotUrl: string | null
      createdAt: Date
      authorId: string
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }

  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackFindUniqueArgs>(args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackFindFirstArgs>(args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedbackFindManyArgs>(args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
     */
    create<T extends FeedbackCreateArgs>(args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedback = await prisma.feedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackCreateManyArgs>(args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
     */
    delete<T extends FeedbackDeleteArgs>(args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackUpdateArgs>(args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackDeleteManyArgs>(args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackUpdateManyArgs>(args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackUpsertArgs>(args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feedback model
   */
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'Int'>
    readonly description: FieldRef<"Feedback", 'String'>
    readonly screenshotUrl: FieldRef<"Feedback", 'String'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly authorId: FieldRef<"Feedback", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }

  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }

  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to update.
     */
    limit?: number
  }

  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }

  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }

  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
    /**
     * Limit how many Feedbacks to delete.
     */
    limit?: number
  }

  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feedback
     */
    omit?: FeedbackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    actorId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    actorId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    actorId: string | null
    action: string
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>



  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "action" | "details" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actorId: string | null
      action: string
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model BroadcastNotification
   */

  export type AggregateBroadcastNotification = {
    _count: BroadcastNotificationCountAggregateOutputType | null
    _avg: BroadcastNotificationAvgAggregateOutputType | null
    _sum: BroadcastNotificationSumAggregateOutputType | null
    _min: BroadcastNotificationMinAggregateOutputType | null
    _max: BroadcastNotificationMaxAggregateOutputType | null
  }

  export type BroadcastNotificationAvgAggregateOutputType = {
    id: number | null
  }

  export type BroadcastNotificationSumAggregateOutputType = {
    id: number | null
  }

  export type BroadcastNotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    body: string | null
    createdAt: Date | null
    sentById: string | null
  }

  export type BroadcastNotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    body: string | null
    createdAt: Date | null
    sentById: string | null
  }

  export type BroadcastNotificationCountAggregateOutputType = {
    id: number
    title: number
    body: number
    createdAt: number
    sentById: number
    _all: number
  }


  export type BroadcastNotificationAvgAggregateInputType = {
    id?: true
  }

  export type BroadcastNotificationSumAggregateInputType = {
    id?: true
  }

  export type BroadcastNotificationMinAggregateInputType = {
    id?: true
    title?: true
    body?: true
    createdAt?: true
    sentById?: true
  }

  export type BroadcastNotificationMaxAggregateInputType = {
    id?: true
    title?: true
    body?: true
    createdAt?: true
    sentById?: true
  }

  export type BroadcastNotificationCountAggregateInputType = {
    id?: true
    title?: true
    body?: true
    createdAt?: true
    sentById?: true
    _all?: true
  }

  export type BroadcastNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadcastNotification to aggregate.
     */
    where?: BroadcastNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadcastNotifications to fetch.
     */
    orderBy?: BroadcastNotificationOrderByWithRelationInput | BroadcastNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BroadcastNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadcastNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadcastNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BroadcastNotifications
    **/
    _count?: true | BroadcastNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BroadcastNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BroadcastNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BroadcastNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BroadcastNotificationMaxAggregateInputType
  }

  export type GetBroadcastNotificationAggregateType<T extends BroadcastNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateBroadcastNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBroadcastNotification[P]>
      : GetScalarType<T[P], AggregateBroadcastNotification[P]>
  }




  export type BroadcastNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BroadcastNotificationWhereInput
    orderBy?: BroadcastNotificationOrderByWithAggregationInput | BroadcastNotificationOrderByWithAggregationInput[]
    by: BroadcastNotificationScalarFieldEnum[] | BroadcastNotificationScalarFieldEnum
    having?: BroadcastNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BroadcastNotificationCountAggregateInputType | true
    _avg?: BroadcastNotificationAvgAggregateInputType
    _sum?: BroadcastNotificationSumAggregateInputType
    _min?: BroadcastNotificationMinAggregateInputType
    _max?: BroadcastNotificationMaxAggregateInputType
  }

  export type BroadcastNotificationGroupByOutputType = {
    id: number
    title: string
    body: string
    createdAt: Date
    sentById: string
    _count: BroadcastNotificationCountAggregateOutputType | null
    _avg: BroadcastNotificationAvgAggregateOutputType | null
    _sum: BroadcastNotificationSumAggregateOutputType | null
    _min: BroadcastNotificationMinAggregateOutputType | null
    _max: BroadcastNotificationMaxAggregateOutputType | null
  }

  type GetBroadcastNotificationGroupByPayload<T extends BroadcastNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BroadcastNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BroadcastNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BroadcastNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], BroadcastNotificationGroupByOutputType[P]>
        }
      >
    >


  export type BroadcastNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    sentById?: boolean
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["broadcastNotification"]>



  export type BroadcastNotificationSelectScalar = {
    id?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    sentById?: boolean
  }

  export type BroadcastNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "body" | "createdAt" | "sentById", ExtArgs["result"]["broadcastNotification"]>
  export type BroadcastNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BroadcastNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BroadcastNotification"
    objects: {
      sentBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      body: string
      createdAt: Date
      sentById: string
    }, ExtArgs["result"]["broadcastNotification"]>
    composites: {}
  }

  type BroadcastNotificationGetPayload<S extends boolean | null | undefined | BroadcastNotificationDefaultArgs> = $Result.GetResult<Prisma.$BroadcastNotificationPayload, S>

  type BroadcastNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BroadcastNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BroadcastNotificationCountAggregateInputType | true
    }

  export interface BroadcastNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BroadcastNotification'], meta: { name: 'BroadcastNotification' } }
    /**
     * Find zero or one BroadcastNotification that matches the filter.
     * @param {BroadcastNotificationFindUniqueArgs} args - Arguments to find a BroadcastNotification
     * @example
     * // Get one BroadcastNotification
     * const broadcastNotification = await prisma.broadcastNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BroadcastNotificationFindUniqueArgs>(args: SelectSubset<T, BroadcastNotificationFindUniqueArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BroadcastNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BroadcastNotificationFindUniqueOrThrowArgs} args - Arguments to find a BroadcastNotification
     * @example
     * // Get one BroadcastNotification
     * const broadcastNotification = await prisma.broadcastNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BroadcastNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, BroadcastNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadcastNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationFindFirstArgs} args - Arguments to find a BroadcastNotification
     * @example
     * // Get one BroadcastNotification
     * const broadcastNotification = await prisma.broadcastNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BroadcastNotificationFindFirstArgs>(args?: SelectSubset<T, BroadcastNotificationFindFirstArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BroadcastNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationFindFirstOrThrowArgs} args - Arguments to find a BroadcastNotification
     * @example
     * // Get one BroadcastNotification
     * const broadcastNotification = await prisma.broadcastNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BroadcastNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, BroadcastNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BroadcastNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BroadcastNotifications
     * const broadcastNotifications = await prisma.broadcastNotification.findMany()
     * 
     * // Get first 10 BroadcastNotifications
     * const broadcastNotifications = await prisma.broadcastNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const broadcastNotificationWithIdOnly = await prisma.broadcastNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BroadcastNotificationFindManyArgs>(args?: SelectSubset<T, BroadcastNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BroadcastNotification.
     * @param {BroadcastNotificationCreateArgs} args - Arguments to create a BroadcastNotification.
     * @example
     * // Create one BroadcastNotification
     * const BroadcastNotification = await prisma.broadcastNotification.create({
     *   data: {
     *     // ... data to create a BroadcastNotification
     *   }
     * })
     * 
     */
    create<T extends BroadcastNotificationCreateArgs>(args: SelectSubset<T, BroadcastNotificationCreateArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BroadcastNotifications.
     * @param {BroadcastNotificationCreateManyArgs} args - Arguments to create many BroadcastNotifications.
     * @example
     * // Create many BroadcastNotifications
     * const broadcastNotification = await prisma.broadcastNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BroadcastNotificationCreateManyArgs>(args?: SelectSubset<T, BroadcastNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BroadcastNotification.
     * @param {BroadcastNotificationDeleteArgs} args - Arguments to delete one BroadcastNotification.
     * @example
     * // Delete one BroadcastNotification
     * const BroadcastNotification = await prisma.broadcastNotification.delete({
     *   where: {
     *     // ... filter to delete one BroadcastNotification
     *   }
     * })
     * 
     */
    delete<T extends BroadcastNotificationDeleteArgs>(args: SelectSubset<T, BroadcastNotificationDeleteArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BroadcastNotification.
     * @param {BroadcastNotificationUpdateArgs} args - Arguments to update one BroadcastNotification.
     * @example
     * // Update one BroadcastNotification
     * const broadcastNotification = await prisma.broadcastNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BroadcastNotificationUpdateArgs>(args: SelectSubset<T, BroadcastNotificationUpdateArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BroadcastNotifications.
     * @param {BroadcastNotificationDeleteManyArgs} args - Arguments to filter BroadcastNotifications to delete.
     * @example
     * // Delete a few BroadcastNotifications
     * const { count } = await prisma.broadcastNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BroadcastNotificationDeleteManyArgs>(args?: SelectSubset<T, BroadcastNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BroadcastNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BroadcastNotifications
     * const broadcastNotification = await prisma.broadcastNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BroadcastNotificationUpdateManyArgs>(args: SelectSubset<T, BroadcastNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BroadcastNotification.
     * @param {BroadcastNotificationUpsertArgs} args - Arguments to update or create a BroadcastNotification.
     * @example
     * // Update or create a BroadcastNotification
     * const broadcastNotification = await prisma.broadcastNotification.upsert({
     *   create: {
     *     // ... data to create a BroadcastNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BroadcastNotification we want to update
     *   }
     * })
     */
    upsert<T extends BroadcastNotificationUpsertArgs>(args: SelectSubset<T, BroadcastNotificationUpsertArgs<ExtArgs>>): Prisma__BroadcastNotificationClient<$Result.GetResult<Prisma.$BroadcastNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BroadcastNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationCountArgs} args - Arguments to filter BroadcastNotifications to count.
     * @example
     * // Count the number of BroadcastNotifications
     * const count = await prisma.broadcastNotification.count({
     *   where: {
     *     // ... the filter for the BroadcastNotifications we want to count
     *   }
     * })
    **/
    count<T extends BroadcastNotificationCountArgs>(
      args?: Subset<T, BroadcastNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BroadcastNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BroadcastNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BroadcastNotificationAggregateArgs>(args: Subset<T, BroadcastNotificationAggregateArgs>): Prisma.PrismaPromise<GetBroadcastNotificationAggregateType<T>>

    /**
     * Group by BroadcastNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BroadcastNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BroadcastNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BroadcastNotificationGroupByArgs['orderBy'] }
        : { orderBy?: BroadcastNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BroadcastNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBroadcastNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BroadcastNotification model
   */
  readonly fields: BroadcastNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BroadcastNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BroadcastNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sentBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BroadcastNotification model
   */
  interface BroadcastNotificationFieldRefs {
    readonly id: FieldRef<"BroadcastNotification", 'Int'>
    readonly title: FieldRef<"BroadcastNotification", 'String'>
    readonly body: FieldRef<"BroadcastNotification", 'String'>
    readonly createdAt: FieldRef<"BroadcastNotification", 'DateTime'>
    readonly sentById: FieldRef<"BroadcastNotification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BroadcastNotification findUnique
   */
  export type BroadcastNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * Filter, which BroadcastNotification to fetch.
     */
    where: BroadcastNotificationWhereUniqueInput
  }

  /**
   * BroadcastNotification findUniqueOrThrow
   */
  export type BroadcastNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * Filter, which BroadcastNotification to fetch.
     */
    where: BroadcastNotificationWhereUniqueInput
  }

  /**
   * BroadcastNotification findFirst
   */
  export type BroadcastNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * Filter, which BroadcastNotification to fetch.
     */
    where?: BroadcastNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadcastNotifications to fetch.
     */
    orderBy?: BroadcastNotificationOrderByWithRelationInput | BroadcastNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadcastNotifications.
     */
    cursor?: BroadcastNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadcastNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadcastNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadcastNotifications.
     */
    distinct?: BroadcastNotificationScalarFieldEnum | BroadcastNotificationScalarFieldEnum[]
  }

  /**
   * BroadcastNotification findFirstOrThrow
   */
  export type BroadcastNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * Filter, which BroadcastNotification to fetch.
     */
    where?: BroadcastNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadcastNotifications to fetch.
     */
    orderBy?: BroadcastNotificationOrderByWithRelationInput | BroadcastNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BroadcastNotifications.
     */
    cursor?: BroadcastNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadcastNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadcastNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BroadcastNotifications.
     */
    distinct?: BroadcastNotificationScalarFieldEnum | BroadcastNotificationScalarFieldEnum[]
  }

  /**
   * BroadcastNotification findMany
   */
  export type BroadcastNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * Filter, which BroadcastNotifications to fetch.
     */
    where?: BroadcastNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BroadcastNotifications to fetch.
     */
    orderBy?: BroadcastNotificationOrderByWithRelationInput | BroadcastNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BroadcastNotifications.
     */
    cursor?: BroadcastNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BroadcastNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BroadcastNotifications.
     */
    skip?: number
    distinct?: BroadcastNotificationScalarFieldEnum | BroadcastNotificationScalarFieldEnum[]
  }

  /**
   * BroadcastNotification create
   */
  export type BroadcastNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a BroadcastNotification.
     */
    data: XOR<BroadcastNotificationCreateInput, BroadcastNotificationUncheckedCreateInput>
  }

  /**
   * BroadcastNotification createMany
   */
  export type BroadcastNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BroadcastNotifications.
     */
    data: BroadcastNotificationCreateManyInput | BroadcastNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BroadcastNotification update
   */
  export type BroadcastNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a BroadcastNotification.
     */
    data: XOR<BroadcastNotificationUpdateInput, BroadcastNotificationUncheckedUpdateInput>
    /**
     * Choose, which BroadcastNotification to update.
     */
    where: BroadcastNotificationWhereUniqueInput
  }

  /**
   * BroadcastNotification updateMany
   */
  export type BroadcastNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BroadcastNotifications.
     */
    data: XOR<BroadcastNotificationUpdateManyMutationInput, BroadcastNotificationUncheckedUpdateManyInput>
    /**
     * Filter which BroadcastNotifications to update
     */
    where?: BroadcastNotificationWhereInput
    /**
     * Limit how many BroadcastNotifications to update.
     */
    limit?: number
  }

  /**
   * BroadcastNotification upsert
   */
  export type BroadcastNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the BroadcastNotification to update in case it exists.
     */
    where: BroadcastNotificationWhereUniqueInput
    /**
     * In case the BroadcastNotification found by the `where` argument doesn't exist, create a new BroadcastNotification with this data.
     */
    create: XOR<BroadcastNotificationCreateInput, BroadcastNotificationUncheckedCreateInput>
    /**
     * In case the BroadcastNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BroadcastNotificationUpdateInput, BroadcastNotificationUncheckedUpdateInput>
  }

  /**
   * BroadcastNotification delete
   */
  export type BroadcastNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
    /**
     * Filter which BroadcastNotification to delete.
     */
    where: BroadcastNotificationWhereUniqueInput
  }

  /**
   * BroadcastNotification deleteMany
   */
  export type BroadcastNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BroadcastNotifications to delete
     */
    where?: BroadcastNotificationWhereInput
    /**
     * Limit how many BroadcastNotifications to delete.
     */
    limit?: number
  }

  /**
   * BroadcastNotification without action
   */
  export type BroadcastNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BroadcastNotification
     */
    select?: BroadcastNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BroadcastNotification
     */
    omit?: BroadcastNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BroadcastNotificationInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type PasswordResetTokenSumAggregateOutputType = {
    id: number | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    createdAt: number
    userId: number
    _all: number
  }


  export type PasswordResetTokenAvgAggregateInputType = {
    id?: true
  }

  export type PasswordResetTokenSumAggregateInputType = {
    id?: true
  }

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PasswordResetTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PasswordResetTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _avg?: PasswordResetTokenAvgAggregateInputType
    _sum?: PasswordResetTokenSumAggregateInputType
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: number
    token: string
    expiresAt: Date
    createdAt: Date
    userId: string
    _count: PasswordResetTokenCountAggregateOutputType | null
    _avg: PasswordResetTokenAvgAggregateOutputType | null
    _sum: PasswordResetTokenSumAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>



  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "createdAt" | "userId", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      expiresAt: Date
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'Int'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model Photo
   */

  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoAvgAggregateOutputType = {
    id: number | null
  }

  export type PhotoSumAggregateOutputType = {
    id: number | null
  }

  export type PhotoMinAggregateOutputType = {
    id: number | null
    url: string | null
    isAvatar: boolean | null
    createdAt: Date | null
    profileId: string | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: number | null
    url: string | null
    isAvatar: boolean | null
    createdAt: Date | null
    profileId: string | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    url: number
    isAvatar: number
    createdAt: number
    profileId: number
    _all: number
  }


  export type PhotoAvgAggregateInputType = {
    id?: true
  }

  export type PhotoSumAggregateInputType = {
    id?: true
  }

  export type PhotoMinAggregateInputType = {
    id?: true
    url?: true
    isAvatar?: true
    createdAt?: true
    profileId?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    url?: true
    isAvatar?: true
    createdAt?: true
    profileId?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    url?: true
    isAvatar?: true
    createdAt?: true
    profileId?: true
    _all?: true
  }

  export type PhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photo to aggregate.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithAggregationInput | PhotoOrderByWithAggregationInput[]
    by: PhotoScalarFieldEnum[] | PhotoScalarFieldEnum
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _avg?: PhotoAvgAggregateInputType
    _sum?: PhotoSumAggregateInputType
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }

  export type PhotoGroupByOutputType = {
    id: number
    url: string
    isAvatar: boolean
    createdAt: Date
    profileId: string
    _count: PhotoCountAggregateOutputType | null
    _avg: PhotoAvgAggregateOutputType | null
    _sum: PhotoSumAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    isAvatar?: boolean
    createdAt?: boolean
    profileId?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>



  export type PhotoSelectScalar = {
    id?: boolean
    url?: boolean
    isAvatar?: boolean
    createdAt?: boolean
    profileId?: boolean
  }

  export type PhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "isAvatar" | "createdAt" | "profileId", ExtArgs["result"]["photo"]>
  export type PhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Photo"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      isAvatar: boolean
      createdAt: Date
      profileId: string
    }, ExtArgs["result"]["photo"]>
    composites: {}
  }

  type PhotoGetPayload<S extends boolean | null | undefined | PhotoDefaultArgs> = $Result.GetResult<Prisma.$PhotoPayload, S>

  type PhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PhotoCountAggregateInputType | true
    }

  export interface PhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Photo'], meta: { name: 'Photo' } }
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotoFindUniqueArgs>(args: SelectSubset<T, PhotoFindUniqueArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Photo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhotoFindUniqueOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotoFindFirstArgs>(args?: SelectSubset<T, PhotoFindFirstArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotoFindManyArgs>(args?: SelectSubset<T, PhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
     */
    create<T extends PhotoCreateArgs>(args: SelectSubset<T, PhotoCreateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Photos.
     * @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     * @example
     * // Create many Photos
     * const photo = await prisma.photo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotoCreateManyArgs>(args?: SelectSubset<T, PhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
     */
    delete<T extends PhotoDeleteArgs>(args: SelectSubset<T, PhotoDeleteArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotoUpdateArgs>(args: SelectSubset<T, PhotoUpdateArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotoDeleteManyArgs>(args?: SelectSubset<T, PhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotoUpdateManyArgs>(args: SelectSubset<T, PhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
     */
    upsert<T extends PhotoUpsertArgs>(args: SelectSubset<T, PhotoUpsertArgs<ExtArgs>>): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): Prisma.PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Photo model
   */
  readonly fields: PhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Photo model
   */
  interface PhotoFieldRefs {
    readonly id: FieldRef<"Photo", 'Int'>
    readonly url: FieldRef<"Photo", 'String'>
    readonly isAvatar: FieldRef<"Photo", 'Boolean'>
    readonly createdAt: FieldRef<"Photo", 'DateTime'>
    readonly profileId: FieldRef<"Photo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findUniqueOrThrow
   */
  export type PhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findFirstOrThrow
   */
  export type PhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photos to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }

  /**
   * Photo create
   */
  export type PhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Photo.
     */
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }

  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Photo update
   */
  export type PhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Photo.
     */
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
    /**
     * Limit how many Photos to update.
     */
    limit?: number
  }

  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Photo to update in case it exists.
     */
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     */
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }

  /**
   * Photo delete
   */
  export type PhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter which Photo to delete.
     */
    where: PhotoWhereUniqueInput
  }

  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photos to delete
     */
    where?: PhotoWhereInput
    /**
     * Limit how many Photos to delete.
     */
    limit?: number
  }

  /**
   * Photo without action
   */
  export type PhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Photo
     */
    omit?: PhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoInclude<ExtArgs> | null
  }


  /**
   * Model IcebreakerQuestion
   */

  export type AggregateIcebreakerQuestion = {
    _count: IcebreakerQuestionCountAggregateOutputType | null
    _avg: IcebreakerQuestionAvgAggregateOutputType | null
    _sum: IcebreakerQuestionSumAggregateOutputType | null
    _min: IcebreakerQuestionMinAggregateOutputType | null
    _max: IcebreakerQuestionMaxAggregateOutputType | null
  }

  export type IcebreakerQuestionAvgAggregateOutputType = {
    id: number | null
  }

  export type IcebreakerQuestionSumAggregateOutputType = {
    id: number | null
  }

  export type IcebreakerQuestionMinAggregateOutputType = {
    id: number | null
    text: string | null
    category: $Enums.IcebreakerCategory | null
    createdAt: Date | null
  }

  export type IcebreakerQuestionMaxAggregateOutputType = {
    id: number | null
    text: string | null
    category: $Enums.IcebreakerCategory | null
    createdAt: Date | null
  }

  export type IcebreakerQuestionCountAggregateOutputType = {
    id: number
    text: number
    category: number
    createdAt: number
    _all: number
  }


  export type IcebreakerQuestionAvgAggregateInputType = {
    id?: true
  }

  export type IcebreakerQuestionSumAggregateInputType = {
    id?: true
  }

  export type IcebreakerQuestionMinAggregateInputType = {
    id?: true
    text?: true
    category?: true
    createdAt?: true
  }

  export type IcebreakerQuestionMaxAggregateInputType = {
    id?: true
    text?: true
    category?: true
    createdAt?: true
  }

  export type IcebreakerQuestionCountAggregateInputType = {
    id?: true
    text?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type IcebreakerQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IcebreakerQuestion to aggregate.
     */
    where?: IcebreakerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IcebreakerQuestions to fetch.
     */
    orderBy?: IcebreakerQuestionOrderByWithRelationInput | IcebreakerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IcebreakerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IcebreakerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IcebreakerQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IcebreakerQuestions
    **/
    _count?: true | IcebreakerQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IcebreakerQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IcebreakerQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IcebreakerQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IcebreakerQuestionMaxAggregateInputType
  }

  export type GetIcebreakerQuestionAggregateType<T extends IcebreakerQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateIcebreakerQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIcebreakerQuestion[P]>
      : GetScalarType<T[P], AggregateIcebreakerQuestion[P]>
  }




  export type IcebreakerQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IcebreakerQuestionWhereInput
    orderBy?: IcebreakerQuestionOrderByWithAggregationInput | IcebreakerQuestionOrderByWithAggregationInput[]
    by: IcebreakerQuestionScalarFieldEnum[] | IcebreakerQuestionScalarFieldEnum
    having?: IcebreakerQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IcebreakerQuestionCountAggregateInputType | true
    _avg?: IcebreakerQuestionAvgAggregateInputType
    _sum?: IcebreakerQuestionSumAggregateInputType
    _min?: IcebreakerQuestionMinAggregateInputType
    _max?: IcebreakerQuestionMaxAggregateInputType
  }

  export type IcebreakerQuestionGroupByOutputType = {
    id: number
    text: string
    category: $Enums.IcebreakerCategory
    createdAt: Date
    _count: IcebreakerQuestionCountAggregateOutputType | null
    _avg: IcebreakerQuestionAvgAggregateOutputType | null
    _sum: IcebreakerQuestionSumAggregateOutputType | null
    _min: IcebreakerQuestionMinAggregateOutputType | null
    _max: IcebreakerQuestionMaxAggregateOutputType | null
  }

  type GetIcebreakerQuestionGroupByPayload<T extends IcebreakerQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IcebreakerQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IcebreakerQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IcebreakerQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], IcebreakerQuestionGroupByOutputType[P]>
        }
      >
    >


  export type IcebreakerQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["icebreakerQuestion"]>



  export type IcebreakerQuestionSelectScalar = {
    id?: boolean
    text?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type IcebreakerQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "category" | "createdAt", ExtArgs["result"]["icebreakerQuestion"]>

  export type $IcebreakerQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IcebreakerQuestion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      text: string
      category: $Enums.IcebreakerCategory
      createdAt: Date
    }, ExtArgs["result"]["icebreakerQuestion"]>
    composites: {}
  }

  type IcebreakerQuestionGetPayload<S extends boolean | null | undefined | IcebreakerQuestionDefaultArgs> = $Result.GetResult<Prisma.$IcebreakerQuestionPayload, S>

  type IcebreakerQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IcebreakerQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IcebreakerQuestionCountAggregateInputType | true
    }

  export interface IcebreakerQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IcebreakerQuestion'], meta: { name: 'IcebreakerQuestion' } }
    /**
     * Find zero or one IcebreakerQuestion that matches the filter.
     * @param {IcebreakerQuestionFindUniqueArgs} args - Arguments to find a IcebreakerQuestion
     * @example
     * // Get one IcebreakerQuestion
     * const icebreakerQuestion = await prisma.icebreakerQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IcebreakerQuestionFindUniqueArgs>(args: SelectSubset<T, IcebreakerQuestionFindUniqueArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IcebreakerQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IcebreakerQuestionFindUniqueOrThrowArgs} args - Arguments to find a IcebreakerQuestion
     * @example
     * // Get one IcebreakerQuestion
     * const icebreakerQuestion = await prisma.icebreakerQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IcebreakerQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, IcebreakerQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IcebreakerQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionFindFirstArgs} args - Arguments to find a IcebreakerQuestion
     * @example
     * // Get one IcebreakerQuestion
     * const icebreakerQuestion = await prisma.icebreakerQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IcebreakerQuestionFindFirstArgs>(args?: SelectSubset<T, IcebreakerQuestionFindFirstArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IcebreakerQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionFindFirstOrThrowArgs} args - Arguments to find a IcebreakerQuestion
     * @example
     * // Get one IcebreakerQuestion
     * const icebreakerQuestion = await prisma.icebreakerQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IcebreakerQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, IcebreakerQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IcebreakerQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IcebreakerQuestions
     * const icebreakerQuestions = await prisma.icebreakerQuestion.findMany()
     * 
     * // Get first 10 IcebreakerQuestions
     * const icebreakerQuestions = await prisma.icebreakerQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const icebreakerQuestionWithIdOnly = await prisma.icebreakerQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IcebreakerQuestionFindManyArgs>(args?: SelectSubset<T, IcebreakerQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IcebreakerQuestion.
     * @param {IcebreakerQuestionCreateArgs} args - Arguments to create a IcebreakerQuestion.
     * @example
     * // Create one IcebreakerQuestion
     * const IcebreakerQuestion = await prisma.icebreakerQuestion.create({
     *   data: {
     *     // ... data to create a IcebreakerQuestion
     *   }
     * })
     * 
     */
    create<T extends IcebreakerQuestionCreateArgs>(args: SelectSubset<T, IcebreakerQuestionCreateArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IcebreakerQuestions.
     * @param {IcebreakerQuestionCreateManyArgs} args - Arguments to create many IcebreakerQuestions.
     * @example
     * // Create many IcebreakerQuestions
     * const icebreakerQuestion = await prisma.icebreakerQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IcebreakerQuestionCreateManyArgs>(args?: SelectSubset<T, IcebreakerQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IcebreakerQuestion.
     * @param {IcebreakerQuestionDeleteArgs} args - Arguments to delete one IcebreakerQuestion.
     * @example
     * // Delete one IcebreakerQuestion
     * const IcebreakerQuestion = await prisma.icebreakerQuestion.delete({
     *   where: {
     *     // ... filter to delete one IcebreakerQuestion
     *   }
     * })
     * 
     */
    delete<T extends IcebreakerQuestionDeleteArgs>(args: SelectSubset<T, IcebreakerQuestionDeleteArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IcebreakerQuestion.
     * @param {IcebreakerQuestionUpdateArgs} args - Arguments to update one IcebreakerQuestion.
     * @example
     * // Update one IcebreakerQuestion
     * const icebreakerQuestion = await prisma.icebreakerQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IcebreakerQuestionUpdateArgs>(args: SelectSubset<T, IcebreakerQuestionUpdateArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IcebreakerQuestions.
     * @param {IcebreakerQuestionDeleteManyArgs} args - Arguments to filter IcebreakerQuestions to delete.
     * @example
     * // Delete a few IcebreakerQuestions
     * const { count } = await prisma.icebreakerQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IcebreakerQuestionDeleteManyArgs>(args?: SelectSubset<T, IcebreakerQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IcebreakerQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IcebreakerQuestions
     * const icebreakerQuestion = await prisma.icebreakerQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IcebreakerQuestionUpdateManyArgs>(args: SelectSubset<T, IcebreakerQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IcebreakerQuestion.
     * @param {IcebreakerQuestionUpsertArgs} args - Arguments to update or create a IcebreakerQuestion.
     * @example
     * // Update or create a IcebreakerQuestion
     * const icebreakerQuestion = await prisma.icebreakerQuestion.upsert({
     *   create: {
     *     // ... data to create a IcebreakerQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IcebreakerQuestion we want to update
     *   }
     * })
     */
    upsert<T extends IcebreakerQuestionUpsertArgs>(args: SelectSubset<T, IcebreakerQuestionUpsertArgs<ExtArgs>>): Prisma__IcebreakerQuestionClient<$Result.GetResult<Prisma.$IcebreakerQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IcebreakerQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionCountArgs} args - Arguments to filter IcebreakerQuestions to count.
     * @example
     * // Count the number of IcebreakerQuestions
     * const count = await prisma.icebreakerQuestion.count({
     *   where: {
     *     // ... the filter for the IcebreakerQuestions we want to count
     *   }
     * })
    **/
    count<T extends IcebreakerQuestionCountArgs>(
      args?: Subset<T, IcebreakerQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IcebreakerQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IcebreakerQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IcebreakerQuestionAggregateArgs>(args: Subset<T, IcebreakerQuestionAggregateArgs>): Prisma.PrismaPromise<GetIcebreakerQuestionAggregateType<T>>

    /**
     * Group by IcebreakerQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IcebreakerQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IcebreakerQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IcebreakerQuestionGroupByArgs['orderBy'] }
        : { orderBy?: IcebreakerQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IcebreakerQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIcebreakerQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IcebreakerQuestion model
   */
  readonly fields: IcebreakerQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IcebreakerQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IcebreakerQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IcebreakerQuestion model
   */
  interface IcebreakerQuestionFieldRefs {
    readonly id: FieldRef<"IcebreakerQuestion", 'Int'>
    readonly text: FieldRef<"IcebreakerQuestion", 'String'>
    readonly category: FieldRef<"IcebreakerQuestion", 'IcebreakerCategory'>
    readonly createdAt: FieldRef<"IcebreakerQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IcebreakerQuestion findUnique
   */
  export type IcebreakerQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * Filter, which IcebreakerQuestion to fetch.
     */
    where: IcebreakerQuestionWhereUniqueInput
  }

  /**
   * IcebreakerQuestion findUniqueOrThrow
   */
  export type IcebreakerQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * Filter, which IcebreakerQuestion to fetch.
     */
    where: IcebreakerQuestionWhereUniqueInput
  }

  /**
   * IcebreakerQuestion findFirst
   */
  export type IcebreakerQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * Filter, which IcebreakerQuestion to fetch.
     */
    where?: IcebreakerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IcebreakerQuestions to fetch.
     */
    orderBy?: IcebreakerQuestionOrderByWithRelationInput | IcebreakerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IcebreakerQuestions.
     */
    cursor?: IcebreakerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IcebreakerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IcebreakerQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IcebreakerQuestions.
     */
    distinct?: IcebreakerQuestionScalarFieldEnum | IcebreakerQuestionScalarFieldEnum[]
  }

  /**
   * IcebreakerQuestion findFirstOrThrow
   */
  export type IcebreakerQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * Filter, which IcebreakerQuestion to fetch.
     */
    where?: IcebreakerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IcebreakerQuestions to fetch.
     */
    orderBy?: IcebreakerQuestionOrderByWithRelationInput | IcebreakerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IcebreakerQuestions.
     */
    cursor?: IcebreakerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IcebreakerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IcebreakerQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IcebreakerQuestions.
     */
    distinct?: IcebreakerQuestionScalarFieldEnum | IcebreakerQuestionScalarFieldEnum[]
  }

  /**
   * IcebreakerQuestion findMany
   */
  export type IcebreakerQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * Filter, which IcebreakerQuestions to fetch.
     */
    where?: IcebreakerQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IcebreakerQuestions to fetch.
     */
    orderBy?: IcebreakerQuestionOrderByWithRelationInput | IcebreakerQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IcebreakerQuestions.
     */
    cursor?: IcebreakerQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IcebreakerQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IcebreakerQuestions.
     */
    skip?: number
    distinct?: IcebreakerQuestionScalarFieldEnum | IcebreakerQuestionScalarFieldEnum[]
  }

  /**
   * IcebreakerQuestion create
   */
  export type IcebreakerQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * The data needed to create a IcebreakerQuestion.
     */
    data: XOR<IcebreakerQuestionCreateInput, IcebreakerQuestionUncheckedCreateInput>
  }

  /**
   * IcebreakerQuestion createMany
   */
  export type IcebreakerQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IcebreakerQuestions.
     */
    data: IcebreakerQuestionCreateManyInput | IcebreakerQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IcebreakerQuestion update
   */
  export type IcebreakerQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * The data needed to update a IcebreakerQuestion.
     */
    data: XOR<IcebreakerQuestionUpdateInput, IcebreakerQuestionUncheckedUpdateInput>
    /**
     * Choose, which IcebreakerQuestion to update.
     */
    where: IcebreakerQuestionWhereUniqueInput
  }

  /**
   * IcebreakerQuestion updateMany
   */
  export type IcebreakerQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IcebreakerQuestions.
     */
    data: XOR<IcebreakerQuestionUpdateManyMutationInput, IcebreakerQuestionUncheckedUpdateManyInput>
    /**
     * Filter which IcebreakerQuestions to update
     */
    where?: IcebreakerQuestionWhereInput
    /**
     * Limit how many IcebreakerQuestions to update.
     */
    limit?: number
  }

  /**
   * IcebreakerQuestion upsert
   */
  export type IcebreakerQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * The filter to search for the IcebreakerQuestion to update in case it exists.
     */
    where: IcebreakerQuestionWhereUniqueInput
    /**
     * In case the IcebreakerQuestion found by the `where` argument doesn't exist, create a new IcebreakerQuestion with this data.
     */
    create: XOR<IcebreakerQuestionCreateInput, IcebreakerQuestionUncheckedCreateInput>
    /**
     * In case the IcebreakerQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IcebreakerQuestionUpdateInput, IcebreakerQuestionUncheckedUpdateInput>
  }

  /**
   * IcebreakerQuestion delete
   */
  export type IcebreakerQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
    /**
     * Filter which IcebreakerQuestion to delete.
     */
    where: IcebreakerQuestionWhereUniqueInput
  }

  /**
   * IcebreakerQuestion deleteMany
   */
  export type IcebreakerQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IcebreakerQuestions to delete
     */
    where?: IcebreakerQuestionWhereInput
    /**
     * Limit how many IcebreakerQuestions to delete.
     */
    limit?: number
  }

  /**
   * IcebreakerQuestion without action
   */
  export type IcebreakerQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IcebreakerQuestion
     */
    select?: IcebreakerQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IcebreakerQuestion
     */
    omit?: IcebreakerQuestionOmit<ExtArgs> | null
  }


  /**
   * Model ProfileView
   */

  export type AggregateProfileView = {
    _count: ProfileViewCountAggregateOutputType | null
    _avg: ProfileViewAvgAggregateOutputType | null
    _sum: ProfileViewSumAggregateOutputType | null
    _min: ProfileViewMinAggregateOutputType | null
    _max: ProfileViewMaxAggregateOutputType | null
  }

  export type ProfileViewAvgAggregateOutputType = {
    id: number | null
  }

  export type ProfileViewSumAggregateOutputType = {
    id: number | null
  }

  export type ProfileViewMinAggregateOutputType = {
    id: number | null
    viewerId: string | null
    viewedId: string | null
    createdAt: Date | null
  }

  export type ProfileViewMaxAggregateOutputType = {
    id: number | null
    viewerId: string | null
    viewedId: string | null
    createdAt: Date | null
  }

  export type ProfileViewCountAggregateOutputType = {
    id: number
    viewerId: number
    viewedId: number
    createdAt: number
    _all: number
  }


  export type ProfileViewAvgAggregateInputType = {
    id?: true
  }

  export type ProfileViewSumAggregateInputType = {
    id?: true
  }

  export type ProfileViewMinAggregateInputType = {
    id?: true
    viewerId?: true
    viewedId?: true
    createdAt?: true
  }

  export type ProfileViewMaxAggregateInputType = {
    id?: true
    viewerId?: true
    viewedId?: true
    createdAt?: true
  }

  export type ProfileViewCountAggregateInputType = {
    id?: true
    viewerId?: true
    viewedId?: true
    createdAt?: true
    _all?: true
  }

  export type ProfileViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileView to aggregate.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileViews
    **/
    _count?: true | ProfileViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileViewMaxAggregateInputType
  }

  export type GetProfileViewAggregateType<T extends ProfileViewAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileView[P]>
      : GetScalarType<T[P], AggregateProfileView[P]>
  }




  export type ProfileViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileViewWhereInput
    orderBy?: ProfileViewOrderByWithAggregationInput | ProfileViewOrderByWithAggregationInput[]
    by: ProfileViewScalarFieldEnum[] | ProfileViewScalarFieldEnum
    having?: ProfileViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileViewCountAggregateInputType | true
    _avg?: ProfileViewAvgAggregateInputType
    _sum?: ProfileViewSumAggregateInputType
    _min?: ProfileViewMinAggregateInputType
    _max?: ProfileViewMaxAggregateInputType
  }

  export type ProfileViewGroupByOutputType = {
    id: number
    viewerId: string
    viewedId: string
    createdAt: Date
    _count: ProfileViewCountAggregateOutputType | null
    _avg: ProfileViewAvgAggregateOutputType | null
    _sum: ProfileViewSumAggregateOutputType | null
    _min: ProfileViewMinAggregateOutputType | null
    _max: ProfileViewMaxAggregateOutputType | null
  }

  type GetProfileViewGroupByPayload<T extends ProfileViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileViewGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileViewGroupByOutputType[P]>
        }
      >
    >


  export type ProfileViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    viewerId?: boolean
    viewedId?: boolean
    createdAt?: boolean
    viewer?: boolean | UserDefaultArgs<ExtArgs>
    viewed?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileView"]>



  export type ProfileViewSelectScalar = {
    id?: boolean
    viewerId?: boolean
    viewedId?: boolean
    createdAt?: boolean
  }

  export type ProfileViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "viewerId" | "viewedId" | "createdAt", ExtArgs["result"]["profileView"]>
  export type ProfileViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    viewer?: boolean | UserDefaultArgs<ExtArgs>
    viewed?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfileViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileView"
    objects: {
      viewer: Prisma.$UserPayload<ExtArgs>
      viewed: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      viewerId: string
      viewedId: string
      createdAt: Date
    }, ExtArgs["result"]["profileView"]>
    composites: {}
  }

  type ProfileViewGetPayload<S extends boolean | null | undefined | ProfileViewDefaultArgs> = $Result.GetResult<Prisma.$ProfileViewPayload, S>

  type ProfileViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileViewCountAggregateInputType | true
    }

  export interface ProfileViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileView'], meta: { name: 'ProfileView' } }
    /**
     * Find zero or one ProfileView that matches the filter.
     * @param {ProfileViewFindUniqueArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileViewFindUniqueArgs>(args: SelectSubset<T, ProfileViewFindUniqueArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileViewFindUniqueOrThrowArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewFindFirstArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileViewFindFirstArgs>(args?: SelectSubset<T, ProfileViewFindFirstArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewFindFirstOrThrowArgs} args - Arguments to find a ProfileView
     * @example
     * // Get one ProfileView
     * const profileView = await prisma.profileView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileViews
     * const profileViews = await prisma.profileView.findMany()
     * 
     * // Get first 10 ProfileViews
     * const profileViews = await prisma.profileView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileViewWithIdOnly = await prisma.profileView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileViewFindManyArgs>(args?: SelectSubset<T, ProfileViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileView.
     * @param {ProfileViewCreateArgs} args - Arguments to create a ProfileView.
     * @example
     * // Create one ProfileView
     * const ProfileView = await prisma.profileView.create({
     *   data: {
     *     // ... data to create a ProfileView
     *   }
     * })
     * 
     */
    create<T extends ProfileViewCreateArgs>(args: SelectSubset<T, ProfileViewCreateArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileViews.
     * @param {ProfileViewCreateManyArgs} args - Arguments to create many ProfileViews.
     * @example
     * // Create many ProfileViews
     * const profileView = await prisma.profileView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileViewCreateManyArgs>(args?: SelectSubset<T, ProfileViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProfileView.
     * @param {ProfileViewDeleteArgs} args - Arguments to delete one ProfileView.
     * @example
     * // Delete one ProfileView
     * const ProfileView = await prisma.profileView.delete({
     *   where: {
     *     // ... filter to delete one ProfileView
     *   }
     * })
     * 
     */
    delete<T extends ProfileViewDeleteArgs>(args: SelectSubset<T, ProfileViewDeleteArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileView.
     * @param {ProfileViewUpdateArgs} args - Arguments to update one ProfileView.
     * @example
     * // Update one ProfileView
     * const profileView = await prisma.profileView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileViewUpdateArgs>(args: SelectSubset<T, ProfileViewUpdateArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileViews.
     * @param {ProfileViewDeleteManyArgs} args - Arguments to filter ProfileViews to delete.
     * @example
     * // Delete a few ProfileViews
     * const { count } = await prisma.profileView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileViewDeleteManyArgs>(args?: SelectSubset<T, ProfileViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileViews
     * const profileView = await prisma.profileView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileViewUpdateManyArgs>(args: SelectSubset<T, ProfileViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileView.
     * @param {ProfileViewUpsertArgs} args - Arguments to update or create a ProfileView.
     * @example
     * // Update or create a ProfileView
     * const profileView = await prisma.profileView.upsert({
     *   create: {
     *     // ... data to create a ProfileView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileView we want to update
     *   }
     * })
     */
    upsert<T extends ProfileViewUpsertArgs>(args: SelectSubset<T, ProfileViewUpsertArgs<ExtArgs>>): Prisma__ProfileViewClient<$Result.GetResult<Prisma.$ProfileViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewCountArgs} args - Arguments to filter ProfileViews to count.
     * @example
     * // Count the number of ProfileViews
     * const count = await prisma.profileView.count({
     *   where: {
     *     // ... the filter for the ProfileViews we want to count
     *   }
     * })
    **/
    count<T extends ProfileViewCountArgs>(
      args?: Subset<T, ProfileViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileViewAggregateArgs>(args: Subset<T, ProfileViewAggregateArgs>): Prisma.PrismaPromise<GetProfileViewAggregateType<T>>

    /**
     * Group by ProfileView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileViewGroupByArgs['orderBy'] }
        : { orderBy?: ProfileViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileView model
   */
  readonly fields: ProfileViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    viewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    viewed<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileView model
   */
  interface ProfileViewFieldRefs {
    readonly id: FieldRef<"ProfileView", 'Int'>
    readonly viewerId: FieldRef<"ProfileView", 'String'>
    readonly viewedId: FieldRef<"ProfileView", 'String'>
    readonly createdAt: FieldRef<"ProfileView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileView findUnique
   */
  export type ProfileViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView findUniqueOrThrow
   */
  export type ProfileViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView findFirst
   */
  export type ProfileViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileViews.
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileViews.
     */
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * ProfileView findFirstOrThrow
   */
  export type ProfileViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileView to fetch.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileViews.
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileViews.
     */
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * ProfileView findMany
   */
  export type ProfileViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter, which ProfileViews to fetch.
     */
    where?: ProfileViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileViews to fetch.
     */
    orderBy?: ProfileViewOrderByWithRelationInput | ProfileViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileViews.
     */
    cursor?: ProfileViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileViews.
     */
    skip?: number
    distinct?: ProfileViewScalarFieldEnum | ProfileViewScalarFieldEnum[]
  }

  /**
   * ProfileView create
   */
  export type ProfileViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileView.
     */
    data: XOR<ProfileViewCreateInput, ProfileViewUncheckedCreateInput>
  }

  /**
   * ProfileView createMany
   */
  export type ProfileViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileViews.
     */
    data: ProfileViewCreateManyInput | ProfileViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileView update
   */
  export type ProfileViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileView.
     */
    data: XOR<ProfileViewUpdateInput, ProfileViewUncheckedUpdateInput>
    /**
     * Choose, which ProfileView to update.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView updateMany
   */
  export type ProfileViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileViews.
     */
    data: XOR<ProfileViewUpdateManyMutationInput, ProfileViewUncheckedUpdateManyInput>
    /**
     * Filter which ProfileViews to update
     */
    where?: ProfileViewWhereInput
    /**
     * Limit how many ProfileViews to update.
     */
    limit?: number
  }

  /**
   * ProfileView upsert
   */
  export type ProfileViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileView to update in case it exists.
     */
    where: ProfileViewWhereUniqueInput
    /**
     * In case the ProfileView found by the `where` argument doesn't exist, create a new ProfileView with this data.
     */
    create: XOR<ProfileViewCreateInput, ProfileViewUncheckedCreateInput>
    /**
     * In case the ProfileView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileViewUpdateInput, ProfileViewUncheckedUpdateInput>
  }

  /**
   * ProfileView delete
   */
  export type ProfileViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
    /**
     * Filter which ProfileView to delete.
     */
    where: ProfileViewWhereUniqueInput
  }

  /**
   * ProfileView deleteMany
   */
  export type ProfileViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileViews to delete
     */
    where?: ProfileViewWhereInput
    /**
     * Limit how many ProfileViews to delete.
     */
    limit?: number
  }

  /**
   * ProfileView without action
   */
  export type ProfileViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileView
     */
    select?: ProfileViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileView
     */
    omit?: ProfileViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileViewInclude<ExtArgs> | null
  }


  /**
   * Model VenueGroupMessage
   */

  export type AggregateVenueGroupMessage = {
    _count: VenueGroupMessageCountAggregateOutputType | null
    _avg: VenueGroupMessageAvgAggregateOutputType | null
    _sum: VenueGroupMessageSumAggregateOutputType | null
    _min: VenueGroupMessageMinAggregateOutputType | null
    _max: VenueGroupMessageMaxAggregateOutputType | null
  }

  export type VenueGroupMessageAvgAggregateOutputType = {
    id: number | null
    venueId: number | null
  }

  export type VenueGroupMessageSumAggregateOutputType = {
    id: number | null
    venueId: number | null
  }

  export type VenueGroupMessageMinAggregateOutputType = {
    id: number | null
    content: string | null
    imageUrl: string | null
    audioUrl: string | null
    videoUrl: string | null
    createdAt: Date | null
    venueId: number | null
    senderId: string | null
  }

  export type VenueGroupMessageMaxAggregateOutputType = {
    id: number | null
    content: string | null
    imageUrl: string | null
    audioUrl: string | null
    videoUrl: string | null
    createdAt: Date | null
    venueId: number | null
    senderId: string | null
  }

  export type VenueGroupMessageCountAggregateOutputType = {
    id: number
    content: number
    imageUrl: number
    audioUrl: number
    videoUrl: number
    createdAt: number
    venueId: number
    senderId: number
    _all: number
  }


  export type VenueGroupMessageAvgAggregateInputType = {
    id?: true
    venueId?: true
  }

  export type VenueGroupMessageSumAggregateInputType = {
    id?: true
    venueId?: true
  }

  export type VenueGroupMessageMinAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    audioUrl?: true
    videoUrl?: true
    createdAt?: true
    venueId?: true
    senderId?: true
  }

  export type VenueGroupMessageMaxAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    audioUrl?: true
    videoUrl?: true
    createdAt?: true
    venueId?: true
    senderId?: true
  }

  export type VenueGroupMessageCountAggregateInputType = {
    id?: true
    content?: true
    imageUrl?: true
    audioUrl?: true
    videoUrl?: true
    createdAt?: true
    venueId?: true
    senderId?: true
    _all?: true
  }

  export type VenueGroupMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueGroupMessage to aggregate.
     */
    where?: VenueGroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueGroupMessages to fetch.
     */
    orderBy?: VenueGroupMessageOrderByWithRelationInput | VenueGroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueGroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueGroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueGroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VenueGroupMessages
    **/
    _count?: true | VenueGroupMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueGroupMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueGroupMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueGroupMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueGroupMessageMaxAggregateInputType
  }

  export type GetVenueGroupMessageAggregateType<T extends VenueGroupMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateVenueGroupMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenueGroupMessage[P]>
      : GetScalarType<T[P], AggregateVenueGroupMessage[P]>
  }




  export type VenueGroupMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueGroupMessageWhereInput
    orderBy?: VenueGroupMessageOrderByWithAggregationInput | VenueGroupMessageOrderByWithAggregationInput[]
    by: VenueGroupMessageScalarFieldEnum[] | VenueGroupMessageScalarFieldEnum
    having?: VenueGroupMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueGroupMessageCountAggregateInputType | true
    _avg?: VenueGroupMessageAvgAggregateInputType
    _sum?: VenueGroupMessageSumAggregateInputType
    _min?: VenueGroupMessageMinAggregateInputType
    _max?: VenueGroupMessageMaxAggregateInputType
  }

  export type VenueGroupMessageGroupByOutputType = {
    id: number
    content: string | null
    imageUrl: string | null
    audioUrl: string | null
    videoUrl: string | null
    createdAt: Date
    venueId: number
    senderId: string
    _count: VenueGroupMessageCountAggregateOutputType | null
    _avg: VenueGroupMessageAvgAggregateOutputType | null
    _sum: VenueGroupMessageSumAggregateOutputType | null
    _min: VenueGroupMessageMinAggregateOutputType | null
    _max: VenueGroupMessageMaxAggregateOutputType | null
  }

  type GetVenueGroupMessageGroupByPayload<T extends VenueGroupMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupMessageGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupMessageGroupByOutputType[P]>
        }
      >
    >


  export type VenueGroupMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    audioUrl?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    venueId?: boolean
    senderId?: boolean
    reports?: boolean | VenueGroupMessage$reportsArgs<ExtArgs>
    reactions?: boolean | VenueGroupMessage$reactionsArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | VenueGroupMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venueGroupMessage"]>



  export type VenueGroupMessageSelectScalar = {
    id?: boolean
    content?: boolean
    imageUrl?: boolean
    audioUrl?: boolean
    videoUrl?: boolean
    createdAt?: boolean
    venueId?: boolean
    senderId?: boolean
  }

  export type VenueGroupMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "imageUrl" | "audioUrl" | "videoUrl" | "createdAt" | "venueId" | "senderId", ExtArgs["result"]["venueGroupMessage"]>
  export type VenueGroupMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | VenueGroupMessage$reportsArgs<ExtArgs>
    reactions?: boolean | VenueGroupMessage$reactionsArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | VenueGroupMessageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VenueGroupMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VenueGroupMessage"
    objects: {
      reports: Prisma.$ReportPayload<ExtArgs>[]
      reactions: Prisma.$GroupMessageReactionPayload<ExtArgs>[]
      venue: Prisma.$VenuePayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string | null
      imageUrl: string | null
      audioUrl: string | null
      videoUrl: string | null
      createdAt: Date
      venueId: number
      senderId: string
    }, ExtArgs["result"]["venueGroupMessage"]>
    composites: {}
  }

  type VenueGroupMessageGetPayload<S extends boolean | null | undefined | VenueGroupMessageDefaultArgs> = $Result.GetResult<Prisma.$VenueGroupMessagePayload, S>

  type VenueGroupMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueGroupMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueGroupMessageCountAggregateInputType | true
    }

  export interface VenueGroupMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VenueGroupMessage'], meta: { name: 'VenueGroupMessage' } }
    /**
     * Find zero or one VenueGroupMessage that matches the filter.
     * @param {VenueGroupMessageFindUniqueArgs} args - Arguments to find a VenueGroupMessage
     * @example
     * // Get one VenueGroupMessage
     * const venueGroupMessage = await prisma.venueGroupMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueGroupMessageFindUniqueArgs>(args: SelectSubset<T, VenueGroupMessageFindUniqueArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VenueGroupMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueGroupMessageFindUniqueOrThrowArgs} args - Arguments to find a VenueGroupMessage
     * @example
     * // Get one VenueGroupMessage
     * const venueGroupMessage = await prisma.venueGroupMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueGroupMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueGroupMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VenueGroupMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageFindFirstArgs} args - Arguments to find a VenueGroupMessage
     * @example
     * // Get one VenueGroupMessage
     * const venueGroupMessage = await prisma.venueGroupMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueGroupMessageFindFirstArgs>(args?: SelectSubset<T, VenueGroupMessageFindFirstArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VenueGroupMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageFindFirstOrThrowArgs} args - Arguments to find a VenueGroupMessage
     * @example
     * // Get one VenueGroupMessage
     * const venueGroupMessage = await prisma.venueGroupMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueGroupMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueGroupMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VenueGroupMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VenueGroupMessages
     * const venueGroupMessages = await prisma.venueGroupMessage.findMany()
     * 
     * // Get first 10 VenueGroupMessages
     * const venueGroupMessages = await prisma.venueGroupMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueGroupMessageWithIdOnly = await prisma.venueGroupMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueGroupMessageFindManyArgs>(args?: SelectSubset<T, VenueGroupMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VenueGroupMessage.
     * @param {VenueGroupMessageCreateArgs} args - Arguments to create a VenueGroupMessage.
     * @example
     * // Create one VenueGroupMessage
     * const VenueGroupMessage = await prisma.venueGroupMessage.create({
     *   data: {
     *     // ... data to create a VenueGroupMessage
     *   }
     * })
     * 
     */
    create<T extends VenueGroupMessageCreateArgs>(args: SelectSubset<T, VenueGroupMessageCreateArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VenueGroupMessages.
     * @param {VenueGroupMessageCreateManyArgs} args - Arguments to create many VenueGroupMessages.
     * @example
     * // Create many VenueGroupMessages
     * const venueGroupMessage = await prisma.venueGroupMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueGroupMessageCreateManyArgs>(args?: SelectSubset<T, VenueGroupMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VenueGroupMessage.
     * @param {VenueGroupMessageDeleteArgs} args - Arguments to delete one VenueGroupMessage.
     * @example
     * // Delete one VenueGroupMessage
     * const VenueGroupMessage = await prisma.venueGroupMessage.delete({
     *   where: {
     *     // ... filter to delete one VenueGroupMessage
     *   }
     * })
     * 
     */
    delete<T extends VenueGroupMessageDeleteArgs>(args: SelectSubset<T, VenueGroupMessageDeleteArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VenueGroupMessage.
     * @param {VenueGroupMessageUpdateArgs} args - Arguments to update one VenueGroupMessage.
     * @example
     * // Update one VenueGroupMessage
     * const venueGroupMessage = await prisma.venueGroupMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueGroupMessageUpdateArgs>(args: SelectSubset<T, VenueGroupMessageUpdateArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VenueGroupMessages.
     * @param {VenueGroupMessageDeleteManyArgs} args - Arguments to filter VenueGroupMessages to delete.
     * @example
     * // Delete a few VenueGroupMessages
     * const { count } = await prisma.venueGroupMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueGroupMessageDeleteManyArgs>(args?: SelectSubset<T, VenueGroupMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VenueGroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VenueGroupMessages
     * const venueGroupMessage = await prisma.venueGroupMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueGroupMessageUpdateManyArgs>(args: SelectSubset<T, VenueGroupMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VenueGroupMessage.
     * @param {VenueGroupMessageUpsertArgs} args - Arguments to update or create a VenueGroupMessage.
     * @example
     * // Update or create a VenueGroupMessage
     * const venueGroupMessage = await prisma.venueGroupMessage.upsert({
     *   create: {
     *     // ... data to create a VenueGroupMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VenueGroupMessage we want to update
     *   }
     * })
     */
    upsert<T extends VenueGroupMessageUpsertArgs>(args: SelectSubset<T, VenueGroupMessageUpsertArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VenueGroupMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageCountArgs} args - Arguments to filter VenueGroupMessages to count.
     * @example
     * // Count the number of VenueGroupMessages
     * const count = await prisma.venueGroupMessage.count({
     *   where: {
     *     // ... the filter for the VenueGroupMessages we want to count
     *   }
     * })
    **/
    count<T extends VenueGroupMessageCountArgs>(
      args?: Subset<T, VenueGroupMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueGroupMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VenueGroupMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueGroupMessageAggregateArgs>(args: Subset<T, VenueGroupMessageAggregateArgs>): Prisma.PrismaPromise<GetVenueGroupMessageAggregateType<T>>

    /**
     * Group by VenueGroupMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupMessageGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VenueGroupMessage model
   */
  readonly fields: VenueGroupMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VenueGroupMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueGroupMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends VenueGroupMessage$reportsArgs<ExtArgs> = {}>(args?: Subset<T, VenueGroupMessage$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactions<T extends VenueGroupMessage$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, VenueGroupMessage$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VenueGroupMessage model
   */
  interface VenueGroupMessageFieldRefs {
    readonly id: FieldRef<"VenueGroupMessage", 'Int'>
    readonly content: FieldRef<"VenueGroupMessage", 'String'>
    readonly imageUrl: FieldRef<"VenueGroupMessage", 'String'>
    readonly audioUrl: FieldRef<"VenueGroupMessage", 'String'>
    readonly videoUrl: FieldRef<"VenueGroupMessage", 'String'>
    readonly createdAt: FieldRef<"VenueGroupMessage", 'DateTime'>
    readonly venueId: FieldRef<"VenueGroupMessage", 'Int'>
    readonly senderId: FieldRef<"VenueGroupMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VenueGroupMessage findUnique
   */
  export type VenueGroupMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which VenueGroupMessage to fetch.
     */
    where: VenueGroupMessageWhereUniqueInput
  }

  /**
   * VenueGroupMessage findUniqueOrThrow
   */
  export type VenueGroupMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which VenueGroupMessage to fetch.
     */
    where: VenueGroupMessageWhereUniqueInput
  }

  /**
   * VenueGroupMessage findFirst
   */
  export type VenueGroupMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which VenueGroupMessage to fetch.
     */
    where?: VenueGroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueGroupMessages to fetch.
     */
    orderBy?: VenueGroupMessageOrderByWithRelationInput | VenueGroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueGroupMessages.
     */
    cursor?: VenueGroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueGroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueGroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueGroupMessages.
     */
    distinct?: VenueGroupMessageScalarFieldEnum | VenueGroupMessageScalarFieldEnum[]
  }

  /**
   * VenueGroupMessage findFirstOrThrow
   */
  export type VenueGroupMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which VenueGroupMessage to fetch.
     */
    where?: VenueGroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueGroupMessages to fetch.
     */
    orderBy?: VenueGroupMessageOrderByWithRelationInput | VenueGroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VenueGroupMessages.
     */
    cursor?: VenueGroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueGroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueGroupMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VenueGroupMessages.
     */
    distinct?: VenueGroupMessageScalarFieldEnum | VenueGroupMessageScalarFieldEnum[]
  }

  /**
   * VenueGroupMessage findMany
   */
  export type VenueGroupMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * Filter, which VenueGroupMessages to fetch.
     */
    where?: VenueGroupMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VenueGroupMessages to fetch.
     */
    orderBy?: VenueGroupMessageOrderByWithRelationInput | VenueGroupMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VenueGroupMessages.
     */
    cursor?: VenueGroupMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VenueGroupMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VenueGroupMessages.
     */
    skip?: number
    distinct?: VenueGroupMessageScalarFieldEnum | VenueGroupMessageScalarFieldEnum[]
  }

  /**
   * VenueGroupMessage create
   */
  export type VenueGroupMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a VenueGroupMessage.
     */
    data: XOR<VenueGroupMessageCreateInput, VenueGroupMessageUncheckedCreateInput>
  }

  /**
   * VenueGroupMessage createMany
   */
  export type VenueGroupMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VenueGroupMessages.
     */
    data: VenueGroupMessageCreateManyInput | VenueGroupMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VenueGroupMessage update
   */
  export type VenueGroupMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a VenueGroupMessage.
     */
    data: XOR<VenueGroupMessageUpdateInput, VenueGroupMessageUncheckedUpdateInput>
    /**
     * Choose, which VenueGroupMessage to update.
     */
    where: VenueGroupMessageWhereUniqueInput
  }

  /**
   * VenueGroupMessage updateMany
   */
  export type VenueGroupMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VenueGroupMessages.
     */
    data: XOR<VenueGroupMessageUpdateManyMutationInput, VenueGroupMessageUncheckedUpdateManyInput>
    /**
     * Filter which VenueGroupMessages to update
     */
    where?: VenueGroupMessageWhereInput
    /**
     * Limit how many VenueGroupMessages to update.
     */
    limit?: number
  }

  /**
   * VenueGroupMessage upsert
   */
  export type VenueGroupMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the VenueGroupMessage to update in case it exists.
     */
    where: VenueGroupMessageWhereUniqueInput
    /**
     * In case the VenueGroupMessage found by the `where` argument doesn't exist, create a new VenueGroupMessage with this data.
     */
    create: XOR<VenueGroupMessageCreateInput, VenueGroupMessageUncheckedCreateInput>
    /**
     * In case the VenueGroupMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueGroupMessageUpdateInput, VenueGroupMessageUncheckedUpdateInput>
  }

  /**
   * VenueGroupMessage delete
   */
  export type VenueGroupMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
    /**
     * Filter which VenueGroupMessage to delete.
     */
    where: VenueGroupMessageWhereUniqueInput
  }

  /**
   * VenueGroupMessage deleteMany
   */
  export type VenueGroupMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VenueGroupMessages to delete
     */
    where?: VenueGroupMessageWhereInput
    /**
     * Limit how many VenueGroupMessages to delete.
     */
    limit?: number
  }

  /**
   * VenueGroupMessage.reports
   */
  export type VenueGroupMessage$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * VenueGroupMessage.reactions
   */
  export type VenueGroupMessage$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    where?: GroupMessageReactionWhereInput
    orderBy?: GroupMessageReactionOrderByWithRelationInput | GroupMessageReactionOrderByWithRelationInput[]
    cursor?: GroupMessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupMessageReactionScalarFieldEnum | GroupMessageReactionScalarFieldEnum[]
  }

  /**
   * VenueGroupMessage without action
   */
  export type VenueGroupMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueGroupMessage
     */
    select?: VenueGroupMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VenueGroupMessage
     */
    omit?: VenueGroupMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueGroupMessageInclude<ExtArgs> | null
  }


  /**
   * Model AccountDeletionToken
   */

  export type AggregateAccountDeletionToken = {
    _count: AccountDeletionTokenCountAggregateOutputType | null
    _avg: AccountDeletionTokenAvgAggregateOutputType | null
    _sum: AccountDeletionTokenSumAggregateOutputType | null
    _min: AccountDeletionTokenMinAggregateOutputType | null
    _max: AccountDeletionTokenMaxAggregateOutputType | null
  }

  export type AccountDeletionTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type AccountDeletionTokenSumAggregateOutputType = {
    id: number | null
  }

  export type AccountDeletionTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type AccountDeletionTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type AccountDeletionTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    createdAt: number
    userId: number
    _all: number
  }


  export type AccountDeletionTokenAvgAggregateInputType = {
    id?: true
  }

  export type AccountDeletionTokenSumAggregateInputType = {
    id?: true
  }

  export type AccountDeletionTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type AccountDeletionTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type AccountDeletionTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type AccountDeletionTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountDeletionToken to aggregate.
     */
    where?: AccountDeletionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeletionTokens to fetch.
     */
    orderBy?: AccountDeletionTokenOrderByWithRelationInput | AccountDeletionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountDeletionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeletionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeletionTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountDeletionTokens
    **/
    _count?: true | AccountDeletionTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountDeletionTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountDeletionTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountDeletionTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountDeletionTokenMaxAggregateInputType
  }

  export type GetAccountDeletionTokenAggregateType<T extends AccountDeletionTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountDeletionToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountDeletionToken[P]>
      : GetScalarType<T[P], AggregateAccountDeletionToken[P]>
  }




  export type AccountDeletionTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountDeletionTokenWhereInput
    orderBy?: AccountDeletionTokenOrderByWithAggregationInput | AccountDeletionTokenOrderByWithAggregationInput[]
    by: AccountDeletionTokenScalarFieldEnum[] | AccountDeletionTokenScalarFieldEnum
    having?: AccountDeletionTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountDeletionTokenCountAggregateInputType | true
    _avg?: AccountDeletionTokenAvgAggregateInputType
    _sum?: AccountDeletionTokenSumAggregateInputType
    _min?: AccountDeletionTokenMinAggregateInputType
    _max?: AccountDeletionTokenMaxAggregateInputType
  }

  export type AccountDeletionTokenGroupByOutputType = {
    id: number
    token: string
    expiresAt: Date
    createdAt: Date
    userId: string
    _count: AccountDeletionTokenCountAggregateOutputType | null
    _avg: AccountDeletionTokenAvgAggregateOutputType | null
    _sum: AccountDeletionTokenSumAggregateOutputType | null
    _min: AccountDeletionTokenMinAggregateOutputType | null
    _max: AccountDeletionTokenMaxAggregateOutputType | null
  }

  type GetAccountDeletionTokenGroupByPayload<T extends AccountDeletionTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountDeletionTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountDeletionTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountDeletionTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AccountDeletionTokenGroupByOutputType[P]>
        }
      >
    >


  export type AccountDeletionTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountDeletionToken"]>



  export type AccountDeletionTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type AccountDeletionTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "createdAt" | "userId", ExtArgs["result"]["accountDeletionToken"]>
  export type AccountDeletionTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountDeletionTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountDeletionToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      expiresAt: Date
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["accountDeletionToken"]>
    composites: {}
  }

  type AccountDeletionTokenGetPayload<S extends boolean | null | undefined | AccountDeletionTokenDefaultArgs> = $Result.GetResult<Prisma.$AccountDeletionTokenPayload, S>

  type AccountDeletionTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountDeletionTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountDeletionTokenCountAggregateInputType | true
    }

  export interface AccountDeletionTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountDeletionToken'], meta: { name: 'AccountDeletionToken' } }
    /**
     * Find zero or one AccountDeletionToken that matches the filter.
     * @param {AccountDeletionTokenFindUniqueArgs} args - Arguments to find a AccountDeletionToken
     * @example
     * // Get one AccountDeletionToken
     * const accountDeletionToken = await prisma.accountDeletionToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountDeletionTokenFindUniqueArgs>(args: SelectSubset<T, AccountDeletionTokenFindUniqueArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountDeletionToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountDeletionTokenFindUniqueOrThrowArgs} args - Arguments to find a AccountDeletionToken
     * @example
     * // Get one AccountDeletionToken
     * const accountDeletionToken = await prisma.accountDeletionToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountDeletionTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountDeletionTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountDeletionToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenFindFirstArgs} args - Arguments to find a AccountDeletionToken
     * @example
     * // Get one AccountDeletionToken
     * const accountDeletionToken = await prisma.accountDeletionToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountDeletionTokenFindFirstArgs>(args?: SelectSubset<T, AccountDeletionTokenFindFirstArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountDeletionToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenFindFirstOrThrowArgs} args - Arguments to find a AccountDeletionToken
     * @example
     * // Get one AccountDeletionToken
     * const accountDeletionToken = await prisma.accountDeletionToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountDeletionTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountDeletionTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountDeletionTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountDeletionTokens
     * const accountDeletionTokens = await prisma.accountDeletionToken.findMany()
     * 
     * // Get first 10 AccountDeletionTokens
     * const accountDeletionTokens = await prisma.accountDeletionToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountDeletionTokenWithIdOnly = await prisma.accountDeletionToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountDeletionTokenFindManyArgs>(args?: SelectSubset<T, AccountDeletionTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountDeletionToken.
     * @param {AccountDeletionTokenCreateArgs} args - Arguments to create a AccountDeletionToken.
     * @example
     * // Create one AccountDeletionToken
     * const AccountDeletionToken = await prisma.accountDeletionToken.create({
     *   data: {
     *     // ... data to create a AccountDeletionToken
     *   }
     * })
     * 
     */
    create<T extends AccountDeletionTokenCreateArgs>(args: SelectSubset<T, AccountDeletionTokenCreateArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountDeletionTokens.
     * @param {AccountDeletionTokenCreateManyArgs} args - Arguments to create many AccountDeletionTokens.
     * @example
     * // Create many AccountDeletionTokens
     * const accountDeletionToken = await prisma.accountDeletionToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountDeletionTokenCreateManyArgs>(args?: SelectSubset<T, AccountDeletionTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccountDeletionToken.
     * @param {AccountDeletionTokenDeleteArgs} args - Arguments to delete one AccountDeletionToken.
     * @example
     * // Delete one AccountDeletionToken
     * const AccountDeletionToken = await prisma.accountDeletionToken.delete({
     *   where: {
     *     // ... filter to delete one AccountDeletionToken
     *   }
     * })
     * 
     */
    delete<T extends AccountDeletionTokenDeleteArgs>(args: SelectSubset<T, AccountDeletionTokenDeleteArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountDeletionToken.
     * @param {AccountDeletionTokenUpdateArgs} args - Arguments to update one AccountDeletionToken.
     * @example
     * // Update one AccountDeletionToken
     * const accountDeletionToken = await prisma.accountDeletionToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountDeletionTokenUpdateArgs>(args: SelectSubset<T, AccountDeletionTokenUpdateArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountDeletionTokens.
     * @param {AccountDeletionTokenDeleteManyArgs} args - Arguments to filter AccountDeletionTokens to delete.
     * @example
     * // Delete a few AccountDeletionTokens
     * const { count } = await prisma.accountDeletionToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeletionTokenDeleteManyArgs>(args?: SelectSubset<T, AccountDeletionTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountDeletionTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountDeletionTokens
     * const accountDeletionToken = await prisma.accountDeletionToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountDeletionTokenUpdateManyArgs>(args: SelectSubset<T, AccountDeletionTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountDeletionToken.
     * @param {AccountDeletionTokenUpsertArgs} args - Arguments to update or create a AccountDeletionToken.
     * @example
     * // Update or create a AccountDeletionToken
     * const accountDeletionToken = await prisma.accountDeletionToken.upsert({
     *   create: {
     *     // ... data to create a AccountDeletionToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountDeletionToken we want to update
     *   }
     * })
     */
    upsert<T extends AccountDeletionTokenUpsertArgs>(args: SelectSubset<T, AccountDeletionTokenUpsertArgs<ExtArgs>>): Prisma__AccountDeletionTokenClient<$Result.GetResult<Prisma.$AccountDeletionTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountDeletionTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenCountArgs} args - Arguments to filter AccountDeletionTokens to count.
     * @example
     * // Count the number of AccountDeletionTokens
     * const count = await prisma.accountDeletionToken.count({
     *   where: {
     *     // ... the filter for the AccountDeletionTokens we want to count
     *   }
     * })
    **/
    count<T extends AccountDeletionTokenCountArgs>(
      args?: Subset<T, AccountDeletionTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountDeletionTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountDeletionToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountDeletionTokenAggregateArgs>(args: Subset<T, AccountDeletionTokenAggregateArgs>): Prisma.PrismaPromise<GetAccountDeletionTokenAggregateType<T>>

    /**
     * Group by AccountDeletionToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountDeletionTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountDeletionTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountDeletionTokenGroupByArgs['orderBy'] }
        : { orderBy?: AccountDeletionTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountDeletionTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountDeletionTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountDeletionToken model
   */
  readonly fields: AccountDeletionTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountDeletionToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountDeletionTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountDeletionToken model
   */
  interface AccountDeletionTokenFieldRefs {
    readonly id: FieldRef<"AccountDeletionToken", 'Int'>
    readonly token: FieldRef<"AccountDeletionToken", 'String'>
    readonly expiresAt: FieldRef<"AccountDeletionToken", 'DateTime'>
    readonly createdAt: FieldRef<"AccountDeletionToken", 'DateTime'>
    readonly userId: FieldRef<"AccountDeletionToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountDeletionToken findUnique
   */
  export type AccountDeletionTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountDeletionToken to fetch.
     */
    where: AccountDeletionTokenWhereUniqueInput
  }

  /**
   * AccountDeletionToken findUniqueOrThrow
   */
  export type AccountDeletionTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountDeletionToken to fetch.
     */
    where: AccountDeletionTokenWhereUniqueInput
  }

  /**
   * AccountDeletionToken findFirst
   */
  export type AccountDeletionTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountDeletionToken to fetch.
     */
    where?: AccountDeletionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeletionTokens to fetch.
     */
    orderBy?: AccountDeletionTokenOrderByWithRelationInput | AccountDeletionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountDeletionTokens.
     */
    cursor?: AccountDeletionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeletionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeletionTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountDeletionTokens.
     */
    distinct?: AccountDeletionTokenScalarFieldEnum | AccountDeletionTokenScalarFieldEnum[]
  }

  /**
   * AccountDeletionToken findFirstOrThrow
   */
  export type AccountDeletionTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountDeletionToken to fetch.
     */
    where?: AccountDeletionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeletionTokens to fetch.
     */
    orderBy?: AccountDeletionTokenOrderByWithRelationInput | AccountDeletionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountDeletionTokens.
     */
    cursor?: AccountDeletionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeletionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeletionTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountDeletionTokens.
     */
    distinct?: AccountDeletionTokenScalarFieldEnum | AccountDeletionTokenScalarFieldEnum[]
  }

  /**
   * AccountDeletionToken findMany
   */
  export type AccountDeletionTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountDeletionTokens to fetch.
     */
    where?: AccountDeletionTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountDeletionTokens to fetch.
     */
    orderBy?: AccountDeletionTokenOrderByWithRelationInput | AccountDeletionTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountDeletionTokens.
     */
    cursor?: AccountDeletionTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountDeletionTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountDeletionTokens.
     */
    skip?: number
    distinct?: AccountDeletionTokenScalarFieldEnum | AccountDeletionTokenScalarFieldEnum[]
  }

  /**
   * AccountDeletionToken create
   */
  export type AccountDeletionTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountDeletionToken.
     */
    data: XOR<AccountDeletionTokenCreateInput, AccountDeletionTokenUncheckedCreateInput>
  }

  /**
   * AccountDeletionToken createMany
   */
  export type AccountDeletionTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountDeletionTokens.
     */
    data: AccountDeletionTokenCreateManyInput | AccountDeletionTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountDeletionToken update
   */
  export type AccountDeletionTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountDeletionToken.
     */
    data: XOR<AccountDeletionTokenUpdateInput, AccountDeletionTokenUncheckedUpdateInput>
    /**
     * Choose, which AccountDeletionToken to update.
     */
    where: AccountDeletionTokenWhereUniqueInput
  }

  /**
   * AccountDeletionToken updateMany
   */
  export type AccountDeletionTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountDeletionTokens.
     */
    data: XOR<AccountDeletionTokenUpdateManyMutationInput, AccountDeletionTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccountDeletionTokens to update
     */
    where?: AccountDeletionTokenWhereInput
    /**
     * Limit how many AccountDeletionTokens to update.
     */
    limit?: number
  }

  /**
   * AccountDeletionToken upsert
   */
  export type AccountDeletionTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountDeletionToken to update in case it exists.
     */
    where: AccountDeletionTokenWhereUniqueInput
    /**
     * In case the AccountDeletionToken found by the `where` argument doesn't exist, create a new AccountDeletionToken with this data.
     */
    create: XOR<AccountDeletionTokenCreateInput, AccountDeletionTokenUncheckedCreateInput>
    /**
     * In case the AccountDeletionToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountDeletionTokenUpdateInput, AccountDeletionTokenUncheckedUpdateInput>
  }

  /**
   * AccountDeletionToken delete
   */
  export type AccountDeletionTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
    /**
     * Filter which AccountDeletionToken to delete.
     */
    where: AccountDeletionTokenWhereUniqueInput
  }

  /**
   * AccountDeletionToken deleteMany
   */
  export type AccountDeletionTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountDeletionTokens to delete
     */
    where?: AccountDeletionTokenWhereInput
    /**
     * Limit how many AccountDeletionTokens to delete.
     */
    limit?: number
  }

  /**
   * AccountDeletionToken without action
   */
  export type AccountDeletionTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountDeletionToken
     */
    select?: AccountDeletionTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountDeletionToken
     */
    omit?: AccountDeletionTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountDeletionTokenInclude<ExtArgs> | null
  }


  /**
   * Model EmailChangeToken
   */

  export type AggregateEmailChangeToken = {
    _count: EmailChangeTokenCountAggregateOutputType | null
    _avg: EmailChangeTokenAvgAggregateOutputType | null
    _sum: EmailChangeTokenSumAggregateOutputType | null
    _min: EmailChangeTokenMinAggregateOutputType | null
    _max: EmailChangeTokenMaxAggregateOutputType | null
  }

  export type EmailChangeTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type EmailChangeTokenSumAggregateOutputType = {
    id: number | null
  }

  export type EmailChangeTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    newEmail: string | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type EmailChangeTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    newEmail: string | null
    expiresAt: Date | null
    createdAt: Date | null
    userId: string | null
  }

  export type EmailChangeTokenCountAggregateOutputType = {
    id: number
    token: number
    newEmail: number
    expiresAt: number
    createdAt: number
    userId: number
    _all: number
  }


  export type EmailChangeTokenAvgAggregateInputType = {
    id?: true
  }

  export type EmailChangeTokenSumAggregateInputType = {
    id?: true
  }

  export type EmailChangeTokenMinAggregateInputType = {
    id?: true
    token?: true
    newEmail?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type EmailChangeTokenMaxAggregateInputType = {
    id?: true
    token?: true
    newEmail?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
  }

  export type EmailChangeTokenCountAggregateInputType = {
    id?: true
    token?: true
    newEmail?: true
    expiresAt?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type EmailChangeTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailChangeToken to aggregate.
     */
    where?: EmailChangeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeTokens to fetch.
     */
    orderBy?: EmailChangeTokenOrderByWithRelationInput | EmailChangeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailChangeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChangeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailChangeTokens
    **/
    _count?: true | EmailChangeTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailChangeTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailChangeTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailChangeTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailChangeTokenMaxAggregateInputType
  }

  export type GetEmailChangeTokenAggregateType<T extends EmailChangeTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailChangeToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailChangeToken[P]>
      : GetScalarType<T[P], AggregateEmailChangeToken[P]>
  }




  export type EmailChangeTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailChangeTokenWhereInput
    orderBy?: EmailChangeTokenOrderByWithAggregationInput | EmailChangeTokenOrderByWithAggregationInput[]
    by: EmailChangeTokenScalarFieldEnum[] | EmailChangeTokenScalarFieldEnum
    having?: EmailChangeTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailChangeTokenCountAggregateInputType | true
    _avg?: EmailChangeTokenAvgAggregateInputType
    _sum?: EmailChangeTokenSumAggregateInputType
    _min?: EmailChangeTokenMinAggregateInputType
    _max?: EmailChangeTokenMaxAggregateInputType
  }

  export type EmailChangeTokenGroupByOutputType = {
    id: number
    token: string
    newEmail: string
    expiresAt: Date
    createdAt: Date
    userId: string
    _count: EmailChangeTokenCountAggregateOutputType | null
    _avg: EmailChangeTokenAvgAggregateOutputType | null
    _sum: EmailChangeTokenSumAggregateOutputType | null
    _min: EmailChangeTokenMinAggregateOutputType | null
    _max: EmailChangeTokenMaxAggregateOutputType | null
  }

  type GetEmailChangeTokenGroupByPayload<T extends EmailChangeTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailChangeTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailChangeTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailChangeTokenGroupByOutputType[P]>
            : GetScalarType<T[P], EmailChangeTokenGroupByOutputType[P]>
        }
      >
    >


  export type EmailChangeTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    newEmail?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChangeToken"]>



  export type EmailChangeTokenSelectScalar = {
    id?: boolean
    token?: boolean
    newEmail?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type EmailChangeTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "newEmail" | "expiresAt" | "createdAt" | "userId", ExtArgs["result"]["emailChangeToken"]>
  export type EmailChangeTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailChangeTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailChangeToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      newEmail: string
      expiresAt: Date
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["emailChangeToken"]>
    composites: {}
  }

  type EmailChangeTokenGetPayload<S extends boolean | null | undefined | EmailChangeTokenDefaultArgs> = $Result.GetResult<Prisma.$EmailChangeTokenPayload, S>

  type EmailChangeTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailChangeTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailChangeTokenCountAggregateInputType | true
    }

  export interface EmailChangeTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailChangeToken'], meta: { name: 'EmailChangeToken' } }
    /**
     * Find zero or one EmailChangeToken that matches the filter.
     * @param {EmailChangeTokenFindUniqueArgs} args - Arguments to find a EmailChangeToken
     * @example
     * // Get one EmailChangeToken
     * const emailChangeToken = await prisma.emailChangeToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailChangeTokenFindUniqueArgs>(args: SelectSubset<T, EmailChangeTokenFindUniqueArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailChangeToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailChangeTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailChangeToken
     * @example
     * // Get one EmailChangeToken
     * const emailChangeToken = await prisma.emailChangeToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailChangeTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailChangeTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailChangeToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenFindFirstArgs} args - Arguments to find a EmailChangeToken
     * @example
     * // Get one EmailChangeToken
     * const emailChangeToken = await prisma.emailChangeToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailChangeTokenFindFirstArgs>(args?: SelectSubset<T, EmailChangeTokenFindFirstArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailChangeToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenFindFirstOrThrowArgs} args - Arguments to find a EmailChangeToken
     * @example
     * // Get one EmailChangeToken
     * const emailChangeToken = await prisma.emailChangeToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailChangeTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailChangeTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailChangeTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailChangeTokens
     * const emailChangeTokens = await prisma.emailChangeToken.findMany()
     * 
     * // Get first 10 EmailChangeTokens
     * const emailChangeTokens = await prisma.emailChangeToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailChangeTokenWithIdOnly = await prisma.emailChangeToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailChangeTokenFindManyArgs>(args?: SelectSubset<T, EmailChangeTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailChangeToken.
     * @param {EmailChangeTokenCreateArgs} args - Arguments to create a EmailChangeToken.
     * @example
     * // Create one EmailChangeToken
     * const EmailChangeToken = await prisma.emailChangeToken.create({
     *   data: {
     *     // ... data to create a EmailChangeToken
     *   }
     * })
     * 
     */
    create<T extends EmailChangeTokenCreateArgs>(args: SelectSubset<T, EmailChangeTokenCreateArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailChangeTokens.
     * @param {EmailChangeTokenCreateManyArgs} args - Arguments to create many EmailChangeTokens.
     * @example
     * // Create many EmailChangeTokens
     * const emailChangeToken = await prisma.emailChangeToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailChangeTokenCreateManyArgs>(args?: SelectSubset<T, EmailChangeTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailChangeToken.
     * @param {EmailChangeTokenDeleteArgs} args - Arguments to delete one EmailChangeToken.
     * @example
     * // Delete one EmailChangeToken
     * const EmailChangeToken = await prisma.emailChangeToken.delete({
     *   where: {
     *     // ... filter to delete one EmailChangeToken
     *   }
     * })
     * 
     */
    delete<T extends EmailChangeTokenDeleteArgs>(args: SelectSubset<T, EmailChangeTokenDeleteArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailChangeToken.
     * @param {EmailChangeTokenUpdateArgs} args - Arguments to update one EmailChangeToken.
     * @example
     * // Update one EmailChangeToken
     * const emailChangeToken = await prisma.emailChangeToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailChangeTokenUpdateArgs>(args: SelectSubset<T, EmailChangeTokenUpdateArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailChangeTokens.
     * @param {EmailChangeTokenDeleteManyArgs} args - Arguments to filter EmailChangeTokens to delete.
     * @example
     * // Delete a few EmailChangeTokens
     * const { count } = await prisma.emailChangeToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailChangeTokenDeleteManyArgs>(args?: SelectSubset<T, EmailChangeTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailChangeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailChangeTokens
     * const emailChangeToken = await prisma.emailChangeToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailChangeTokenUpdateManyArgs>(args: SelectSubset<T, EmailChangeTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailChangeToken.
     * @param {EmailChangeTokenUpsertArgs} args - Arguments to update or create a EmailChangeToken.
     * @example
     * // Update or create a EmailChangeToken
     * const emailChangeToken = await prisma.emailChangeToken.upsert({
     *   create: {
     *     // ... data to create a EmailChangeToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailChangeToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailChangeTokenUpsertArgs>(args: SelectSubset<T, EmailChangeTokenUpsertArgs<ExtArgs>>): Prisma__EmailChangeTokenClient<$Result.GetResult<Prisma.$EmailChangeTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailChangeTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenCountArgs} args - Arguments to filter EmailChangeTokens to count.
     * @example
     * // Count the number of EmailChangeTokens
     * const count = await prisma.emailChangeToken.count({
     *   where: {
     *     // ... the filter for the EmailChangeTokens we want to count
     *   }
     * })
    **/
    count<T extends EmailChangeTokenCountArgs>(
      args?: Subset<T, EmailChangeTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailChangeTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailChangeToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailChangeTokenAggregateArgs>(args: Subset<T, EmailChangeTokenAggregateArgs>): Prisma.PrismaPromise<GetEmailChangeTokenAggregateType<T>>

    /**
     * Group by EmailChangeToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailChangeTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailChangeTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailChangeTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailChangeTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailChangeTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailChangeToken model
   */
  readonly fields: EmailChangeTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailChangeToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailChangeTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailChangeToken model
   */
  interface EmailChangeTokenFieldRefs {
    readonly id: FieldRef<"EmailChangeToken", 'Int'>
    readonly token: FieldRef<"EmailChangeToken", 'String'>
    readonly newEmail: FieldRef<"EmailChangeToken", 'String'>
    readonly expiresAt: FieldRef<"EmailChangeToken", 'DateTime'>
    readonly createdAt: FieldRef<"EmailChangeToken", 'DateTime'>
    readonly userId: FieldRef<"EmailChangeToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmailChangeToken findUnique
   */
  export type EmailChangeTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeToken to fetch.
     */
    where: EmailChangeTokenWhereUniqueInput
  }

  /**
   * EmailChangeToken findUniqueOrThrow
   */
  export type EmailChangeTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeToken to fetch.
     */
    where: EmailChangeTokenWhereUniqueInput
  }

  /**
   * EmailChangeToken findFirst
   */
  export type EmailChangeTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeToken to fetch.
     */
    where?: EmailChangeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeTokens to fetch.
     */
    orderBy?: EmailChangeTokenOrderByWithRelationInput | EmailChangeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailChangeTokens.
     */
    cursor?: EmailChangeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChangeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailChangeTokens.
     */
    distinct?: EmailChangeTokenScalarFieldEnum | EmailChangeTokenScalarFieldEnum[]
  }

  /**
   * EmailChangeToken findFirstOrThrow
   */
  export type EmailChangeTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeToken to fetch.
     */
    where?: EmailChangeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeTokens to fetch.
     */
    orderBy?: EmailChangeTokenOrderByWithRelationInput | EmailChangeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailChangeTokens.
     */
    cursor?: EmailChangeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChangeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailChangeTokens.
     */
    distinct?: EmailChangeTokenScalarFieldEnum | EmailChangeTokenScalarFieldEnum[]
  }

  /**
   * EmailChangeToken findMany
   */
  export type EmailChangeTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeTokens to fetch.
     */
    where?: EmailChangeTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeTokens to fetch.
     */
    orderBy?: EmailChangeTokenOrderByWithRelationInput | EmailChangeTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailChangeTokens.
     */
    cursor?: EmailChangeTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailChangeTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeTokens.
     */
    skip?: number
    distinct?: EmailChangeTokenScalarFieldEnum | EmailChangeTokenScalarFieldEnum[]
  }

  /**
   * EmailChangeToken create
   */
  export type EmailChangeTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailChangeToken.
     */
    data: XOR<EmailChangeTokenCreateInput, EmailChangeTokenUncheckedCreateInput>
  }

  /**
   * EmailChangeToken createMany
   */
  export type EmailChangeTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailChangeTokens.
     */
    data: EmailChangeTokenCreateManyInput | EmailChangeTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailChangeToken update
   */
  export type EmailChangeTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailChangeToken.
     */
    data: XOR<EmailChangeTokenUpdateInput, EmailChangeTokenUncheckedUpdateInput>
    /**
     * Choose, which EmailChangeToken to update.
     */
    where: EmailChangeTokenWhereUniqueInput
  }

  /**
   * EmailChangeToken updateMany
   */
  export type EmailChangeTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailChangeTokens.
     */
    data: XOR<EmailChangeTokenUpdateManyMutationInput, EmailChangeTokenUncheckedUpdateManyInput>
    /**
     * Filter which EmailChangeTokens to update
     */
    where?: EmailChangeTokenWhereInput
    /**
     * Limit how many EmailChangeTokens to update.
     */
    limit?: number
  }

  /**
   * EmailChangeToken upsert
   */
  export type EmailChangeTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailChangeToken to update in case it exists.
     */
    where: EmailChangeTokenWhereUniqueInput
    /**
     * In case the EmailChangeToken found by the `where` argument doesn't exist, create a new EmailChangeToken with this data.
     */
    create: XOR<EmailChangeTokenCreateInput, EmailChangeTokenUncheckedCreateInput>
    /**
     * In case the EmailChangeToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailChangeTokenUpdateInput, EmailChangeTokenUncheckedUpdateInput>
  }

  /**
   * EmailChangeToken delete
   */
  export type EmailChangeTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
    /**
     * Filter which EmailChangeToken to delete.
     */
    where: EmailChangeTokenWhereUniqueInput
  }

  /**
   * EmailChangeToken deleteMany
   */
  export type EmailChangeTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailChangeTokens to delete
     */
    where?: EmailChangeTokenWhereInput
    /**
     * Limit how many EmailChangeTokens to delete.
     */
    limit?: number
  }

  /**
   * EmailChangeToken without action
   */
  export type EmailChangeTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeToken
     */
    select?: EmailChangeTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeToken
     */
    omit?: EmailChangeTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeTokenInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    id: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    userId: string | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    expiresAt: Date | null
    userId: string | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    expiresAt: number
    userId: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    id?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    id?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    expiresAt?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: number
    token: string
    expiresAt: Date
    userId: string
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>



  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    expiresAt?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "expiresAt" | "userId" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      expiresAt: Date
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'Int'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model GroupMessageReaction
   */

  export type AggregateGroupMessageReaction = {
    _count: GroupMessageReactionCountAggregateOutputType | null
    _avg: GroupMessageReactionAvgAggregateOutputType | null
    _sum: GroupMessageReactionSumAggregateOutputType | null
    _min: GroupMessageReactionMinAggregateOutputType | null
    _max: GroupMessageReactionMaxAggregateOutputType | null
  }

  export type GroupMessageReactionAvgAggregateOutputType = {
    id: number | null
    messageId: number | null
  }

  export type GroupMessageReactionSumAggregateOutputType = {
    id: number | null
    messageId: number | null
  }

  export type GroupMessageReactionMinAggregateOutputType = {
    id: number | null
    emoji: string | null
    createdAt: Date | null
    messageId: number | null
    userId: string | null
  }

  export type GroupMessageReactionMaxAggregateOutputType = {
    id: number | null
    emoji: string | null
    createdAt: Date | null
    messageId: number | null
    userId: string | null
  }

  export type GroupMessageReactionCountAggregateOutputType = {
    id: number
    emoji: number
    createdAt: number
    messageId: number
    userId: number
    _all: number
  }


  export type GroupMessageReactionAvgAggregateInputType = {
    id?: true
    messageId?: true
  }

  export type GroupMessageReactionSumAggregateInputType = {
    id?: true
    messageId?: true
  }

  export type GroupMessageReactionMinAggregateInputType = {
    id?: true
    emoji?: true
    createdAt?: true
    messageId?: true
    userId?: true
  }

  export type GroupMessageReactionMaxAggregateInputType = {
    id?: true
    emoji?: true
    createdAt?: true
    messageId?: true
    userId?: true
  }

  export type GroupMessageReactionCountAggregateInputType = {
    id?: true
    emoji?: true
    createdAt?: true
    messageId?: true
    userId?: true
    _all?: true
  }

  export type GroupMessageReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessageReaction to aggregate.
     */
    where?: GroupMessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessageReactions to fetch.
     */
    orderBy?: GroupMessageReactionOrderByWithRelationInput | GroupMessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupMessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupMessageReactions
    **/
    _count?: true | GroupMessageReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupMessageReactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupMessageReactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMessageReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMessageReactionMaxAggregateInputType
  }

  export type GetGroupMessageReactionAggregateType<T extends GroupMessageReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupMessageReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupMessageReaction[P]>
      : GetScalarType<T[P], AggregateGroupMessageReaction[P]>
  }




  export type GroupMessageReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupMessageReactionWhereInput
    orderBy?: GroupMessageReactionOrderByWithAggregationInput | GroupMessageReactionOrderByWithAggregationInput[]
    by: GroupMessageReactionScalarFieldEnum[] | GroupMessageReactionScalarFieldEnum
    having?: GroupMessageReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupMessageReactionCountAggregateInputType | true
    _avg?: GroupMessageReactionAvgAggregateInputType
    _sum?: GroupMessageReactionSumAggregateInputType
    _min?: GroupMessageReactionMinAggregateInputType
    _max?: GroupMessageReactionMaxAggregateInputType
  }

  export type GroupMessageReactionGroupByOutputType = {
    id: number
    emoji: string
    createdAt: Date
    messageId: number
    userId: string
    _count: GroupMessageReactionCountAggregateOutputType | null
    _avg: GroupMessageReactionAvgAggregateOutputType | null
    _sum: GroupMessageReactionSumAggregateOutputType | null
    _min: GroupMessageReactionMinAggregateOutputType | null
    _max: GroupMessageReactionMaxAggregateOutputType | null
  }

  type GetGroupMessageReactionGroupByPayload<T extends GroupMessageReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupMessageReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupMessageReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupMessageReactionGroupByOutputType[P]>
            : GetScalarType<T[P], GroupMessageReactionGroupByOutputType[P]>
        }
      >
    >


  export type GroupMessageReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emoji?: boolean
    createdAt?: boolean
    messageId?: boolean
    userId?: boolean
    message?: boolean | VenueGroupMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupMessageReaction"]>



  export type GroupMessageReactionSelectScalar = {
    id?: boolean
    emoji?: boolean
    createdAt?: boolean
    messageId?: boolean
    userId?: boolean
  }

  export type GroupMessageReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emoji" | "createdAt" | "messageId" | "userId", ExtArgs["result"]["groupMessageReaction"]>
  export type GroupMessageReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | VenueGroupMessageDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GroupMessageReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupMessageReaction"
    objects: {
      message: Prisma.$VenueGroupMessagePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      emoji: string
      createdAt: Date
      messageId: number
      userId: string
    }, ExtArgs["result"]["groupMessageReaction"]>
    composites: {}
  }

  type GroupMessageReactionGetPayload<S extends boolean | null | undefined | GroupMessageReactionDefaultArgs> = $Result.GetResult<Prisma.$GroupMessageReactionPayload, S>

  type GroupMessageReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupMessageReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupMessageReactionCountAggregateInputType | true
    }

  export interface GroupMessageReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupMessageReaction'], meta: { name: 'GroupMessageReaction' } }
    /**
     * Find zero or one GroupMessageReaction that matches the filter.
     * @param {GroupMessageReactionFindUniqueArgs} args - Arguments to find a GroupMessageReaction
     * @example
     * // Get one GroupMessageReaction
     * const groupMessageReaction = await prisma.groupMessageReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupMessageReactionFindUniqueArgs>(args: SelectSubset<T, GroupMessageReactionFindUniqueArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupMessageReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupMessageReactionFindUniqueOrThrowArgs} args - Arguments to find a GroupMessageReaction
     * @example
     * // Get one GroupMessageReaction
     * const groupMessageReaction = await prisma.groupMessageReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupMessageReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupMessageReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessageReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionFindFirstArgs} args - Arguments to find a GroupMessageReaction
     * @example
     * // Get one GroupMessageReaction
     * const groupMessageReaction = await prisma.groupMessageReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupMessageReactionFindFirstArgs>(args?: SelectSubset<T, GroupMessageReactionFindFirstArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupMessageReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionFindFirstOrThrowArgs} args - Arguments to find a GroupMessageReaction
     * @example
     * // Get one GroupMessageReaction
     * const groupMessageReaction = await prisma.groupMessageReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupMessageReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupMessageReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupMessageReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupMessageReactions
     * const groupMessageReactions = await prisma.groupMessageReaction.findMany()
     * 
     * // Get first 10 GroupMessageReactions
     * const groupMessageReactions = await prisma.groupMessageReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupMessageReactionWithIdOnly = await prisma.groupMessageReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupMessageReactionFindManyArgs>(args?: SelectSubset<T, GroupMessageReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupMessageReaction.
     * @param {GroupMessageReactionCreateArgs} args - Arguments to create a GroupMessageReaction.
     * @example
     * // Create one GroupMessageReaction
     * const GroupMessageReaction = await prisma.groupMessageReaction.create({
     *   data: {
     *     // ... data to create a GroupMessageReaction
     *   }
     * })
     * 
     */
    create<T extends GroupMessageReactionCreateArgs>(args: SelectSubset<T, GroupMessageReactionCreateArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupMessageReactions.
     * @param {GroupMessageReactionCreateManyArgs} args - Arguments to create many GroupMessageReactions.
     * @example
     * // Create many GroupMessageReactions
     * const groupMessageReaction = await prisma.groupMessageReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupMessageReactionCreateManyArgs>(args?: SelectSubset<T, GroupMessageReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupMessageReaction.
     * @param {GroupMessageReactionDeleteArgs} args - Arguments to delete one GroupMessageReaction.
     * @example
     * // Delete one GroupMessageReaction
     * const GroupMessageReaction = await prisma.groupMessageReaction.delete({
     *   where: {
     *     // ... filter to delete one GroupMessageReaction
     *   }
     * })
     * 
     */
    delete<T extends GroupMessageReactionDeleteArgs>(args: SelectSubset<T, GroupMessageReactionDeleteArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupMessageReaction.
     * @param {GroupMessageReactionUpdateArgs} args - Arguments to update one GroupMessageReaction.
     * @example
     * // Update one GroupMessageReaction
     * const groupMessageReaction = await prisma.groupMessageReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupMessageReactionUpdateArgs>(args: SelectSubset<T, GroupMessageReactionUpdateArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupMessageReactions.
     * @param {GroupMessageReactionDeleteManyArgs} args - Arguments to filter GroupMessageReactions to delete.
     * @example
     * // Delete a few GroupMessageReactions
     * const { count } = await prisma.groupMessageReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupMessageReactionDeleteManyArgs>(args?: SelectSubset<T, GroupMessageReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupMessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupMessageReactions
     * const groupMessageReaction = await prisma.groupMessageReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupMessageReactionUpdateManyArgs>(args: SelectSubset<T, GroupMessageReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupMessageReaction.
     * @param {GroupMessageReactionUpsertArgs} args - Arguments to update or create a GroupMessageReaction.
     * @example
     * // Update or create a GroupMessageReaction
     * const groupMessageReaction = await prisma.groupMessageReaction.upsert({
     *   create: {
     *     // ... data to create a GroupMessageReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupMessageReaction we want to update
     *   }
     * })
     */
    upsert<T extends GroupMessageReactionUpsertArgs>(args: SelectSubset<T, GroupMessageReactionUpsertArgs<ExtArgs>>): Prisma__GroupMessageReactionClient<$Result.GetResult<Prisma.$GroupMessageReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupMessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionCountArgs} args - Arguments to filter GroupMessageReactions to count.
     * @example
     * // Count the number of GroupMessageReactions
     * const count = await prisma.groupMessageReaction.count({
     *   where: {
     *     // ... the filter for the GroupMessageReactions we want to count
     *   }
     * })
    **/
    count<T extends GroupMessageReactionCountArgs>(
      args?: Subset<T, GroupMessageReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupMessageReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupMessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupMessageReactionAggregateArgs>(args: Subset<T, GroupMessageReactionAggregateArgs>): Prisma.PrismaPromise<GetGroupMessageReactionAggregateType<T>>

    /**
     * Group by GroupMessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupMessageReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupMessageReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupMessageReactionGroupByArgs['orderBy'] }
        : { orderBy?: GroupMessageReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupMessageReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupMessageReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupMessageReaction model
   */
  readonly fields: GroupMessageReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupMessageReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupMessageReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends VenueGroupMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueGroupMessageDefaultArgs<ExtArgs>>): Prisma__VenueGroupMessageClient<$Result.GetResult<Prisma.$VenueGroupMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupMessageReaction model
   */
  interface GroupMessageReactionFieldRefs {
    readonly id: FieldRef<"GroupMessageReaction", 'Int'>
    readonly emoji: FieldRef<"GroupMessageReaction", 'String'>
    readonly createdAt: FieldRef<"GroupMessageReaction", 'DateTime'>
    readonly messageId: FieldRef<"GroupMessageReaction", 'Int'>
    readonly userId: FieldRef<"GroupMessageReaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GroupMessageReaction findUnique
   */
  export type GroupMessageReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessageReaction to fetch.
     */
    where: GroupMessageReactionWhereUniqueInput
  }

  /**
   * GroupMessageReaction findUniqueOrThrow
   */
  export type GroupMessageReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessageReaction to fetch.
     */
    where: GroupMessageReactionWhereUniqueInput
  }

  /**
   * GroupMessageReaction findFirst
   */
  export type GroupMessageReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessageReaction to fetch.
     */
    where?: GroupMessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessageReactions to fetch.
     */
    orderBy?: GroupMessageReactionOrderByWithRelationInput | GroupMessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessageReactions.
     */
    cursor?: GroupMessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessageReactions.
     */
    distinct?: GroupMessageReactionScalarFieldEnum | GroupMessageReactionScalarFieldEnum[]
  }

  /**
   * GroupMessageReaction findFirstOrThrow
   */
  export type GroupMessageReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessageReaction to fetch.
     */
    where?: GroupMessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessageReactions to fetch.
     */
    orderBy?: GroupMessageReactionOrderByWithRelationInput | GroupMessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupMessageReactions.
     */
    cursor?: GroupMessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupMessageReactions.
     */
    distinct?: GroupMessageReactionScalarFieldEnum | GroupMessageReactionScalarFieldEnum[]
  }

  /**
   * GroupMessageReaction findMany
   */
  export type GroupMessageReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which GroupMessageReactions to fetch.
     */
    where?: GroupMessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupMessageReactions to fetch.
     */
    orderBy?: GroupMessageReactionOrderByWithRelationInput | GroupMessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupMessageReactions.
     */
    cursor?: GroupMessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupMessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupMessageReactions.
     */
    skip?: number
    distinct?: GroupMessageReactionScalarFieldEnum | GroupMessageReactionScalarFieldEnum[]
  }

  /**
   * GroupMessageReaction create
   */
  export type GroupMessageReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupMessageReaction.
     */
    data: XOR<GroupMessageReactionCreateInput, GroupMessageReactionUncheckedCreateInput>
  }

  /**
   * GroupMessageReaction createMany
   */
  export type GroupMessageReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupMessageReactions.
     */
    data: GroupMessageReactionCreateManyInput | GroupMessageReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupMessageReaction update
   */
  export type GroupMessageReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupMessageReaction.
     */
    data: XOR<GroupMessageReactionUpdateInput, GroupMessageReactionUncheckedUpdateInput>
    /**
     * Choose, which GroupMessageReaction to update.
     */
    where: GroupMessageReactionWhereUniqueInput
  }

  /**
   * GroupMessageReaction updateMany
   */
  export type GroupMessageReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupMessageReactions.
     */
    data: XOR<GroupMessageReactionUpdateManyMutationInput, GroupMessageReactionUncheckedUpdateManyInput>
    /**
     * Filter which GroupMessageReactions to update
     */
    where?: GroupMessageReactionWhereInput
    /**
     * Limit how many GroupMessageReactions to update.
     */
    limit?: number
  }

  /**
   * GroupMessageReaction upsert
   */
  export type GroupMessageReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupMessageReaction to update in case it exists.
     */
    where: GroupMessageReactionWhereUniqueInput
    /**
     * In case the GroupMessageReaction found by the `where` argument doesn't exist, create a new GroupMessageReaction with this data.
     */
    create: XOR<GroupMessageReactionCreateInput, GroupMessageReactionUncheckedCreateInput>
    /**
     * In case the GroupMessageReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupMessageReactionUpdateInput, GroupMessageReactionUncheckedUpdateInput>
  }

  /**
   * GroupMessageReaction delete
   */
  export type GroupMessageReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
    /**
     * Filter which GroupMessageReaction to delete.
     */
    where: GroupMessageReactionWhereUniqueInput
  }

  /**
   * GroupMessageReaction deleteMany
   */
  export type GroupMessageReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupMessageReactions to delete
     */
    where?: GroupMessageReactionWhereInput
    /**
     * Limit how many GroupMessageReactions to delete.
     */
    limit?: number
  }

  /**
   * GroupMessageReaction without action
   */
  export type GroupMessageReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupMessageReaction
     */
    select?: GroupMessageReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupMessageReaction
     */
    omit?: GroupMessageReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupMessageReactionInclude<ExtArgs> | null
  }


  /**
   * Model CheckInHistory
   */

  export type AggregateCheckInHistory = {
    _count: CheckInHistoryCountAggregateOutputType | null
    _avg: CheckInHistoryAvgAggregateOutputType | null
    _sum: CheckInHistorySumAggregateOutputType | null
    _min: CheckInHistoryMinAggregateOutputType | null
    _max: CheckInHistoryMaxAggregateOutputType | null
  }

  export type CheckInHistoryAvgAggregateOutputType = {
    id: number | null
    venueId: number | null
  }

  export type CheckInHistorySumAggregateOutputType = {
    id: number | null
    venueId: number | null
  }

  export type CheckInHistoryMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: string | null
    venueId: number | null
  }

  export type CheckInHistoryMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    userId: string | null
    venueId: number | null
  }

  export type CheckInHistoryCountAggregateOutputType = {
    id: number
    createdAt: number
    userId: number
    venueId: number
    _all: number
  }


  export type CheckInHistoryAvgAggregateInputType = {
    id?: true
    venueId?: true
  }

  export type CheckInHistorySumAggregateInputType = {
    id?: true
    venueId?: true
  }

  export type CheckInHistoryMinAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    venueId?: true
  }

  export type CheckInHistoryMaxAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    venueId?: true
  }

  export type CheckInHistoryCountAggregateInputType = {
    id?: true
    createdAt?: true
    userId?: true
    venueId?: true
    _all?: true
  }

  export type CheckInHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckInHistory to aggregate.
     */
    where?: CheckInHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckInHistories to fetch.
     */
    orderBy?: CheckInHistoryOrderByWithRelationInput | CheckInHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckInHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckInHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckInHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckInHistories
    **/
    _count?: true | CheckInHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckInHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckInHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckInHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckInHistoryMaxAggregateInputType
  }

  export type GetCheckInHistoryAggregateType<T extends CheckInHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckInHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckInHistory[P]>
      : GetScalarType<T[P], AggregateCheckInHistory[P]>
  }




  export type CheckInHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckInHistoryWhereInput
    orderBy?: CheckInHistoryOrderByWithAggregationInput | CheckInHistoryOrderByWithAggregationInput[]
    by: CheckInHistoryScalarFieldEnum[] | CheckInHistoryScalarFieldEnum
    having?: CheckInHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckInHistoryCountAggregateInputType | true
    _avg?: CheckInHistoryAvgAggregateInputType
    _sum?: CheckInHistorySumAggregateInputType
    _min?: CheckInHistoryMinAggregateInputType
    _max?: CheckInHistoryMaxAggregateInputType
  }

  export type CheckInHistoryGroupByOutputType = {
    id: number
    createdAt: Date
    userId: string
    venueId: number
    _count: CheckInHistoryCountAggregateOutputType | null
    _avg: CheckInHistoryAvgAggregateOutputType | null
    _sum: CheckInHistorySumAggregateOutputType | null
    _min: CheckInHistoryMinAggregateOutputType | null
    _max: CheckInHistoryMaxAggregateOutputType | null
  }

  type GetCheckInHistoryGroupByPayload<T extends CheckInHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckInHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckInHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckInHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CheckInHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CheckInHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    venueId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkInHistory"]>



  export type CheckInHistorySelectScalar = {
    id?: boolean
    createdAt?: boolean
    userId?: boolean
    venueId?: boolean
  }

  export type CheckInHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "userId" | "venueId", ExtArgs["result"]["checkInHistory"]>
  export type CheckInHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $CheckInHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckInHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      userId: string
      venueId: number
    }, ExtArgs["result"]["checkInHistory"]>
    composites: {}
  }

  type CheckInHistoryGetPayload<S extends boolean | null | undefined | CheckInHistoryDefaultArgs> = $Result.GetResult<Prisma.$CheckInHistoryPayload, S>

  type CheckInHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CheckInHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckInHistoryCountAggregateInputType | true
    }

  export interface CheckInHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckInHistory'], meta: { name: 'CheckInHistory' } }
    /**
     * Find zero or one CheckInHistory that matches the filter.
     * @param {CheckInHistoryFindUniqueArgs} args - Arguments to find a CheckInHistory
     * @example
     * // Get one CheckInHistory
     * const checkInHistory = await prisma.checkInHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckInHistoryFindUniqueArgs>(args: SelectSubset<T, CheckInHistoryFindUniqueArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CheckInHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CheckInHistoryFindUniqueOrThrowArgs} args - Arguments to find a CheckInHistory
     * @example
     * // Get one CheckInHistory
     * const checkInHistory = await prisma.checkInHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckInHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckInHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckInHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryFindFirstArgs} args - Arguments to find a CheckInHistory
     * @example
     * // Get one CheckInHistory
     * const checkInHistory = await prisma.checkInHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckInHistoryFindFirstArgs>(args?: SelectSubset<T, CheckInHistoryFindFirstArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CheckInHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryFindFirstOrThrowArgs} args - Arguments to find a CheckInHistory
     * @example
     * // Get one CheckInHistory
     * const checkInHistory = await prisma.checkInHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckInHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckInHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CheckInHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckInHistories
     * const checkInHistories = await prisma.checkInHistory.findMany()
     * 
     * // Get first 10 CheckInHistories
     * const checkInHistories = await prisma.checkInHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkInHistoryWithIdOnly = await prisma.checkInHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckInHistoryFindManyArgs>(args?: SelectSubset<T, CheckInHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CheckInHistory.
     * @param {CheckInHistoryCreateArgs} args - Arguments to create a CheckInHistory.
     * @example
     * // Create one CheckInHistory
     * const CheckInHistory = await prisma.checkInHistory.create({
     *   data: {
     *     // ... data to create a CheckInHistory
     *   }
     * })
     * 
     */
    create<T extends CheckInHistoryCreateArgs>(args: SelectSubset<T, CheckInHistoryCreateArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CheckInHistories.
     * @param {CheckInHistoryCreateManyArgs} args - Arguments to create many CheckInHistories.
     * @example
     * // Create many CheckInHistories
     * const checkInHistory = await prisma.checkInHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckInHistoryCreateManyArgs>(args?: SelectSubset<T, CheckInHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CheckInHistory.
     * @param {CheckInHistoryDeleteArgs} args - Arguments to delete one CheckInHistory.
     * @example
     * // Delete one CheckInHistory
     * const CheckInHistory = await prisma.checkInHistory.delete({
     *   where: {
     *     // ... filter to delete one CheckInHistory
     *   }
     * })
     * 
     */
    delete<T extends CheckInHistoryDeleteArgs>(args: SelectSubset<T, CheckInHistoryDeleteArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CheckInHistory.
     * @param {CheckInHistoryUpdateArgs} args - Arguments to update one CheckInHistory.
     * @example
     * // Update one CheckInHistory
     * const checkInHistory = await prisma.checkInHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckInHistoryUpdateArgs>(args: SelectSubset<T, CheckInHistoryUpdateArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CheckInHistories.
     * @param {CheckInHistoryDeleteManyArgs} args - Arguments to filter CheckInHistories to delete.
     * @example
     * // Delete a few CheckInHistories
     * const { count } = await prisma.checkInHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckInHistoryDeleteManyArgs>(args?: SelectSubset<T, CheckInHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckInHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckInHistories
     * const checkInHistory = await prisma.checkInHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckInHistoryUpdateManyArgs>(args: SelectSubset<T, CheckInHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckInHistory.
     * @param {CheckInHistoryUpsertArgs} args - Arguments to update or create a CheckInHistory.
     * @example
     * // Update or create a CheckInHistory
     * const checkInHistory = await prisma.checkInHistory.upsert({
     *   create: {
     *     // ... data to create a CheckInHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckInHistory we want to update
     *   }
     * })
     */
    upsert<T extends CheckInHistoryUpsertArgs>(args: SelectSubset<T, CheckInHistoryUpsertArgs<ExtArgs>>): Prisma__CheckInHistoryClient<$Result.GetResult<Prisma.$CheckInHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CheckInHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryCountArgs} args - Arguments to filter CheckInHistories to count.
     * @example
     * // Count the number of CheckInHistories
     * const count = await prisma.checkInHistory.count({
     *   where: {
     *     // ... the filter for the CheckInHistories we want to count
     *   }
     * })
    **/
    count<T extends CheckInHistoryCountArgs>(
      args?: Subset<T, CheckInHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckInHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckInHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckInHistoryAggregateArgs>(args: Subset<T, CheckInHistoryAggregateArgs>): Prisma.PrismaPromise<GetCheckInHistoryAggregateType<T>>

    /**
     * Group by CheckInHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckInHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckInHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckInHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CheckInHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckInHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckInHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckInHistory model
   */
  readonly fields: CheckInHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckInHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckInHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheckInHistory model
   */
  interface CheckInHistoryFieldRefs {
    readonly id: FieldRef<"CheckInHistory", 'Int'>
    readonly createdAt: FieldRef<"CheckInHistory", 'DateTime'>
    readonly userId: FieldRef<"CheckInHistory", 'String'>
    readonly venueId: FieldRef<"CheckInHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CheckInHistory findUnique
   */
  export type CheckInHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CheckInHistory to fetch.
     */
    where: CheckInHistoryWhereUniqueInput
  }

  /**
   * CheckInHistory findUniqueOrThrow
   */
  export type CheckInHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CheckInHistory to fetch.
     */
    where: CheckInHistoryWhereUniqueInput
  }

  /**
   * CheckInHistory findFirst
   */
  export type CheckInHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CheckInHistory to fetch.
     */
    where?: CheckInHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckInHistories to fetch.
     */
    orderBy?: CheckInHistoryOrderByWithRelationInput | CheckInHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckInHistories.
     */
    cursor?: CheckInHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckInHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckInHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckInHistories.
     */
    distinct?: CheckInHistoryScalarFieldEnum | CheckInHistoryScalarFieldEnum[]
  }

  /**
   * CheckInHistory findFirstOrThrow
   */
  export type CheckInHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CheckInHistory to fetch.
     */
    where?: CheckInHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckInHistories to fetch.
     */
    orderBy?: CheckInHistoryOrderByWithRelationInput | CheckInHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckInHistories.
     */
    cursor?: CheckInHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckInHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckInHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckInHistories.
     */
    distinct?: CheckInHistoryScalarFieldEnum | CheckInHistoryScalarFieldEnum[]
  }

  /**
   * CheckInHistory findMany
   */
  export type CheckInHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CheckInHistories to fetch.
     */
    where?: CheckInHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckInHistories to fetch.
     */
    orderBy?: CheckInHistoryOrderByWithRelationInput | CheckInHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckInHistories.
     */
    cursor?: CheckInHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckInHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckInHistories.
     */
    skip?: number
    distinct?: CheckInHistoryScalarFieldEnum | CheckInHistoryScalarFieldEnum[]
  }

  /**
   * CheckInHistory create
   */
  export type CheckInHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckInHistory.
     */
    data: XOR<CheckInHistoryCreateInput, CheckInHistoryUncheckedCreateInput>
  }

  /**
   * CheckInHistory createMany
   */
  export type CheckInHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckInHistories.
     */
    data: CheckInHistoryCreateManyInput | CheckInHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheckInHistory update
   */
  export type CheckInHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckInHistory.
     */
    data: XOR<CheckInHistoryUpdateInput, CheckInHistoryUncheckedUpdateInput>
    /**
     * Choose, which CheckInHistory to update.
     */
    where: CheckInHistoryWhereUniqueInput
  }

  /**
   * CheckInHistory updateMany
   */
  export type CheckInHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckInHistories.
     */
    data: XOR<CheckInHistoryUpdateManyMutationInput, CheckInHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CheckInHistories to update
     */
    where?: CheckInHistoryWhereInput
    /**
     * Limit how many CheckInHistories to update.
     */
    limit?: number
  }

  /**
   * CheckInHistory upsert
   */
  export type CheckInHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckInHistory to update in case it exists.
     */
    where: CheckInHistoryWhereUniqueInput
    /**
     * In case the CheckInHistory found by the `where` argument doesn't exist, create a new CheckInHistory with this data.
     */
    create: XOR<CheckInHistoryCreateInput, CheckInHistoryUncheckedCreateInput>
    /**
     * In case the CheckInHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckInHistoryUpdateInput, CheckInHistoryUncheckedUpdateInput>
  }

  /**
   * CheckInHistory delete
   */
  export type CheckInHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
    /**
     * Filter which CheckInHistory to delete.
     */
    where: CheckInHistoryWhereUniqueInput
  }

  /**
   * CheckInHistory deleteMany
   */
  export type CheckInHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckInHistories to delete
     */
    where?: CheckInHistoryWhereInput
    /**
     * Limit how many CheckInHistories to delete.
     */
    limit?: number
  }

  /**
   * CheckInHistory without action
   */
  export type CheckInHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckInHistory
     */
    select?: CheckInHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CheckInHistory
     */
    omit?: CheckInHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckInHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    id: number | null
    ruleId: number | null
    checkValue: number | null
  }

  export type BadgeSumAggregateOutputType = {
    id: number | null
    ruleId: number | null
    checkValue: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    ruleId: number | null
    checkValue: number | null
    createdAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    iconUrl: string | null
    ruleId: number | null
    checkValue: number | null
    createdAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    iconUrl: number
    ruleId: number
    checkValue: number
    createdAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    id?: true
    ruleId?: true
    checkValue?: true
  }

  export type BadgeSumAggregateInputType = {
    id?: true
    ruleId?: true
    checkValue?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    iconUrl?: true
    ruleId?: true
    checkValue?: true
    createdAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    iconUrl?: true
    ruleId?: true
    checkValue?: true
    createdAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    iconUrl?: true
    ruleId?: true
    checkValue?: true
    createdAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string
    iconUrl: string
    ruleId: number | null
    checkValue: number | null
    createdAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    ruleId?: boolean
    checkValue?: boolean
    createdAt?: boolean
    rule?: boolean | Badge$ruleArgs<ExtArgs>
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>



  export type BadgeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    ruleId?: boolean
    checkValue?: boolean
    createdAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "iconUrl" | "ruleId" | "checkValue" | "createdAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rule?: boolean | Badge$ruleArgs<ExtArgs>
    users?: boolean | Badge$usersArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      rule: Prisma.$BadgeRulePayload<ExtArgs> | null
      users: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string
      iconUrl: string
      ruleId: number | null
      checkValue: number | null
      createdAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rule<T extends Badge$ruleArgs<ExtArgs> = {}>(args?: Subset<T, Badge$ruleArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Badge$usersArgs<ExtArgs> = {}>(args?: Subset<T, Badge$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'Int'>
    readonly code: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly iconUrl: FieldRef<"Badge", 'String'>
    readonly ruleId: FieldRef<"Badge", 'Int'>
    readonly checkValue: FieldRef<"Badge", 'Int'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.rule
   */
  export type Badge$ruleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    where?: BadgeRuleWhereInput
  }

  /**
   * Badge.users
   */
  export type Badge$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeAvgAggregateOutputType = {
    badgeId: number | null
  }

  export type UserBadgeSumAggregateOutputType = {
    badgeId: number | null
  }

  export type UserBadgeMinAggregateOutputType = {
    userId: string | null
    badgeId: number | null
    createdAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    userId: string | null
    badgeId: number | null
    createdAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    userId: number
    badgeId: number
    createdAt: number
    _all: number
  }


  export type UserBadgeAvgAggregateInputType = {
    badgeId?: true
  }

  export type UserBadgeSumAggregateInputType = {
    badgeId?: true
  }

  export type UserBadgeMinAggregateInputType = {
    userId?: true
    badgeId?: true
    createdAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    userId?: true
    badgeId?: true
    createdAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    userId?: true
    badgeId?: true
    createdAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _avg?: UserBadgeAvgAggregateInputType
    _sum?: UserBadgeSumAggregateInputType
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    userId: string
    badgeId: number
    createdAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>



  export type UserBadgeSelectScalar = {
    userId?: boolean
    badgeId?: boolean
    createdAt?: boolean
  }

  export type UserBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "badgeId" | "createdAt", ExtArgs["result"]["userBadge"]>
  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      badgeId: number
      createdAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userBadgeWithUserIdOnly = await prisma.userBadge.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */
  interface UserBadgeFieldRefs {
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeId: FieldRef<"UserBadge", 'Int'>
    readonly createdAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to delete.
     */
    limit?: number
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model BadgeRule
   */

  export type AggregateBadgeRule = {
    _count: BadgeRuleCountAggregateOutputType | null
    _avg: BadgeRuleAvgAggregateOutputType | null
    _sum: BadgeRuleSumAggregateOutputType | null
    _min: BadgeRuleMinAggregateOutputType | null
    _max: BadgeRuleMaxAggregateOutputType | null
  }

  export type BadgeRuleAvgAggregateOutputType = {
    id: number | null
  }

  export type BadgeRuleSumAggregateOutputType = {
    id: number | null
  }

  export type BadgeRuleMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    triggerAction: string | null
  }

  export type BadgeRuleMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    description: string | null
    triggerAction: string | null
  }

  export type BadgeRuleCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    triggerAction: number
    _all: number
  }


  export type BadgeRuleAvgAggregateInputType = {
    id?: true
  }

  export type BadgeRuleSumAggregateInputType = {
    id?: true
  }

  export type BadgeRuleMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    triggerAction?: true
  }

  export type BadgeRuleMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    triggerAction?: true
  }

  export type BadgeRuleCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    triggerAction?: true
    _all?: true
  }

  export type BadgeRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeRule to aggregate.
     */
    where?: BadgeRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeRules to fetch.
     */
    orderBy?: BadgeRuleOrderByWithRelationInput | BadgeRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BadgeRules
    **/
    _count?: true | BadgeRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeRuleMaxAggregateInputType
  }

  export type GetBadgeRuleAggregateType<T extends BadgeRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateBadgeRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadgeRule[P]>
      : GetScalarType<T[P], AggregateBadgeRule[P]>
  }




  export type BadgeRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeRuleWhereInput
    orderBy?: BadgeRuleOrderByWithAggregationInput | BadgeRuleOrderByWithAggregationInput[]
    by: BadgeRuleScalarFieldEnum[] | BadgeRuleScalarFieldEnum
    having?: BadgeRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeRuleCountAggregateInputType | true
    _avg?: BadgeRuleAvgAggregateInputType
    _sum?: BadgeRuleSumAggregateInputType
    _min?: BadgeRuleMinAggregateInputType
    _max?: BadgeRuleMaxAggregateInputType
  }

  export type BadgeRuleGroupByOutputType = {
    id: number
    code: string
    name: string
    description: string
    triggerAction: string
    _count: BadgeRuleCountAggregateOutputType | null
    _avg: BadgeRuleAvgAggregateOutputType | null
    _sum: BadgeRuleSumAggregateOutputType | null
    _min: BadgeRuleMinAggregateOutputType | null
    _max: BadgeRuleMaxAggregateOutputType | null
  }

  type GetBadgeRuleGroupByPayload<T extends BadgeRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeRuleGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeRuleGroupByOutputType[P]>
        }
      >
    >


  export type BadgeRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    triggerAction?: boolean
    badges?: boolean | BadgeRule$badgesArgs<ExtArgs>
    _count?: boolean | BadgeRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badgeRule"]>



  export type BadgeRuleSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    triggerAction?: boolean
  }

  export type BadgeRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "triggerAction", ExtArgs["result"]["badgeRule"]>
  export type BadgeRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeRule$badgesArgs<ExtArgs>
    _count?: boolean | BadgeRuleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BadgeRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BadgeRule"
    objects: {
      badges: Prisma.$BadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      description: string
      triggerAction: string
    }, ExtArgs["result"]["badgeRule"]>
    composites: {}
  }

  type BadgeRuleGetPayload<S extends boolean | null | undefined | BadgeRuleDefaultArgs> = $Result.GetResult<Prisma.$BadgeRulePayload, S>

  type BadgeRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeRuleCountAggregateInputType | true
    }

  export interface BadgeRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BadgeRule'], meta: { name: 'BadgeRule' } }
    /**
     * Find zero or one BadgeRule that matches the filter.
     * @param {BadgeRuleFindUniqueArgs} args - Arguments to find a BadgeRule
     * @example
     * // Get one BadgeRule
     * const badgeRule = await prisma.badgeRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeRuleFindUniqueArgs>(args: SelectSubset<T, BadgeRuleFindUniqueArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BadgeRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeRuleFindUniqueOrThrowArgs} args - Arguments to find a BadgeRule
     * @example
     * // Get one BadgeRule
     * const badgeRule = await prisma.badgeRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleFindFirstArgs} args - Arguments to find a BadgeRule
     * @example
     * // Get one BadgeRule
     * const badgeRule = await prisma.badgeRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeRuleFindFirstArgs>(args?: SelectSubset<T, BadgeRuleFindFirstArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BadgeRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleFindFirstOrThrowArgs} args - Arguments to find a BadgeRule
     * @example
     * // Get one BadgeRule
     * const badgeRule = await prisma.badgeRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BadgeRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BadgeRules
     * const badgeRules = await prisma.badgeRule.findMany()
     * 
     * // Get first 10 BadgeRules
     * const badgeRules = await prisma.badgeRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeRuleWithIdOnly = await prisma.badgeRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeRuleFindManyArgs>(args?: SelectSubset<T, BadgeRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BadgeRule.
     * @param {BadgeRuleCreateArgs} args - Arguments to create a BadgeRule.
     * @example
     * // Create one BadgeRule
     * const BadgeRule = await prisma.badgeRule.create({
     *   data: {
     *     // ... data to create a BadgeRule
     *   }
     * })
     * 
     */
    create<T extends BadgeRuleCreateArgs>(args: SelectSubset<T, BadgeRuleCreateArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BadgeRules.
     * @param {BadgeRuleCreateManyArgs} args - Arguments to create many BadgeRules.
     * @example
     * // Create many BadgeRules
     * const badgeRule = await prisma.badgeRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeRuleCreateManyArgs>(args?: SelectSubset<T, BadgeRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BadgeRule.
     * @param {BadgeRuleDeleteArgs} args - Arguments to delete one BadgeRule.
     * @example
     * // Delete one BadgeRule
     * const BadgeRule = await prisma.badgeRule.delete({
     *   where: {
     *     // ... filter to delete one BadgeRule
     *   }
     * })
     * 
     */
    delete<T extends BadgeRuleDeleteArgs>(args: SelectSubset<T, BadgeRuleDeleteArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BadgeRule.
     * @param {BadgeRuleUpdateArgs} args - Arguments to update one BadgeRule.
     * @example
     * // Update one BadgeRule
     * const badgeRule = await prisma.badgeRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeRuleUpdateArgs>(args: SelectSubset<T, BadgeRuleUpdateArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BadgeRules.
     * @param {BadgeRuleDeleteManyArgs} args - Arguments to filter BadgeRules to delete.
     * @example
     * // Delete a few BadgeRules
     * const { count } = await prisma.badgeRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeRuleDeleteManyArgs>(args?: SelectSubset<T, BadgeRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BadgeRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BadgeRules
     * const badgeRule = await prisma.badgeRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeRuleUpdateManyArgs>(args: SelectSubset<T, BadgeRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BadgeRule.
     * @param {BadgeRuleUpsertArgs} args - Arguments to update or create a BadgeRule.
     * @example
     * // Update or create a BadgeRule
     * const badgeRule = await prisma.badgeRule.upsert({
     *   create: {
     *     // ... data to create a BadgeRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BadgeRule we want to update
     *   }
     * })
     */
    upsert<T extends BadgeRuleUpsertArgs>(args: SelectSubset<T, BadgeRuleUpsertArgs<ExtArgs>>): Prisma__BadgeRuleClient<$Result.GetResult<Prisma.$BadgeRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BadgeRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleCountArgs} args - Arguments to filter BadgeRules to count.
     * @example
     * // Count the number of BadgeRules
     * const count = await prisma.badgeRule.count({
     *   where: {
     *     // ... the filter for the BadgeRules we want to count
     *   }
     * })
    **/
    count<T extends BadgeRuleCountArgs>(
      args?: Subset<T, BadgeRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BadgeRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeRuleAggregateArgs>(args: Subset<T, BadgeRuleAggregateArgs>): Prisma.PrismaPromise<GetBadgeRuleAggregateType<T>>

    /**
     * Group by BadgeRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeRuleGroupByArgs['orderBy'] }
        : { orderBy?: BadgeRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BadgeRule model
   */
  readonly fields: BadgeRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BadgeRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends BadgeRule$badgesArgs<ExtArgs> = {}>(args?: Subset<T, BadgeRule$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BadgeRule model
   */
  interface BadgeRuleFieldRefs {
    readonly id: FieldRef<"BadgeRule", 'Int'>
    readonly code: FieldRef<"BadgeRule", 'String'>
    readonly name: FieldRef<"BadgeRule", 'String'>
    readonly description: FieldRef<"BadgeRule", 'String'>
    readonly triggerAction: FieldRef<"BadgeRule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BadgeRule findUnique
   */
  export type BadgeRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * Filter, which BadgeRule to fetch.
     */
    where: BadgeRuleWhereUniqueInput
  }

  /**
   * BadgeRule findUniqueOrThrow
   */
  export type BadgeRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * Filter, which BadgeRule to fetch.
     */
    where: BadgeRuleWhereUniqueInput
  }

  /**
   * BadgeRule findFirst
   */
  export type BadgeRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * Filter, which BadgeRule to fetch.
     */
    where?: BadgeRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeRules to fetch.
     */
    orderBy?: BadgeRuleOrderByWithRelationInput | BadgeRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeRules.
     */
    cursor?: BadgeRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeRules.
     */
    distinct?: BadgeRuleScalarFieldEnum | BadgeRuleScalarFieldEnum[]
  }

  /**
   * BadgeRule findFirstOrThrow
   */
  export type BadgeRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * Filter, which BadgeRule to fetch.
     */
    where?: BadgeRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeRules to fetch.
     */
    orderBy?: BadgeRuleOrderByWithRelationInput | BadgeRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BadgeRules.
     */
    cursor?: BadgeRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BadgeRules.
     */
    distinct?: BadgeRuleScalarFieldEnum | BadgeRuleScalarFieldEnum[]
  }

  /**
   * BadgeRule findMany
   */
  export type BadgeRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * Filter, which BadgeRules to fetch.
     */
    where?: BadgeRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BadgeRules to fetch.
     */
    orderBy?: BadgeRuleOrderByWithRelationInput | BadgeRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BadgeRules.
     */
    cursor?: BadgeRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BadgeRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BadgeRules.
     */
    skip?: number
    distinct?: BadgeRuleScalarFieldEnum | BadgeRuleScalarFieldEnum[]
  }

  /**
   * BadgeRule create
   */
  export type BadgeRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a BadgeRule.
     */
    data: XOR<BadgeRuleCreateInput, BadgeRuleUncheckedCreateInput>
  }

  /**
   * BadgeRule createMany
   */
  export type BadgeRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BadgeRules.
     */
    data: BadgeRuleCreateManyInput | BadgeRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BadgeRule update
   */
  export type BadgeRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a BadgeRule.
     */
    data: XOR<BadgeRuleUpdateInput, BadgeRuleUncheckedUpdateInput>
    /**
     * Choose, which BadgeRule to update.
     */
    where: BadgeRuleWhereUniqueInput
  }

  /**
   * BadgeRule updateMany
   */
  export type BadgeRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BadgeRules.
     */
    data: XOR<BadgeRuleUpdateManyMutationInput, BadgeRuleUncheckedUpdateManyInput>
    /**
     * Filter which BadgeRules to update
     */
    where?: BadgeRuleWhereInput
    /**
     * Limit how many BadgeRules to update.
     */
    limit?: number
  }

  /**
   * BadgeRule upsert
   */
  export type BadgeRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the BadgeRule to update in case it exists.
     */
    where: BadgeRuleWhereUniqueInput
    /**
     * In case the BadgeRule found by the `where` argument doesn't exist, create a new BadgeRule with this data.
     */
    create: XOR<BadgeRuleCreateInput, BadgeRuleUncheckedCreateInput>
    /**
     * In case the BadgeRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeRuleUpdateInput, BadgeRuleUncheckedUpdateInput>
  }

  /**
   * BadgeRule delete
   */
  export type BadgeRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
    /**
     * Filter which BadgeRule to delete.
     */
    where: BadgeRuleWhereUniqueInput
  }

  /**
   * BadgeRule deleteMany
   */
  export type BadgeRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BadgeRules to delete
     */
    where?: BadgeRuleWhereInput
    /**
     * Limit how many BadgeRules to delete.
     */
    limit?: number
  }

  /**
   * BadgeRule.badges
   */
  export type BadgeRule$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    cursor?: BadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * BadgeRule without action
   */
  export type BadgeRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeRule
     */
    select?: BadgeRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BadgeRule
     */
    omit?: BadgeRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeRuleInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeTemplate
   */

  export type AggregateChallengeTemplate = {
    _count: ChallengeTemplateCountAggregateOutputType | null
    _avg: ChallengeTemplateAvgAggregateOutputType | null
    _sum: ChallengeTemplateSumAggregateOutputType | null
    _min: ChallengeTemplateMinAggregateOutputType | null
    _max: ChallengeTemplateMaxAggregateOutputType | null
  }

  export type ChallengeTemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type ChallengeTemplateSumAggregateOutputType = {
    id: number | null
  }

  export type ChallengeTemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    iconUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ChallengeTemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    iconUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ChallengeTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    iconUrl: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ChallengeTemplateAvgAggregateInputType = {
    id?: true
  }

  export type ChallengeTemplateSumAggregateInputType = {
    id?: true
  }

  export type ChallengeTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconUrl?: true
    isActive?: true
    createdAt?: true
  }

  export type ChallengeTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconUrl?: true
    isActive?: true
    createdAt?: true
  }

  export type ChallengeTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    iconUrl?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ChallengeTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTemplate to aggregate.
     */
    where?: ChallengeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTemplates to fetch.
     */
    orderBy?: ChallengeTemplateOrderByWithRelationInput | ChallengeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeTemplates
    **/
    _count?: true | ChallengeTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeTemplateMaxAggregateInputType
  }

  export type GetChallengeTemplateAggregateType<T extends ChallengeTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeTemplate[P]>
      : GetScalarType<T[P], AggregateChallengeTemplate[P]>
  }




  export type ChallengeTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTemplateWhereInput
    orderBy?: ChallengeTemplateOrderByWithAggregationInput | ChallengeTemplateOrderByWithAggregationInput[]
    by: ChallengeTemplateScalarFieldEnum[] | ChallengeTemplateScalarFieldEnum
    having?: ChallengeTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeTemplateCountAggregateInputType | true
    _avg?: ChallengeTemplateAvgAggregateInputType
    _sum?: ChallengeTemplateSumAggregateInputType
    _min?: ChallengeTemplateMinAggregateInputType
    _max?: ChallengeTemplateMaxAggregateInputType
  }

  export type ChallengeTemplateGroupByOutputType = {
    id: number
    name: string
    description: string
    iconUrl: string | null
    isActive: boolean
    createdAt: Date
    _count: ChallengeTemplateCountAggregateOutputType | null
    _avg: ChallengeTemplateAvgAggregateOutputType | null
    _sum: ChallengeTemplateSumAggregateOutputType | null
    _min: ChallengeTemplateMinAggregateOutputType | null
    _max: ChallengeTemplateMaxAggregateOutputType | null
  }

  type GetChallengeTemplateGroupByPayload<T extends ChallengeTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    instances?: boolean | ChallengeTemplate$instancesArgs<ExtArgs>
    _count?: boolean | ChallengeTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTemplate"]>



  export type ChallengeTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    iconUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ChallengeTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "iconUrl" | "isActive" | "createdAt", ExtArgs["result"]["challengeTemplate"]>
  export type ChallengeTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instances?: boolean | ChallengeTemplate$instancesArgs<ExtArgs>
    _count?: boolean | ChallengeTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChallengeTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeTemplate"
    objects: {
      instances: Prisma.$ChallengeInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      iconUrl: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["challengeTemplate"]>
    composites: {}
  }

  type ChallengeTemplateGetPayload<S extends boolean | null | undefined | ChallengeTemplateDefaultArgs> = $Result.GetResult<Prisma.$ChallengeTemplatePayload, S>

  type ChallengeTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeTemplateCountAggregateInputType | true
    }

  export interface ChallengeTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeTemplate'], meta: { name: 'ChallengeTemplate' } }
    /**
     * Find zero or one ChallengeTemplate that matches the filter.
     * @param {ChallengeTemplateFindUniqueArgs} args - Arguments to find a ChallengeTemplate
     * @example
     * // Get one ChallengeTemplate
     * const challengeTemplate = await prisma.challengeTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeTemplateFindUniqueArgs>(args: SelectSubset<T, ChallengeTemplateFindUniqueArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeTemplateFindUniqueOrThrowArgs} args - Arguments to find a ChallengeTemplate
     * @example
     * // Get one ChallengeTemplate
     * const challengeTemplate = await prisma.challengeTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateFindFirstArgs} args - Arguments to find a ChallengeTemplate
     * @example
     * // Get one ChallengeTemplate
     * const challengeTemplate = await prisma.challengeTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeTemplateFindFirstArgs>(args?: SelectSubset<T, ChallengeTemplateFindFirstArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateFindFirstOrThrowArgs} args - Arguments to find a ChallengeTemplate
     * @example
     * // Get one ChallengeTemplate
     * const challengeTemplate = await prisma.challengeTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeTemplates
     * const challengeTemplates = await prisma.challengeTemplate.findMany()
     * 
     * // Get first 10 ChallengeTemplates
     * const challengeTemplates = await prisma.challengeTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeTemplateWithIdOnly = await prisma.challengeTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeTemplateFindManyArgs>(args?: SelectSubset<T, ChallengeTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeTemplate.
     * @param {ChallengeTemplateCreateArgs} args - Arguments to create a ChallengeTemplate.
     * @example
     * // Create one ChallengeTemplate
     * const ChallengeTemplate = await prisma.challengeTemplate.create({
     *   data: {
     *     // ... data to create a ChallengeTemplate
     *   }
     * })
     * 
     */
    create<T extends ChallengeTemplateCreateArgs>(args: SelectSubset<T, ChallengeTemplateCreateArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeTemplates.
     * @param {ChallengeTemplateCreateManyArgs} args - Arguments to create many ChallengeTemplates.
     * @example
     * // Create many ChallengeTemplates
     * const challengeTemplate = await prisma.challengeTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeTemplateCreateManyArgs>(args?: SelectSubset<T, ChallengeTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChallengeTemplate.
     * @param {ChallengeTemplateDeleteArgs} args - Arguments to delete one ChallengeTemplate.
     * @example
     * // Delete one ChallengeTemplate
     * const ChallengeTemplate = await prisma.challengeTemplate.delete({
     *   where: {
     *     // ... filter to delete one ChallengeTemplate
     *   }
     * })
     * 
     */
    delete<T extends ChallengeTemplateDeleteArgs>(args: SelectSubset<T, ChallengeTemplateDeleteArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeTemplate.
     * @param {ChallengeTemplateUpdateArgs} args - Arguments to update one ChallengeTemplate.
     * @example
     * // Update one ChallengeTemplate
     * const challengeTemplate = await prisma.challengeTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeTemplateUpdateArgs>(args: SelectSubset<T, ChallengeTemplateUpdateArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeTemplates.
     * @param {ChallengeTemplateDeleteManyArgs} args - Arguments to filter ChallengeTemplates to delete.
     * @example
     * // Delete a few ChallengeTemplates
     * const { count } = await prisma.challengeTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeTemplateDeleteManyArgs>(args?: SelectSubset<T, ChallengeTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeTemplates
     * const challengeTemplate = await prisma.challengeTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeTemplateUpdateManyArgs>(args: SelectSubset<T, ChallengeTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChallengeTemplate.
     * @param {ChallengeTemplateUpsertArgs} args - Arguments to update or create a ChallengeTemplate.
     * @example
     * // Update or create a ChallengeTemplate
     * const challengeTemplate = await prisma.challengeTemplate.upsert({
     *   create: {
     *     // ... data to create a ChallengeTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeTemplateUpsertArgs>(args: SelectSubset<T, ChallengeTemplateUpsertArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateCountArgs} args - Arguments to filter ChallengeTemplates to count.
     * @example
     * // Count the number of ChallengeTemplates
     * const count = await prisma.challengeTemplate.count({
     *   where: {
     *     // ... the filter for the ChallengeTemplates we want to count
     *   }
     * })
    **/
    count<T extends ChallengeTemplateCountArgs>(
      args?: Subset<T, ChallengeTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeTemplateAggregateArgs>(args: Subset<T, ChallengeTemplateAggregateArgs>): Prisma.PrismaPromise<GetChallengeTemplateAggregateType<T>>

    /**
     * Group by ChallengeTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeTemplate model
   */
  readonly fields: ChallengeTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instances<T extends ChallengeTemplate$instancesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTemplate$instancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeTemplate model
   */
  interface ChallengeTemplateFieldRefs {
    readonly id: FieldRef<"ChallengeTemplate", 'Int'>
    readonly name: FieldRef<"ChallengeTemplate", 'String'>
    readonly description: FieldRef<"ChallengeTemplate", 'String'>
    readonly iconUrl: FieldRef<"ChallengeTemplate", 'String'>
    readonly isActive: FieldRef<"ChallengeTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"ChallengeTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeTemplate findUnique
   */
  export type ChallengeTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTemplate to fetch.
     */
    where: ChallengeTemplateWhereUniqueInput
  }

  /**
   * ChallengeTemplate findUniqueOrThrow
   */
  export type ChallengeTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTemplate to fetch.
     */
    where: ChallengeTemplateWhereUniqueInput
  }

  /**
   * ChallengeTemplate findFirst
   */
  export type ChallengeTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTemplate to fetch.
     */
    where?: ChallengeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTemplates to fetch.
     */
    orderBy?: ChallengeTemplateOrderByWithRelationInput | ChallengeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTemplates.
     */
    cursor?: ChallengeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTemplates.
     */
    distinct?: ChallengeTemplateScalarFieldEnum | ChallengeTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTemplate findFirstOrThrow
   */
  export type ChallengeTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTemplate to fetch.
     */
    where?: ChallengeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTemplates to fetch.
     */
    orderBy?: ChallengeTemplateOrderByWithRelationInput | ChallengeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTemplates.
     */
    cursor?: ChallengeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTemplates.
     */
    distinct?: ChallengeTemplateScalarFieldEnum | ChallengeTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTemplate findMany
   */
  export type ChallengeTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTemplates to fetch.
     */
    where?: ChallengeTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTemplates to fetch.
     */
    orderBy?: ChallengeTemplateOrderByWithRelationInput | ChallengeTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeTemplates.
     */
    cursor?: ChallengeTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTemplates.
     */
    skip?: number
    distinct?: ChallengeTemplateScalarFieldEnum | ChallengeTemplateScalarFieldEnum[]
  }

  /**
   * ChallengeTemplate create
   */
  export type ChallengeTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeTemplate.
     */
    data: XOR<ChallengeTemplateCreateInput, ChallengeTemplateUncheckedCreateInput>
  }

  /**
   * ChallengeTemplate createMany
   */
  export type ChallengeTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeTemplates.
     */
    data: ChallengeTemplateCreateManyInput | ChallengeTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeTemplate update
   */
  export type ChallengeTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeTemplate.
     */
    data: XOR<ChallengeTemplateUpdateInput, ChallengeTemplateUncheckedUpdateInput>
    /**
     * Choose, which ChallengeTemplate to update.
     */
    where: ChallengeTemplateWhereUniqueInput
  }

  /**
   * ChallengeTemplate updateMany
   */
  export type ChallengeTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeTemplates.
     */
    data: XOR<ChallengeTemplateUpdateManyMutationInput, ChallengeTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTemplates to update
     */
    where?: ChallengeTemplateWhereInput
    /**
     * Limit how many ChallengeTemplates to update.
     */
    limit?: number
  }

  /**
   * ChallengeTemplate upsert
   */
  export type ChallengeTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeTemplate to update in case it exists.
     */
    where: ChallengeTemplateWhereUniqueInput
    /**
     * In case the ChallengeTemplate found by the `where` argument doesn't exist, create a new ChallengeTemplate with this data.
     */
    create: XOR<ChallengeTemplateCreateInput, ChallengeTemplateUncheckedCreateInput>
    /**
     * In case the ChallengeTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeTemplateUpdateInput, ChallengeTemplateUncheckedUpdateInput>
  }

  /**
   * ChallengeTemplate delete
   */
  export type ChallengeTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
    /**
     * Filter which ChallengeTemplate to delete.
     */
    where: ChallengeTemplateWhereUniqueInput
  }

  /**
   * ChallengeTemplate deleteMany
   */
  export type ChallengeTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTemplates to delete
     */
    where?: ChallengeTemplateWhereInput
    /**
     * Limit how many ChallengeTemplates to delete.
     */
    limit?: number
  }

  /**
   * ChallengeTemplate.instances
   */
  export type ChallengeTemplate$instancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    where?: ChallengeInstanceWhereInput
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    cursor?: ChallengeInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * ChallengeTemplate without action
   */
  export type ChallengeTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTemplate
     */
    select?: ChallengeTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeTemplate
     */
    omit?: ChallengeTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeInstance
   */

  export type AggregateChallengeInstance = {
    _count: ChallengeInstanceCountAggregateOutputType | null
    _avg: ChallengeInstanceAvgAggregateOutputType | null
    _sum: ChallengeInstanceSumAggregateOutputType | null
    _min: ChallengeInstanceMinAggregateOutputType | null
    _max: ChallengeInstanceMaxAggregateOutputType | null
  }

  export type ChallengeInstanceAvgAggregateOutputType = {
    id: number | null
    templateId: number | null
    connectionId: number | null
    venueId: number | null
  }

  export type ChallengeInstanceSumAggregateOutputType = {
    id: number | null
    templateId: number | null
    connectionId: number | null
    venueId: number | null
  }

  export type ChallengeInstanceMinAggregateOutputType = {
    id: number | null
    status: $Enums.ChallengeInstanceStatus | null
    challengeTime: Date | null
    templateId: number | null
    challengerId: string | null
    challengedId: string | null
    connectionId: number | null
    venueId: number | null
    challengerCheckedIn: boolean | null
    challengedCheckedIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeInstanceMaxAggregateOutputType = {
    id: number | null
    status: $Enums.ChallengeInstanceStatus | null
    challengeTime: Date | null
    templateId: number | null
    challengerId: string | null
    challengedId: string | null
    connectionId: number | null
    venueId: number | null
    challengerCheckedIn: boolean | null
    challengedCheckedIn: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeInstanceCountAggregateOutputType = {
    id: number
    status: number
    challengeTime: number
    templateId: number
    challengerId: number
    challengedId: number
    connectionId: number
    venueId: number
    challengerCheckedIn: number
    challengedCheckedIn: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengeInstanceAvgAggregateInputType = {
    id?: true
    templateId?: true
    connectionId?: true
    venueId?: true
  }

  export type ChallengeInstanceSumAggregateInputType = {
    id?: true
    templateId?: true
    connectionId?: true
    venueId?: true
  }

  export type ChallengeInstanceMinAggregateInputType = {
    id?: true
    status?: true
    challengeTime?: true
    templateId?: true
    challengerId?: true
    challengedId?: true
    connectionId?: true
    venueId?: true
    challengerCheckedIn?: true
    challengedCheckedIn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeInstanceMaxAggregateInputType = {
    id?: true
    status?: true
    challengeTime?: true
    templateId?: true
    challengerId?: true
    challengedId?: true
    connectionId?: true
    venueId?: true
    challengerCheckedIn?: true
    challengedCheckedIn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeInstanceCountAggregateInputType = {
    id?: true
    status?: true
    challengeTime?: true
    templateId?: true
    challengerId?: true
    challengedId?: true
    connectionId?: true
    venueId?: true
    challengerCheckedIn?: true
    challengedCheckedIn?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengeInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeInstance to aggregate.
     */
    where?: ChallengeInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstances to fetch.
     */
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeInstances
    **/
    _count?: true | ChallengeInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeInstanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeInstanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeInstanceMaxAggregateInputType
  }

  export type GetChallengeInstanceAggregateType<T extends ChallengeInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeInstance[P]>
      : GetScalarType<T[P], AggregateChallengeInstance[P]>
  }




  export type ChallengeInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeInstanceWhereInput
    orderBy?: ChallengeInstanceOrderByWithAggregationInput | ChallengeInstanceOrderByWithAggregationInput[]
    by: ChallengeInstanceScalarFieldEnum[] | ChallengeInstanceScalarFieldEnum
    having?: ChallengeInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeInstanceCountAggregateInputType | true
    _avg?: ChallengeInstanceAvgAggregateInputType
    _sum?: ChallengeInstanceSumAggregateInputType
    _min?: ChallengeInstanceMinAggregateInputType
    _max?: ChallengeInstanceMaxAggregateInputType
  }

  export type ChallengeInstanceGroupByOutputType = {
    id: number
    status: $Enums.ChallengeInstanceStatus
    challengeTime: Date
    templateId: number
    challengerId: string
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn: boolean
    challengedCheckedIn: boolean
    createdAt: Date
    updatedAt: Date
    _count: ChallengeInstanceCountAggregateOutputType | null
    _avg: ChallengeInstanceAvgAggregateOutputType | null
    _sum: ChallengeInstanceSumAggregateOutputType | null
    _min: ChallengeInstanceMinAggregateOutputType | null
    _max: ChallengeInstanceMaxAggregateOutputType | null
  }

  type GetChallengeInstanceGroupByPayload<T extends ChallengeInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeInstanceGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    challengeTime?: boolean
    templateId?: boolean
    challengerId?: boolean
    challengedId?: boolean
    connectionId?: boolean
    venueId?: boolean
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | ChallengeTemplateDefaultArgs<ExtArgs>
    challenger?: boolean | UserDefaultArgs<ExtArgs>
    challenged?: boolean | UserDefaultArgs<ExtArgs>
    connection?: boolean | ConnectionDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeInstance"]>



  export type ChallengeInstanceSelectScalar = {
    id?: boolean
    status?: boolean
    challengeTime?: boolean
    templateId?: boolean
    challengerId?: boolean
    challengedId?: boolean
    connectionId?: boolean
    venueId?: boolean
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChallengeInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "challengeTime" | "templateId" | "challengerId" | "challengedId" | "connectionId" | "venueId" | "challengerCheckedIn" | "challengedCheckedIn" | "createdAt" | "updatedAt", ExtArgs["result"]["challengeInstance"]>
  export type ChallengeInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | ChallengeTemplateDefaultArgs<ExtArgs>
    challenger?: boolean | UserDefaultArgs<ExtArgs>
    challenged?: boolean | UserDefaultArgs<ExtArgs>
    connection?: boolean | ConnectionDefaultArgs<ExtArgs>
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $ChallengeInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeInstance"
    objects: {
      template: Prisma.$ChallengeTemplatePayload<ExtArgs>
      challenger: Prisma.$UserPayload<ExtArgs>
      challenged: Prisma.$UserPayload<ExtArgs>
      connection: Prisma.$ConnectionPayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: $Enums.ChallengeInstanceStatus
      challengeTime: Date
      templateId: number
      challengerId: string
      challengedId: string
      connectionId: number
      venueId: number
      challengerCheckedIn: boolean
      challengedCheckedIn: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["challengeInstance"]>
    composites: {}
  }

  type ChallengeInstanceGetPayload<S extends boolean | null | undefined | ChallengeInstanceDefaultArgs> = $Result.GetResult<Prisma.$ChallengeInstancePayload, S>

  type ChallengeInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeInstanceCountAggregateInputType | true
    }

  export interface ChallengeInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeInstance'], meta: { name: 'ChallengeInstance' } }
    /**
     * Find zero or one ChallengeInstance that matches the filter.
     * @param {ChallengeInstanceFindUniqueArgs} args - Arguments to find a ChallengeInstance
     * @example
     * // Get one ChallengeInstance
     * const challengeInstance = await prisma.challengeInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeInstanceFindUniqueArgs>(args: SelectSubset<T, ChallengeInstanceFindUniqueArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChallengeInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeInstanceFindUniqueOrThrowArgs} args - Arguments to find a ChallengeInstance
     * @example
     * // Get one ChallengeInstance
     * const challengeInstance = await prisma.challengeInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceFindFirstArgs} args - Arguments to find a ChallengeInstance
     * @example
     * // Get one ChallengeInstance
     * const challengeInstance = await prisma.challengeInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeInstanceFindFirstArgs>(args?: SelectSubset<T, ChallengeInstanceFindFirstArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChallengeInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceFindFirstOrThrowArgs} args - Arguments to find a ChallengeInstance
     * @example
     * // Get one ChallengeInstance
     * const challengeInstance = await prisma.challengeInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChallengeInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeInstances
     * const challengeInstances = await prisma.challengeInstance.findMany()
     * 
     * // Get first 10 ChallengeInstances
     * const challengeInstances = await prisma.challengeInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeInstanceWithIdOnly = await prisma.challengeInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeInstanceFindManyArgs>(args?: SelectSubset<T, ChallengeInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChallengeInstance.
     * @param {ChallengeInstanceCreateArgs} args - Arguments to create a ChallengeInstance.
     * @example
     * // Create one ChallengeInstance
     * const ChallengeInstance = await prisma.challengeInstance.create({
     *   data: {
     *     // ... data to create a ChallengeInstance
     *   }
     * })
     * 
     */
    create<T extends ChallengeInstanceCreateArgs>(args: SelectSubset<T, ChallengeInstanceCreateArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChallengeInstances.
     * @param {ChallengeInstanceCreateManyArgs} args - Arguments to create many ChallengeInstances.
     * @example
     * // Create many ChallengeInstances
     * const challengeInstance = await prisma.challengeInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeInstanceCreateManyArgs>(args?: SelectSubset<T, ChallengeInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChallengeInstance.
     * @param {ChallengeInstanceDeleteArgs} args - Arguments to delete one ChallengeInstance.
     * @example
     * // Delete one ChallengeInstance
     * const ChallengeInstance = await prisma.challengeInstance.delete({
     *   where: {
     *     // ... filter to delete one ChallengeInstance
     *   }
     * })
     * 
     */
    delete<T extends ChallengeInstanceDeleteArgs>(args: SelectSubset<T, ChallengeInstanceDeleteArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChallengeInstance.
     * @param {ChallengeInstanceUpdateArgs} args - Arguments to update one ChallengeInstance.
     * @example
     * // Update one ChallengeInstance
     * const challengeInstance = await prisma.challengeInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeInstanceUpdateArgs>(args: SelectSubset<T, ChallengeInstanceUpdateArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChallengeInstances.
     * @param {ChallengeInstanceDeleteManyArgs} args - Arguments to filter ChallengeInstances to delete.
     * @example
     * // Delete a few ChallengeInstances
     * const { count } = await prisma.challengeInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeInstanceDeleteManyArgs>(args?: SelectSubset<T, ChallengeInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeInstances
     * const challengeInstance = await prisma.challengeInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeInstanceUpdateManyArgs>(args: SelectSubset<T, ChallengeInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChallengeInstance.
     * @param {ChallengeInstanceUpsertArgs} args - Arguments to update or create a ChallengeInstance.
     * @example
     * // Update or create a ChallengeInstance
     * const challengeInstance = await prisma.challengeInstance.upsert({
     *   create: {
     *     // ... data to create a ChallengeInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeInstance we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeInstanceUpsertArgs>(args: SelectSubset<T, ChallengeInstanceUpsertArgs<ExtArgs>>): Prisma__ChallengeInstanceClient<$Result.GetResult<Prisma.$ChallengeInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChallengeInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceCountArgs} args - Arguments to filter ChallengeInstances to count.
     * @example
     * // Count the number of ChallengeInstances
     * const count = await prisma.challengeInstance.count({
     *   where: {
     *     // ... the filter for the ChallengeInstances we want to count
     *   }
     * })
    **/
    count<T extends ChallengeInstanceCountArgs>(
      args?: Subset<T, ChallengeInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeInstanceAggregateArgs>(args: Subset<T, ChallengeInstanceAggregateArgs>): Prisma.PrismaPromise<GetChallengeInstanceAggregateType<T>>

    /**
     * Group by ChallengeInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeInstanceGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeInstance model
   */
  readonly fields: ChallengeInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends ChallengeTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTemplateDefaultArgs<ExtArgs>>): Prisma__ChallengeTemplateClient<$Result.GetResult<Prisma.$ChallengeTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenger<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    challenged<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    connection<T extends ConnectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConnectionDefaultArgs<ExtArgs>>): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeInstance model
   */
  interface ChallengeInstanceFieldRefs {
    readonly id: FieldRef<"ChallengeInstance", 'Int'>
    readonly status: FieldRef<"ChallengeInstance", 'ChallengeInstanceStatus'>
    readonly challengeTime: FieldRef<"ChallengeInstance", 'DateTime'>
    readonly templateId: FieldRef<"ChallengeInstance", 'Int'>
    readonly challengerId: FieldRef<"ChallengeInstance", 'String'>
    readonly challengedId: FieldRef<"ChallengeInstance", 'String'>
    readonly connectionId: FieldRef<"ChallengeInstance", 'Int'>
    readonly venueId: FieldRef<"ChallengeInstance", 'Int'>
    readonly challengerCheckedIn: FieldRef<"ChallengeInstance", 'Boolean'>
    readonly challengedCheckedIn: FieldRef<"ChallengeInstance", 'Boolean'>
    readonly createdAt: FieldRef<"ChallengeInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"ChallengeInstance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeInstance findUnique
   */
  export type ChallengeInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstance to fetch.
     */
    where: ChallengeInstanceWhereUniqueInput
  }

  /**
   * ChallengeInstance findUniqueOrThrow
   */
  export type ChallengeInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstance to fetch.
     */
    where: ChallengeInstanceWhereUniqueInput
  }

  /**
   * ChallengeInstance findFirst
   */
  export type ChallengeInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstance to fetch.
     */
    where?: ChallengeInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstances to fetch.
     */
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeInstances.
     */
    cursor?: ChallengeInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeInstances.
     */
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * ChallengeInstance findFirstOrThrow
   */
  export type ChallengeInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstance to fetch.
     */
    where?: ChallengeInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstances to fetch.
     */
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeInstances.
     */
    cursor?: ChallengeInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeInstances.
     */
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * ChallengeInstance findMany
   */
  export type ChallengeInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeInstances to fetch.
     */
    where?: ChallengeInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeInstances to fetch.
     */
    orderBy?: ChallengeInstanceOrderByWithRelationInput | ChallengeInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeInstances.
     */
    cursor?: ChallengeInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeInstances.
     */
    skip?: number
    distinct?: ChallengeInstanceScalarFieldEnum | ChallengeInstanceScalarFieldEnum[]
  }

  /**
   * ChallengeInstance create
   */
  export type ChallengeInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeInstance.
     */
    data: XOR<ChallengeInstanceCreateInput, ChallengeInstanceUncheckedCreateInput>
  }

  /**
   * ChallengeInstance createMany
   */
  export type ChallengeInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeInstances.
     */
    data: ChallengeInstanceCreateManyInput | ChallengeInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeInstance update
   */
  export type ChallengeInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeInstance.
     */
    data: XOR<ChallengeInstanceUpdateInput, ChallengeInstanceUncheckedUpdateInput>
    /**
     * Choose, which ChallengeInstance to update.
     */
    where: ChallengeInstanceWhereUniqueInput
  }

  /**
   * ChallengeInstance updateMany
   */
  export type ChallengeInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeInstances.
     */
    data: XOR<ChallengeInstanceUpdateManyMutationInput, ChallengeInstanceUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeInstances to update
     */
    where?: ChallengeInstanceWhereInput
    /**
     * Limit how many ChallengeInstances to update.
     */
    limit?: number
  }

  /**
   * ChallengeInstance upsert
   */
  export type ChallengeInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeInstance to update in case it exists.
     */
    where: ChallengeInstanceWhereUniqueInput
    /**
     * In case the ChallengeInstance found by the `where` argument doesn't exist, create a new ChallengeInstance with this data.
     */
    create: XOR<ChallengeInstanceCreateInput, ChallengeInstanceUncheckedCreateInput>
    /**
     * In case the ChallengeInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeInstanceUpdateInput, ChallengeInstanceUncheckedUpdateInput>
  }

  /**
   * ChallengeInstance delete
   */
  export type ChallengeInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
    /**
     * Filter which ChallengeInstance to delete.
     */
    where: ChallengeInstanceWhereUniqueInput
  }

  /**
   * ChallengeInstance deleteMany
   */
  export type ChallengeInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeInstances to delete
     */
    where?: ChallengeInstanceWhereInput
    /**
     * Limit how many ChallengeInstances to delete.
     */
    limit?: number
  }

  /**
   * ChallengeInstance without action
   */
  export type ChallengeInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeInstance
     */
    select?: ChallengeInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeInstance
     */
    omit?: ChallengeInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInstanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProfileOptionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    code: 'code',
    name: 'name'
  };

  export type ProfileOptionScalarFieldEnum = (typeof ProfileOptionScalarFieldEnum)[keyof typeof ProfileOptionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    authProvider: 'authProvider',
    googleId: 'googleId',
    appleId: 'appleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    roleId: 'roleId',
    isActive: 'isActive',
    subscription: 'subscription',
    subscriptionExpiresAt: 'subscriptionExpiresAt',
    premiumExpiresAt: 'premiumExpiresAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    age: 'age',
    gender: 'gender',
    bio: 'bio',
    university: 'university',
    city: 'city',
    personality: 'personality',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    extraSignalCredits: 'extraSignalCredits',
    hideViewFootprints: 'hideViewFootprints',
    preferredMinAge: 'preferredMinAge',
    preferredMaxAge: 'preferredMaxAge',
    notifyOnNewSignal: 'notifyOnNewSignal',
    notifyOnNewMatch: 'notifyOnNewMatch',
    notifyOnNewMessage: 'notifyOnNewMessage',
    isVerified: 'isVerified',
    verificationStatus: 'verificationStatus',
    verificationPhotoUrl: 'verificationPhotoUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    provisionalSignalsUsed: 'provisionalSignalsUsed',
    currentStatus: 'currentStatus',
    statusExpiresAt: 'statusExpiresAt',
    sexualOrientationId: 'sexualOrientationId',
    relationshipGoalId: 'relationshipGoalId'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const InterestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    categoryId: 'categoryId'
  };

  export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    description: 'description',
    latitude: 'latitude',
    longitude: 'longitude',
    isActive: 'isActive',
    isFeatured: 'isFeatured',
    category: 'category',
    statsSummary: 'statsSummary'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const ActiveSessionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    isIncognito: 'isIncognito',
    userId: 'userId',
    venueId: 'venueId'
  };

  export type ActiveSessionScalarFieldEnum = (typeof ActiveSessionScalarFieldEnum)[keyof typeof ActiveSessionScalarFieldEnum]


  export const SignalScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    senderId: 'senderId',
    receiverId: 'receiverId'
  };

  export type SignalScalarFieldEnum = (typeof SignalScalarFieldEnum)[keyof typeof SignalScalarFieldEnum]


  export const ConnectionScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userAId: 'userAId',
    userBId: 'userBId'
  };

  export type ConnectionScalarFieldEnum = (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    imageUrl: 'imageUrl',
    audioUrl: 'audioUrl',
    createdAt: 'createdAt',
    senderId: 'senderId',
    connectionId: 'connectionId',
    isRead: 'isRead'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    blockerId: 'blockerId',
    blockedId: 'blockedId'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId',
    reportedMessageId: 'reportedMessageId',
    reportedGroupMessageId: 'reportedGroupMessageId'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    description: 'description',
    screenshotUrl: 'screenshotUrl',
    createdAt: 'createdAt',
    authorId: 'authorId'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const BroadcastNotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body: 'body',
    createdAt: 'createdAt',
    sentById: 'sentById'
  };

  export type BroadcastNotificationScalarFieldEnum = (typeof BroadcastNotificationScalarFieldEnum)[keyof typeof BroadcastNotificationScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    url: 'url',
    isAvatar: 'isAvatar',
    createdAt: 'createdAt',
    profileId: 'profileId'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const IcebreakerQuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type IcebreakerQuestionScalarFieldEnum = (typeof IcebreakerQuestionScalarFieldEnum)[keyof typeof IcebreakerQuestionScalarFieldEnum]


  export const ProfileViewScalarFieldEnum: {
    id: 'id',
    viewerId: 'viewerId',
    viewedId: 'viewedId',
    createdAt: 'createdAt'
  };

  export type ProfileViewScalarFieldEnum = (typeof ProfileViewScalarFieldEnum)[keyof typeof ProfileViewScalarFieldEnum]


  export const VenueGroupMessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    imageUrl: 'imageUrl',
    audioUrl: 'audioUrl',
    videoUrl: 'videoUrl',
    createdAt: 'createdAt',
    venueId: 'venueId',
    senderId: 'senderId'
  };

  export type VenueGroupMessageScalarFieldEnum = (typeof VenueGroupMessageScalarFieldEnum)[keyof typeof VenueGroupMessageScalarFieldEnum]


  export const AccountDeletionTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type AccountDeletionTokenScalarFieldEnum = (typeof AccountDeletionTokenScalarFieldEnum)[keyof typeof AccountDeletionTokenScalarFieldEnum]


  export const EmailChangeTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    newEmail: 'newEmail',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type EmailChangeTokenScalarFieldEnum = (typeof EmailChangeTokenScalarFieldEnum)[keyof typeof EmailChangeTokenScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    expiresAt: 'expiresAt',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const GroupMessageReactionScalarFieldEnum: {
    id: 'id',
    emoji: 'emoji',
    createdAt: 'createdAt',
    messageId: 'messageId',
    userId: 'userId'
  };

  export type GroupMessageReactionScalarFieldEnum = (typeof GroupMessageReactionScalarFieldEnum)[keyof typeof GroupMessageReactionScalarFieldEnum]


  export const CheckInHistoryScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    userId: 'userId',
    venueId: 'venueId'
  };

  export type CheckInHistoryScalarFieldEnum = (typeof CheckInHistoryScalarFieldEnum)[keyof typeof CheckInHistoryScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl',
    ruleId: 'ruleId',
    checkValue: 'checkValue',
    createdAt: 'createdAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    userId: 'userId',
    badgeId: 'badgeId',
    createdAt: 'createdAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const BadgeRuleScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    triggerAction: 'triggerAction'
  };

  export type BadgeRuleScalarFieldEnum = (typeof BadgeRuleScalarFieldEnum)[keyof typeof BadgeRuleScalarFieldEnum]


  export const ChallengeTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ChallengeTemplateScalarFieldEnum = (typeof ChallengeTemplateScalarFieldEnum)[keyof typeof ChallengeTemplateScalarFieldEnum]


  export const ChallengeInstanceScalarFieldEnum: {
    id: 'id',
    status: 'status',
    challengeTime: 'challengeTime',
    templateId: 'templateId',
    challengerId: 'challengerId',
    challengedId: 'challengedId',
    connectionId: 'connectionId',
    venueId: 'venueId',
    challengerCheckedIn: 'challengerCheckedIn',
    challengedCheckedIn: 'challengedCheckedIn',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengeInstanceScalarFieldEnum = (typeof ChallengeInstanceScalarFieldEnum)[keyof typeof ChallengeInstanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const ProfileOptionOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name'
  };

  export type ProfileOptionOrderByRelevanceFieldEnum = (typeof ProfileOptionOrderByRelevanceFieldEnum)[keyof typeof ProfileOptionOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    googleId: 'googleId',
    appleId: 'appleId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const ProfileOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    gender: 'gender',
    bio: 'bio',
    university: 'university',
    city: 'city',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    verificationPhotoUrl: 'verificationPhotoUrl',
    currentStatus: 'currentStatus'
  };

  export type ProfileOrderByRelevanceFieldEnum = (typeof ProfileOrderByRelevanceFieldEnum)[keyof typeof ProfileOrderByRelevanceFieldEnum]


  export const CategoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type CategoryOrderByRelevanceFieldEnum = (typeof CategoryOrderByRelevanceFieldEnum)[keyof typeof CategoryOrderByRelevanceFieldEnum]


  export const InterestOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type InterestOrderByRelevanceFieldEnum = (typeof InterestOrderByRelevanceFieldEnum)[keyof typeof InterestOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const VenueOrderByRelevanceFieldEnum: {
    name: 'name',
    address: 'address',
    description: 'description'
  };

  export type VenueOrderByRelevanceFieldEnum = (typeof VenueOrderByRelevanceFieldEnum)[keyof typeof VenueOrderByRelevanceFieldEnum]


  export const ActiveSessionOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId'
  };

  export type ActiveSessionOrderByRelevanceFieldEnum = (typeof ActiveSessionOrderByRelevanceFieldEnum)[keyof typeof ActiveSessionOrderByRelevanceFieldEnum]


  export const SignalOrderByRelevanceFieldEnum: {
    senderId: 'senderId',
    receiverId: 'receiverId'
  };

  export type SignalOrderByRelevanceFieldEnum = (typeof SignalOrderByRelevanceFieldEnum)[keyof typeof SignalOrderByRelevanceFieldEnum]


  export const ConnectionOrderByRelevanceFieldEnum: {
    userAId: 'userAId',
    userBId: 'userBId'
  };

  export type ConnectionOrderByRelevanceFieldEnum = (typeof ConnectionOrderByRelevanceFieldEnum)[keyof typeof ConnectionOrderByRelevanceFieldEnum]


  export const MessageOrderByRelevanceFieldEnum: {
    content: 'content',
    imageUrl: 'imageUrl',
    audioUrl: 'audioUrl',
    senderId: 'senderId'
  };

  export type MessageOrderByRelevanceFieldEnum = (typeof MessageOrderByRelevanceFieldEnum)[keyof typeof MessageOrderByRelevanceFieldEnum]


  export const BlockOrderByRelevanceFieldEnum: {
    blockerId: 'blockerId',
    blockedId: 'blockedId'
  };

  export type BlockOrderByRelevanceFieldEnum = (typeof BlockOrderByRelevanceFieldEnum)[keyof typeof BlockOrderByRelevanceFieldEnum]


  export const ReportOrderByRelevanceFieldEnum: {
    reason: 'reason',
    reporterId: 'reporterId',
    reportedUserId: 'reportedUserId'
  };

  export type ReportOrderByRelevanceFieldEnum = (typeof ReportOrderByRelevanceFieldEnum)[keyof typeof ReportOrderByRelevanceFieldEnum]


  export const DeviceOrderByRelevanceFieldEnum: {
    token: 'token',
    userId: 'userId'
  };

  export type DeviceOrderByRelevanceFieldEnum = (typeof DeviceOrderByRelevanceFieldEnum)[keyof typeof DeviceOrderByRelevanceFieldEnum]


  export const NotificationOrderByRelevanceFieldEnum: {
    type: 'type',
    content: 'content',
    userId: 'userId'
  };

  export type NotificationOrderByRelevanceFieldEnum = (typeof NotificationOrderByRelevanceFieldEnum)[keyof typeof NotificationOrderByRelevanceFieldEnum]


  export const FeedbackOrderByRelevanceFieldEnum: {
    description: 'description',
    screenshotUrl: 'screenshotUrl',
    authorId: 'authorId'
  };

  export type FeedbackOrderByRelevanceFieldEnum = (typeof FeedbackOrderByRelevanceFieldEnum)[keyof typeof FeedbackOrderByRelevanceFieldEnum]


  export const RoleOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const AuditLogOrderByRelevanceFieldEnum: {
    actorId: 'actorId',
    action: 'action'
  };

  export type AuditLogOrderByRelevanceFieldEnum = (typeof AuditLogOrderByRelevanceFieldEnum)[keyof typeof AuditLogOrderByRelevanceFieldEnum]


  export const BroadcastNotificationOrderByRelevanceFieldEnum: {
    title: 'title',
    body: 'body',
    sentById: 'sentById'
  };

  export type BroadcastNotificationOrderByRelevanceFieldEnum = (typeof BroadcastNotificationOrderByRelevanceFieldEnum)[keyof typeof BroadcastNotificationOrderByRelevanceFieldEnum]


  export const PasswordResetTokenOrderByRelevanceFieldEnum: {
    token: 'token',
    userId: 'userId'
  };

  export type PasswordResetTokenOrderByRelevanceFieldEnum = (typeof PasswordResetTokenOrderByRelevanceFieldEnum)[keyof typeof PasswordResetTokenOrderByRelevanceFieldEnum]


  export const PhotoOrderByRelevanceFieldEnum: {
    url: 'url',
    profileId: 'profileId'
  };

  export type PhotoOrderByRelevanceFieldEnum = (typeof PhotoOrderByRelevanceFieldEnum)[keyof typeof PhotoOrderByRelevanceFieldEnum]


  export const IcebreakerQuestionOrderByRelevanceFieldEnum: {
    text: 'text'
  };

  export type IcebreakerQuestionOrderByRelevanceFieldEnum = (typeof IcebreakerQuestionOrderByRelevanceFieldEnum)[keyof typeof IcebreakerQuestionOrderByRelevanceFieldEnum]


  export const ProfileViewOrderByRelevanceFieldEnum: {
    viewerId: 'viewerId',
    viewedId: 'viewedId'
  };

  export type ProfileViewOrderByRelevanceFieldEnum = (typeof ProfileViewOrderByRelevanceFieldEnum)[keyof typeof ProfileViewOrderByRelevanceFieldEnum]


  export const VenueGroupMessageOrderByRelevanceFieldEnum: {
    content: 'content',
    imageUrl: 'imageUrl',
    audioUrl: 'audioUrl',
    videoUrl: 'videoUrl',
    senderId: 'senderId'
  };

  export type VenueGroupMessageOrderByRelevanceFieldEnum = (typeof VenueGroupMessageOrderByRelevanceFieldEnum)[keyof typeof VenueGroupMessageOrderByRelevanceFieldEnum]


  export const AccountDeletionTokenOrderByRelevanceFieldEnum: {
    token: 'token',
    userId: 'userId'
  };

  export type AccountDeletionTokenOrderByRelevanceFieldEnum = (typeof AccountDeletionTokenOrderByRelevanceFieldEnum)[keyof typeof AccountDeletionTokenOrderByRelevanceFieldEnum]


  export const EmailChangeTokenOrderByRelevanceFieldEnum: {
    token: 'token',
    newEmail: 'newEmail',
    userId: 'userId'
  };

  export type EmailChangeTokenOrderByRelevanceFieldEnum = (typeof EmailChangeTokenOrderByRelevanceFieldEnum)[keyof typeof EmailChangeTokenOrderByRelevanceFieldEnum]


  export const RefreshTokenOrderByRelevanceFieldEnum: {
    token: 'token',
    userId: 'userId'
  };

  export type RefreshTokenOrderByRelevanceFieldEnum = (typeof RefreshTokenOrderByRelevanceFieldEnum)[keyof typeof RefreshTokenOrderByRelevanceFieldEnum]


  export const GroupMessageReactionOrderByRelevanceFieldEnum: {
    emoji: 'emoji',
    userId: 'userId'
  };

  export type GroupMessageReactionOrderByRelevanceFieldEnum = (typeof GroupMessageReactionOrderByRelevanceFieldEnum)[keyof typeof GroupMessageReactionOrderByRelevanceFieldEnum]


  export const CheckInHistoryOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type CheckInHistoryOrderByRelevanceFieldEnum = (typeof CheckInHistoryOrderByRelevanceFieldEnum)[keyof typeof CheckInHistoryOrderByRelevanceFieldEnum]


  export const BadgeOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl'
  };

  export type BadgeOrderByRelevanceFieldEnum = (typeof BadgeOrderByRelevanceFieldEnum)[keyof typeof BadgeOrderByRelevanceFieldEnum]


  export const UserBadgeOrderByRelevanceFieldEnum: {
    userId: 'userId'
  };

  export type UserBadgeOrderByRelevanceFieldEnum = (typeof UserBadgeOrderByRelevanceFieldEnum)[keyof typeof UserBadgeOrderByRelevanceFieldEnum]


  export const BadgeRuleOrderByRelevanceFieldEnum: {
    code: 'code',
    name: 'name',
    description: 'description',
    triggerAction: 'triggerAction'
  };

  export type BadgeRuleOrderByRelevanceFieldEnum = (typeof BadgeRuleOrderByRelevanceFieldEnum)[keyof typeof BadgeRuleOrderByRelevanceFieldEnum]


  export const ChallengeTemplateOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description',
    iconUrl: 'iconUrl'
  };

  export type ChallengeTemplateOrderByRelevanceFieldEnum = (typeof ChallengeTemplateOrderByRelevanceFieldEnum)[keyof typeof ChallengeTemplateOrderByRelevanceFieldEnum]


  export const ChallengeInstanceOrderByRelevanceFieldEnum: {
    challengerId: 'challengerId',
    challengedId: 'challengedId'
  };

  export type ChallengeInstanceOrderByRelevanceFieldEnum = (typeof ChallengeInstanceOrderByRelevanceFieldEnum)[keyof typeof ChallengeInstanceOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'OptionType'
   */
  export type EnumOptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OptionType'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SubscriptionPlan'
   */
  export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


  /**
   * Reference to a field of type 'PersonalityType'
   */
  export type EnumPersonalityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonalityType'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'VenueCategory'
   */
  export type EnumVenueCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VenueCategory'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'IcebreakerCategory'
   */
  export type EnumIcebreakerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IcebreakerCategory'>
    


  /**
   * Reference to a field of type 'ChallengeInstanceStatus'
   */
  export type EnumChallengeInstanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeInstanceStatus'>
    
  /**
   * Deep Input Types
   */


  export type ProfileOptionWhereInput = {
    AND?: ProfileOptionWhereInput | ProfileOptionWhereInput[]
    OR?: ProfileOptionWhereInput[]
    NOT?: ProfileOptionWhereInput | ProfileOptionWhereInput[]
    id?: IntFilter<"ProfileOption"> | number
    type?: EnumOptionTypeFilter<"ProfileOption"> | $Enums.OptionType
    code?: StringFilter<"ProfileOption"> | string
    name?: StringFilter<"ProfileOption"> | string
    profilesByOrientation?: ProfileListRelationFilter
    profilesByGoal?: ProfileListRelationFilter
  }

  export type ProfileOptionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    profilesByOrientation?: ProfileOrderByRelationAggregateInput
    profilesByGoal?: ProfileOrderByRelationAggregateInput
    _relevance?: ProfileOptionOrderByRelevanceInput
  }

  export type ProfileOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: ProfileOptionWhereInput | ProfileOptionWhereInput[]
    OR?: ProfileOptionWhereInput[]
    NOT?: ProfileOptionWhereInput | ProfileOptionWhereInput[]
    type?: EnumOptionTypeFilter<"ProfileOption"> | $Enums.OptionType
    name?: StringFilter<"ProfileOption"> | string
    profilesByOrientation?: ProfileListRelationFilter
    profilesByGoal?: ProfileListRelationFilter
  }, "id" | "code">

  export type ProfileOptionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: ProfileOptionCountOrderByAggregateInput
    _avg?: ProfileOptionAvgOrderByAggregateInput
    _max?: ProfileOptionMaxOrderByAggregateInput
    _min?: ProfileOptionMinOrderByAggregateInput
    _sum?: ProfileOptionSumOrderByAggregateInput
  }

  export type ProfileOptionScalarWhereWithAggregatesInput = {
    AND?: ProfileOptionScalarWhereWithAggregatesInput | ProfileOptionScalarWhereWithAggregatesInput[]
    OR?: ProfileOptionScalarWhereWithAggregatesInput[]
    NOT?: ProfileOptionScalarWhereWithAggregatesInput | ProfileOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfileOption"> | number
    type?: EnumOptionTypeWithAggregatesFilter<"ProfileOption"> | $Enums.OptionType
    code?: StringWithAggregatesFilter<"ProfileOption"> | string
    name?: StringWithAggregatesFilter<"ProfileOption"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    googleId?: StringNullableFilter<"User"> | string | null
    appleId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    subscription?: EnumSubscriptionPlanFilter<"User"> | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    premiumExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    activeSession?: XOR<ActiveSessionNullableScalarRelationFilter, ActiveSessionWhereInput> | null
    sentSignals?: SignalListRelationFilter
    receivedSignals?: SignalListRelationFilter
    connectionsA?: ConnectionListRelationFilter
    connectionsB?: ConnectionListRelationFilter
    messages?: MessageListRelationFilter
    blockedBy?: BlockListRelationFilter
    blocking?: BlockListRelationFilter
    reportsMade?: ReportListRelationFilter
    reportsReceived?: ReportListRelationFilter
    devices?: DeviceListRelationFilter
    notifications?: NotificationListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    auditLogs?: AuditLogListRelationFilter
    sentBroadcasts?: BroadcastNotificationListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    viewsMade?: ProfileViewListRelationFilter
    viewsReceived?: ProfileViewListRelationFilter
    venueGroupMessages?: VenueGroupMessageListRelationFilter
    accountDeletionToken?: XOR<AccountDeletionTokenNullableScalarRelationFilter, AccountDeletionTokenWhereInput> | null
    emailChangeToken?: XOR<EmailChangeTokenNullableScalarRelationFilter, EmailChangeTokenWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    groupMessageReactions?: GroupMessageReactionListRelationFilter
    checkInHistory?: CheckInHistoryListRelationFilter
    badges?: UserBadgeListRelationFilter
    sentChallenges?: ChallengeInstanceListRelationFilter
    receivedChallenges?: ChallengeInstanceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    authProvider?: SortOrder
    googleId?: SortOrderInput | SortOrder
    appleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    subscription?: SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    premiumExpiresAt?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    activeSession?: ActiveSessionOrderByWithRelationInput
    sentSignals?: SignalOrderByRelationAggregateInput
    receivedSignals?: SignalOrderByRelationAggregateInput
    connectionsA?: ConnectionOrderByRelationAggregateInput
    connectionsB?: ConnectionOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    blockedBy?: BlockOrderByRelationAggregateInput
    blocking?: BlockOrderByRelationAggregateInput
    reportsMade?: ReportOrderByRelationAggregateInput
    reportsReceived?: ReportOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    feedbacks?: FeedbackOrderByRelationAggregateInput
    role?: RoleOrderByWithRelationInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    sentBroadcasts?: BroadcastNotificationOrderByRelationAggregateInput
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    viewsMade?: ProfileViewOrderByRelationAggregateInput
    viewsReceived?: ProfileViewOrderByRelationAggregateInput
    venueGroupMessages?: VenueGroupMessageOrderByRelationAggregateInput
    accountDeletionToken?: AccountDeletionTokenOrderByWithRelationInput
    emailChangeToken?: EmailChangeTokenOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    groupMessageReactions?: GroupMessageReactionOrderByRelationAggregateInput
    checkInHistory?: CheckInHistoryOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    sentChallenges?: ChallengeInstanceOrderByRelationAggregateInput
    receivedChallenges?: ChallengeInstanceOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    googleId?: string
    appleId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    subscription?: EnumSubscriptionPlanFilter<"User"> | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    premiumExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    activeSession?: XOR<ActiveSessionNullableScalarRelationFilter, ActiveSessionWhereInput> | null
    sentSignals?: SignalListRelationFilter
    receivedSignals?: SignalListRelationFilter
    connectionsA?: ConnectionListRelationFilter
    connectionsB?: ConnectionListRelationFilter
    messages?: MessageListRelationFilter
    blockedBy?: BlockListRelationFilter
    blocking?: BlockListRelationFilter
    reportsMade?: ReportListRelationFilter
    reportsReceived?: ReportListRelationFilter
    devices?: DeviceListRelationFilter
    notifications?: NotificationListRelationFilter
    feedbacks?: FeedbackListRelationFilter
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    auditLogs?: AuditLogListRelationFilter
    sentBroadcasts?: BroadcastNotificationListRelationFilter
    passwordResetTokens?: PasswordResetTokenListRelationFilter
    viewsMade?: ProfileViewListRelationFilter
    viewsReceived?: ProfileViewListRelationFilter
    venueGroupMessages?: VenueGroupMessageListRelationFilter
    accountDeletionToken?: XOR<AccountDeletionTokenNullableScalarRelationFilter, AccountDeletionTokenWhereInput> | null
    emailChangeToken?: XOR<EmailChangeTokenNullableScalarRelationFilter, EmailChangeTokenWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    groupMessageReactions?: GroupMessageReactionListRelationFilter
    checkInHistory?: CheckInHistoryListRelationFilter
    badges?: UserBadgeListRelationFilter
    sentChallenges?: ChallengeInstanceListRelationFilter
    receivedChallenges?: ChallengeInstanceListRelationFilter
  }, "id" | "email" | "googleId" | "appleId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    authProvider?: SortOrder
    googleId?: SortOrderInput | SortOrder
    appleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    subscription?: SortOrder
    subscriptionExpiresAt?: SortOrderInput | SortOrder
    premiumExpiresAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    authProvider?: EnumAuthProviderWithAggregatesFilter<"User"> | $Enums.AuthProvider
    googleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    appleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    roleId?: IntWithAggregatesFilter<"User"> | number
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    subscription?: EnumSubscriptionPlanWithAggregatesFilter<"User"> | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    premiumExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    age?: IntFilter<"Profile"> | number
    gender?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    university?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    personality?: EnumPersonalityTypeNullableFilter<"Profile"> | $Enums.PersonalityType | null
    userId?: StringFilter<"Profile"> | string
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    extraSignalCredits?: IntFilter<"Profile"> | number
    hideViewFootprints?: BoolFilter<"Profile"> | boolean
    preferredMinAge?: IntNullableFilter<"Profile"> | number | null
    preferredMaxAge?: IntNullableFilter<"Profile"> | number | null
    notifyOnNewSignal?: BoolFilter<"Profile"> | boolean
    notifyOnNewMatch?: BoolFilter<"Profile"> | boolean
    notifyOnNewMessage?: BoolFilter<"Profile"> | boolean
    isVerified?: BoolFilter<"Profile"> | boolean
    verificationStatus?: EnumVerificationStatusFilter<"Profile"> | $Enums.VerificationStatus
    verificationPhotoUrl?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    provisionalSignalsUsed?: IntFilter<"Profile"> | number
    currentStatus?: StringNullableFilter<"Profile"> | string | null
    statusExpiresAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    sexualOrientationId?: IntNullableFilter<"Profile"> | number | null
    relationshipGoalId?: IntNullableFilter<"Profile"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interests?: InterestListRelationFilter
    photos?: PhotoListRelationFilter
    sexualOrientation?: XOR<ProfileOptionNullableScalarRelationFilter, ProfileOptionWhereInput> | null
    relationshipGoal?: XOR<ProfileOptionNullableScalarRelationFilter, ProfileOptionWhereInput> | null
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    bio?: SortOrderInput | SortOrder
    university?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    extraSignalCredits?: SortOrder
    hideViewFootprints?: SortOrder
    preferredMinAge?: SortOrderInput | SortOrder
    preferredMaxAge?: SortOrderInput | SortOrder
    notifyOnNewSignal?: SortOrder
    notifyOnNewMatch?: SortOrder
    notifyOnNewMessage?: SortOrder
    isVerified?: SortOrder
    verificationStatus?: SortOrder
    verificationPhotoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    provisionalSignalsUsed?: SortOrder
    currentStatus?: SortOrderInput | SortOrder
    statusExpiresAt?: SortOrderInput | SortOrder
    sexualOrientationId?: SortOrderInput | SortOrder
    relationshipGoalId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    interests?: InterestOrderByRelationAggregateInput
    photos?: PhotoOrderByRelationAggregateInput
    sexualOrientation?: ProfileOptionOrderByWithRelationInput
    relationshipGoal?: ProfileOptionOrderByWithRelationInput
    _relevance?: ProfileOrderByRelevanceInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    phoneNumber?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    name?: StringFilter<"Profile"> | string
    age?: IntFilter<"Profile"> | number
    gender?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    university?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    personality?: EnumPersonalityTypeNullableFilter<"Profile"> | $Enums.PersonalityType | null
    extraSignalCredits?: IntFilter<"Profile"> | number
    hideViewFootprints?: BoolFilter<"Profile"> | boolean
    preferredMinAge?: IntNullableFilter<"Profile"> | number | null
    preferredMaxAge?: IntNullableFilter<"Profile"> | number | null
    notifyOnNewSignal?: BoolFilter<"Profile"> | boolean
    notifyOnNewMatch?: BoolFilter<"Profile"> | boolean
    notifyOnNewMessage?: BoolFilter<"Profile"> | boolean
    isVerified?: BoolFilter<"Profile"> | boolean
    verificationStatus?: EnumVerificationStatusFilter<"Profile"> | $Enums.VerificationStatus
    verificationPhotoUrl?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    provisionalSignalsUsed?: IntFilter<"Profile"> | number
    currentStatus?: StringNullableFilter<"Profile"> | string | null
    statusExpiresAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    sexualOrientationId?: IntNullableFilter<"Profile"> | number | null
    relationshipGoalId?: IntNullableFilter<"Profile"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    interests?: InterestListRelationFilter
    photos?: PhotoListRelationFilter
    sexualOrientation?: XOR<ProfileOptionNullableScalarRelationFilter, ProfileOptionWhereInput> | null
    relationshipGoal?: XOR<ProfileOptionNullableScalarRelationFilter, ProfileOptionWhereInput> | null
  }, "id" | "userId" | "phoneNumber">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    bio?: SortOrderInput | SortOrder
    university?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    personality?: SortOrderInput | SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    extraSignalCredits?: SortOrder
    hideViewFootprints?: SortOrder
    preferredMinAge?: SortOrderInput | SortOrder
    preferredMaxAge?: SortOrderInput | SortOrder
    notifyOnNewSignal?: SortOrder
    notifyOnNewMatch?: SortOrder
    notifyOnNewMessage?: SortOrder
    isVerified?: SortOrder
    verificationStatus?: SortOrder
    verificationPhotoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    provisionalSignalsUsed?: SortOrder
    currentStatus?: SortOrderInput | SortOrder
    statusExpiresAt?: SortOrderInput | SortOrder
    sexualOrientationId?: SortOrderInput | SortOrder
    relationshipGoalId?: SortOrderInput | SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    name?: StringWithAggregatesFilter<"Profile"> | string
    age?: IntWithAggregatesFilter<"Profile"> | number
    gender?: StringWithAggregatesFilter<"Profile"> | string
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    university?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    personality?: EnumPersonalityTypeNullableWithAggregatesFilter<"Profile"> | $Enums.PersonalityType | null
    userId?: StringWithAggregatesFilter<"Profile"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    extraSignalCredits?: IntWithAggregatesFilter<"Profile"> | number
    hideViewFootprints?: BoolWithAggregatesFilter<"Profile"> | boolean
    preferredMinAge?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    preferredMaxAge?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    notifyOnNewSignal?: BoolWithAggregatesFilter<"Profile"> | boolean
    notifyOnNewMatch?: BoolWithAggregatesFilter<"Profile"> | boolean
    notifyOnNewMessage?: BoolWithAggregatesFilter<"Profile"> | boolean
    isVerified?: BoolWithAggregatesFilter<"Profile"> | boolean
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"Profile"> | $Enums.VerificationStatus
    verificationPhotoUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    provisionalSignalsUsed?: IntWithAggregatesFilter<"Profile"> | number
    currentStatus?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    statusExpiresAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    sexualOrientationId?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    relationshipGoalId?: IntNullableWithAggregatesFilter<"Profile"> | number | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    interests?: InterestListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    interests?: InterestOrderByRelationAggregateInput
    _relevance?: CategoryOrderByRelevanceInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    interests?: InterestListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type InterestWhereInput = {
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    id?: IntFilter<"Interest"> | number
    name?: StringFilter<"Interest"> | string
    categoryId?: IntFilter<"Interest"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    profiles?: ProfileListRelationFilter
  }

  export type InterestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    profiles?: ProfileOrderByRelationAggregateInput
    _relevance?: InterestOrderByRelevanceInput
  }

  export type InterestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    categoryId?: IntFilter<"Interest"> | number
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    profiles?: ProfileListRelationFilter
  }, "id" | "name">

  export type InterestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
    _count?: InterestCountOrderByAggregateInput
    _avg?: InterestAvgOrderByAggregateInput
    _max?: InterestMaxOrderByAggregateInput
    _min?: InterestMinOrderByAggregateInput
    _sum?: InterestSumOrderByAggregateInput
  }

  export type InterestScalarWhereWithAggregatesInput = {
    AND?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    OR?: InterestScalarWhereWithAggregatesInput[]
    NOT?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Interest"> | number
    name?: StringWithAggregatesFilter<"Interest"> | string
    categoryId?: IntWithAggregatesFilter<"Interest"> | number
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: IntFilter<"Venue"> | number
    name?: StringFilter<"Venue"> | string
    address?: StringNullableFilter<"Venue"> | string | null
    description?: StringNullableFilter<"Venue"> | string | null
    latitude?: FloatFilter<"Venue"> | number
    longitude?: FloatFilter<"Venue"> | number
    isActive?: BoolFilter<"Venue"> | boolean
    isFeatured?: BoolFilter<"Venue"> | boolean
    category?: EnumVenueCategoryFilter<"Venue"> | $Enums.VenueCategory
    statsSummary?: JsonNullableFilter<"Venue">
    activeSessions?: ActiveSessionListRelationFilter
    groupMessages?: VenueGroupMessageListRelationFilter
    checkInHistory?: CheckInHistoryListRelationFilter
    challenges?: ChallengeInstanceListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    category?: SortOrder
    statsSummary?: SortOrderInput | SortOrder
    activeSessions?: ActiveSessionOrderByRelationAggregateInput
    groupMessages?: VenueGroupMessageOrderByRelationAggregateInput
    checkInHistory?: CheckInHistoryOrderByRelationAggregateInput
    challenges?: ChallengeInstanceOrderByRelationAggregateInput
    _relevance?: VenueOrderByRelevanceInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    name?: StringFilter<"Venue"> | string
    address?: StringNullableFilter<"Venue"> | string | null
    description?: StringNullableFilter<"Venue"> | string | null
    latitude?: FloatFilter<"Venue"> | number
    longitude?: FloatFilter<"Venue"> | number
    isActive?: BoolFilter<"Venue"> | boolean
    isFeatured?: BoolFilter<"Venue"> | boolean
    category?: EnumVenueCategoryFilter<"Venue"> | $Enums.VenueCategory
    statsSummary?: JsonNullableFilter<"Venue">
    activeSessions?: ActiveSessionListRelationFilter
    groupMessages?: VenueGroupMessageListRelationFilter
    checkInHistory?: CheckInHistoryListRelationFilter
    challenges?: ChallengeInstanceListRelationFilter
  }, "id">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    category?: SortOrder
    statsSummary?: SortOrderInput | SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Venue"> | number
    name?: StringWithAggregatesFilter<"Venue"> | string
    address?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    description?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    latitude?: FloatWithAggregatesFilter<"Venue"> | number
    longitude?: FloatWithAggregatesFilter<"Venue"> | number
    isActive?: BoolWithAggregatesFilter<"Venue"> | boolean
    isFeatured?: BoolWithAggregatesFilter<"Venue"> | boolean
    category?: EnumVenueCategoryWithAggregatesFilter<"Venue"> | $Enums.VenueCategory
    statsSummary?: JsonNullableWithAggregatesFilter<"Venue">
  }

  export type ActiveSessionWhereInput = {
    AND?: ActiveSessionWhereInput | ActiveSessionWhereInput[]
    OR?: ActiveSessionWhereInput[]
    NOT?: ActiveSessionWhereInput | ActiveSessionWhereInput[]
    id?: StringFilter<"ActiveSession"> | string
    createdAt?: DateTimeFilter<"ActiveSession"> | Date | string
    expiresAt?: DateTimeFilter<"ActiveSession"> | Date | string
    isIncognito?: BoolFilter<"ActiveSession"> | boolean
    userId?: StringFilter<"ActiveSession"> | string
    venueId?: IntFilter<"ActiveSession"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }

  export type ActiveSessionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isIncognito?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    user?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    _relevance?: ActiveSessionOrderByRelevanceInput
  }

  export type ActiveSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ActiveSessionWhereInput | ActiveSessionWhereInput[]
    OR?: ActiveSessionWhereInput[]
    NOT?: ActiveSessionWhereInput | ActiveSessionWhereInput[]
    createdAt?: DateTimeFilter<"ActiveSession"> | Date | string
    expiresAt?: DateTimeFilter<"ActiveSession"> | Date | string
    isIncognito?: BoolFilter<"ActiveSession"> | boolean
    venueId?: IntFilter<"ActiveSession"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }, "id" | "userId">

  export type ActiveSessionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isIncognito?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    _count?: ActiveSessionCountOrderByAggregateInput
    _avg?: ActiveSessionAvgOrderByAggregateInput
    _max?: ActiveSessionMaxOrderByAggregateInput
    _min?: ActiveSessionMinOrderByAggregateInput
    _sum?: ActiveSessionSumOrderByAggregateInput
  }

  export type ActiveSessionScalarWhereWithAggregatesInput = {
    AND?: ActiveSessionScalarWhereWithAggregatesInput | ActiveSessionScalarWhereWithAggregatesInput[]
    OR?: ActiveSessionScalarWhereWithAggregatesInput[]
    NOT?: ActiveSessionScalarWhereWithAggregatesInput | ActiveSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActiveSession"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ActiveSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"ActiveSession"> | Date | string
    isIncognito?: BoolWithAggregatesFilter<"ActiveSession"> | boolean
    userId?: StringWithAggregatesFilter<"ActiveSession"> | string
    venueId?: IntWithAggregatesFilter<"ActiveSession"> | number
  }

  export type SignalWhereInput = {
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    id?: IntFilter<"Signal"> | number
    createdAt?: DateTimeFilter<"Signal"> | Date | string
    senderId?: StringFilter<"Signal"> | string
    receiverId?: StringFilter<"Signal"> | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SignalOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    sender?: UserOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    _relevance?: SignalOrderByRelevanceInput
  }

  export type SignalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    senderId_receiverId?: SignalSenderIdReceiverIdCompoundUniqueInput
    AND?: SignalWhereInput | SignalWhereInput[]
    OR?: SignalWhereInput[]
    NOT?: SignalWhereInput | SignalWhereInput[]
    createdAt?: DateTimeFilter<"Signal"> | Date | string
    senderId?: StringFilter<"Signal"> | string
    receiverId?: StringFilter<"Signal"> | string
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "senderId_receiverId">

  export type SignalOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    _count?: SignalCountOrderByAggregateInput
    _avg?: SignalAvgOrderByAggregateInput
    _max?: SignalMaxOrderByAggregateInput
    _min?: SignalMinOrderByAggregateInput
    _sum?: SignalSumOrderByAggregateInput
  }

  export type SignalScalarWhereWithAggregatesInput = {
    AND?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    OR?: SignalScalarWhereWithAggregatesInput[]
    NOT?: SignalScalarWhereWithAggregatesInput | SignalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Signal"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Signal"> | Date | string
    senderId?: StringWithAggregatesFilter<"Signal"> | string
    receiverId?: StringWithAggregatesFilter<"Signal"> | string
  }

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    id?: IntFilter<"Connection"> | number
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    userAId?: StringFilter<"Connection"> | string
    userBId?: StringFilter<"Connection"> | string
    userA?: XOR<UserScalarRelationFilter, UserWhereInput>
    userB?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    challenges?: ChallengeInstanceListRelationFilter
  }

  export type ConnectionOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    userA?: UserOrderByWithRelationInput
    userB?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    challenges?: ChallengeInstanceOrderByRelationAggregateInput
    _relevance?: ConnectionOrderByRelevanceInput
  }

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userAId_userBId?: ConnectionUserAIdUserBIdCompoundUniqueInput
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    userAId?: StringFilter<"Connection"> | string
    userBId?: StringFilter<"Connection"> | string
    userA?: XOR<UserScalarRelationFilter, UserWhereInput>
    userB?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    challenges?: ChallengeInstanceListRelationFilter
  }, "id" | "userAId_userBId">

  export type ConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    _count?: ConnectionCountOrderByAggregateInput
    _avg?: ConnectionAvgOrderByAggregateInput
    _max?: ConnectionMaxOrderByAggregateInput
    _min?: ConnectionMinOrderByAggregateInput
    _sum?: ConnectionSumOrderByAggregateInput
  }

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    OR?: ConnectionScalarWhereWithAggregatesInput[]
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Connection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Connection"> | Date | string
    userAId?: StringWithAggregatesFilter<"Connection"> | string
    userBId?: StringWithAggregatesFilter<"Connection"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    content?: StringNullableFilter<"Message"> | string | null
    imageUrl?: StringNullableFilter<"Message"> | string | null
    audioUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: StringFilter<"Message"> | string
    connectionId?: IntFilter<"Message"> | number
    isRead?: BoolFilter<"Message"> | boolean
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    connection?: XOR<ConnectionScalarRelationFilter, ConnectionWhereInput>
    reports?: ReportListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    connectionId?: SortOrder
    isRead?: SortOrder
    sender?: UserOrderByWithRelationInput
    connection?: ConnectionOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
    _relevance?: MessageOrderByRelevanceInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringNullableFilter<"Message"> | string | null
    imageUrl?: StringNullableFilter<"Message"> | string | null
    audioUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: StringFilter<"Message"> | string
    connectionId?: IntFilter<"Message"> | number
    isRead?: BoolFilter<"Message"> | boolean
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    connection?: XOR<ConnectionScalarRelationFilter, ConnectionWhereInput>
    reports?: ReportListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    connectionId?: SortOrder
    isRead?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    connectionId?: IntWithAggregatesFilter<"Message"> | number
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: IntFilter<"Block"> | number
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blockerId?: StringFilter<"Block"> | string
    blockedId?: StringFilter<"Block"> | string
    blocker?: XOR<UserScalarRelationFilter, UserWhereInput>
    blocked?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    blocker?: UserOrderByWithRelationInput
    blocked?: UserOrderByWithRelationInput
    _relevance?: BlockOrderByRelevanceInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    blockerId_blockedId?: BlockBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blockerId?: StringFilter<"Block"> | string
    blockedId?: StringFilter<"Block"> | string
    blocker?: XOR<UserScalarRelationFilter, UserWhereInput>
    blocked?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "blockerId_blockedId">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _avg?: BlockAvgOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
    _sum?: BlockSumOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Block"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
    blockerId?: StringWithAggregatesFilter<"Block"> | string
    blockedId?: StringWithAggregatesFilter<"Block"> | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    reportedMessageId?: IntNullableFilter<"Report"> | number | null
    reportedGroupMessageId?: IntNullableFilter<"Report"> | number | null
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportedUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportedMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    reportedGroupMessage?: XOR<VenueGroupMessageNullableScalarRelationFilter, VenueGroupMessageWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedMessageId?: SortOrderInput | SortOrder
    reportedGroupMessageId?: SortOrderInput | SortOrder
    reporter?: UserOrderByWithRelationInput
    reportedUser?: UserOrderByWithRelationInput
    reportedMessage?: MessageOrderByWithRelationInput
    reportedGroupMessage?: VenueGroupMessageOrderByWithRelationInput
    _relevance?: ReportOrderByRelevanceInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    reportedMessageId?: IntNullableFilter<"Report"> | number | null
    reportedGroupMessageId?: IntNullableFilter<"Report"> | number | null
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportedUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    reportedMessage?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    reportedGroupMessage?: XOR<VenueGroupMessageNullableScalarRelationFilter, VenueGroupMessageWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedMessageId?: SortOrderInput | SortOrder
    reportedGroupMessageId?: SortOrderInput | SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    reason?: StringWithAggregatesFilter<"Report"> | string
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    reporterId?: StringWithAggregatesFilter<"Report"> | string
    reportedUserId?: StringWithAggregatesFilter<"Report"> | string
    reportedMessageId?: IntNullableWithAggregatesFilter<"Report"> | number | null
    reportedGroupMessageId?: IntNullableWithAggregatesFilter<"Report"> | number | null
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: IntFilter<"Device"> | number
    token?: StringFilter<"Device"> | string
    createdAt?: DateTimeFilter<"Device"> | Date | string
    userId?: StringFilter<"Device"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: DeviceOrderByRelevanceInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    createdAt?: DateTimeFilter<"Device"> | Date | string
    userId?: StringFilter<"Device"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _avg?: DeviceAvgOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
    _sum?: DeviceSumOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Device"> | number
    token?: StringWithAggregatesFilter<"Device"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Device"> | Date | string
    userId?: StringWithAggregatesFilter<"Device"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: NotificationOrderByRelevanceInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    content?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: IntFilter<"Feedback"> | number
    description?: StringFilter<"Feedback"> | string
    screenshotUrl?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    authorId?: StringFilter<"Feedback"> | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    screenshotUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    author?: UserOrderByWithRelationInput
    _relevance?: FeedbackOrderByRelevanceInput
  }

  export type FeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    description?: StringFilter<"Feedback"> | string
    screenshotUrl?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    authorId?: StringFilter<"Feedback"> | string
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    screenshotUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Feedback"> | number
    description?: StringWithAggregatesFilter<"Feedback"> | string
    screenshotUrl?: StringNullableWithAggregatesFilter<"Feedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feedback"> | Date | string
    authorId?: StringWithAggregatesFilter<"Feedback"> | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
    _relevance?: AuditLogOrderByRelevanceInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    actorId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type BroadcastNotificationWhereInput = {
    AND?: BroadcastNotificationWhereInput | BroadcastNotificationWhereInput[]
    OR?: BroadcastNotificationWhereInput[]
    NOT?: BroadcastNotificationWhereInput | BroadcastNotificationWhereInput[]
    id?: IntFilter<"BroadcastNotification"> | number
    title?: StringFilter<"BroadcastNotification"> | string
    body?: StringFilter<"BroadcastNotification"> | string
    createdAt?: DateTimeFilter<"BroadcastNotification"> | Date | string
    sentById?: StringFilter<"BroadcastNotification"> | string
    sentBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BroadcastNotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    sentById?: SortOrder
    sentBy?: UserOrderByWithRelationInput
    _relevance?: BroadcastNotificationOrderByRelevanceInput
  }

  export type BroadcastNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BroadcastNotificationWhereInput | BroadcastNotificationWhereInput[]
    OR?: BroadcastNotificationWhereInput[]
    NOT?: BroadcastNotificationWhereInput | BroadcastNotificationWhereInput[]
    title?: StringFilter<"BroadcastNotification"> | string
    body?: StringFilter<"BroadcastNotification"> | string
    createdAt?: DateTimeFilter<"BroadcastNotification"> | Date | string
    sentById?: StringFilter<"BroadcastNotification"> | string
    sentBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type BroadcastNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    sentById?: SortOrder
    _count?: BroadcastNotificationCountOrderByAggregateInput
    _avg?: BroadcastNotificationAvgOrderByAggregateInput
    _max?: BroadcastNotificationMaxOrderByAggregateInput
    _min?: BroadcastNotificationMinOrderByAggregateInput
    _sum?: BroadcastNotificationSumOrderByAggregateInput
  }

  export type BroadcastNotificationScalarWhereWithAggregatesInput = {
    AND?: BroadcastNotificationScalarWhereWithAggregatesInput | BroadcastNotificationScalarWhereWithAggregatesInput[]
    OR?: BroadcastNotificationScalarWhereWithAggregatesInput[]
    NOT?: BroadcastNotificationScalarWhereWithAggregatesInput | BroadcastNotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BroadcastNotification"> | number
    title?: StringWithAggregatesFilter<"BroadcastNotification"> | string
    body?: StringWithAggregatesFilter<"BroadcastNotification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BroadcastNotification"> | Date | string
    sentById?: StringWithAggregatesFilter<"BroadcastNotification"> | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: StringFilter<"PasswordResetToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: PasswordResetTokenOrderByRelevanceInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: StringFilter<"PasswordResetToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _avg?: PasswordResetTokenAvgOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
    _sum?: PasswordResetTokenSumOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PasswordResetToken"> | number
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
  }

  export type PhotoWhereInput = {
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    id?: IntFilter<"Photo"> | number
    url?: StringFilter<"Photo"> | string
    isAvatar?: BoolFilter<"Photo"> | boolean
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profileId?: StringFilter<"Photo"> | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    isAvatar?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    _relevance?: PhotoOrderByRelevanceInput
  }

  export type PhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    url?: StringFilter<"Photo"> | string
    isAvatar?: BoolFilter<"Photo"> | boolean
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profileId?: StringFilter<"Photo"> | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    isAvatar?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _avg?: PhotoAvgOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
    _sum?: PhotoSumOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    OR?: PhotoScalarWhereWithAggregatesInput[]
    NOT?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Photo"> | number
    url?: StringWithAggregatesFilter<"Photo"> | string
    isAvatar?: BoolWithAggregatesFilter<"Photo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Photo"> | Date | string
    profileId?: StringWithAggregatesFilter<"Photo"> | string
  }

  export type IcebreakerQuestionWhereInput = {
    AND?: IcebreakerQuestionWhereInput | IcebreakerQuestionWhereInput[]
    OR?: IcebreakerQuestionWhereInput[]
    NOT?: IcebreakerQuestionWhereInput | IcebreakerQuestionWhereInput[]
    id?: IntFilter<"IcebreakerQuestion"> | number
    text?: StringFilter<"IcebreakerQuestion"> | string
    category?: EnumIcebreakerCategoryFilter<"IcebreakerQuestion"> | $Enums.IcebreakerCategory
    createdAt?: DateTimeFilter<"IcebreakerQuestion"> | Date | string
  }

  export type IcebreakerQuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    _relevance?: IcebreakerQuestionOrderByRelevanceInput
  }

  export type IcebreakerQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    text?: string
    AND?: IcebreakerQuestionWhereInput | IcebreakerQuestionWhereInput[]
    OR?: IcebreakerQuestionWhereInput[]
    NOT?: IcebreakerQuestionWhereInput | IcebreakerQuestionWhereInput[]
    category?: EnumIcebreakerCategoryFilter<"IcebreakerQuestion"> | $Enums.IcebreakerCategory
    createdAt?: DateTimeFilter<"IcebreakerQuestion"> | Date | string
  }, "id" | "text">

  export type IcebreakerQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    _count?: IcebreakerQuestionCountOrderByAggregateInput
    _avg?: IcebreakerQuestionAvgOrderByAggregateInput
    _max?: IcebreakerQuestionMaxOrderByAggregateInput
    _min?: IcebreakerQuestionMinOrderByAggregateInput
    _sum?: IcebreakerQuestionSumOrderByAggregateInput
  }

  export type IcebreakerQuestionScalarWhereWithAggregatesInput = {
    AND?: IcebreakerQuestionScalarWhereWithAggregatesInput | IcebreakerQuestionScalarWhereWithAggregatesInput[]
    OR?: IcebreakerQuestionScalarWhereWithAggregatesInput[]
    NOT?: IcebreakerQuestionScalarWhereWithAggregatesInput | IcebreakerQuestionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IcebreakerQuestion"> | number
    text?: StringWithAggregatesFilter<"IcebreakerQuestion"> | string
    category?: EnumIcebreakerCategoryWithAggregatesFilter<"IcebreakerQuestion"> | $Enums.IcebreakerCategory
    createdAt?: DateTimeWithAggregatesFilter<"IcebreakerQuestion"> | Date | string
  }

  export type ProfileViewWhereInput = {
    AND?: ProfileViewWhereInput | ProfileViewWhereInput[]
    OR?: ProfileViewWhereInput[]
    NOT?: ProfileViewWhereInput | ProfileViewWhereInput[]
    id?: IntFilter<"ProfileView"> | number
    viewerId?: StringFilter<"ProfileView"> | string
    viewedId?: StringFilter<"ProfileView"> | string
    createdAt?: DateTimeFilter<"ProfileView"> | Date | string
    viewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    viewed?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProfileViewOrderByWithRelationInput = {
    id?: SortOrder
    viewerId?: SortOrder
    viewedId?: SortOrder
    createdAt?: SortOrder
    viewer?: UserOrderByWithRelationInput
    viewed?: UserOrderByWithRelationInput
    _relevance?: ProfileViewOrderByRelevanceInput
  }

  export type ProfileViewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    viewerId_viewedId?: ProfileViewViewerIdViewedIdCompoundUniqueInput
    AND?: ProfileViewWhereInput | ProfileViewWhereInput[]
    OR?: ProfileViewWhereInput[]
    NOT?: ProfileViewWhereInput | ProfileViewWhereInput[]
    viewerId?: StringFilter<"ProfileView"> | string
    viewedId?: StringFilter<"ProfileView"> | string
    createdAt?: DateTimeFilter<"ProfileView"> | Date | string
    viewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    viewed?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "viewerId_viewedId">

  export type ProfileViewOrderByWithAggregationInput = {
    id?: SortOrder
    viewerId?: SortOrder
    viewedId?: SortOrder
    createdAt?: SortOrder
    _count?: ProfileViewCountOrderByAggregateInput
    _avg?: ProfileViewAvgOrderByAggregateInput
    _max?: ProfileViewMaxOrderByAggregateInput
    _min?: ProfileViewMinOrderByAggregateInput
    _sum?: ProfileViewSumOrderByAggregateInput
  }

  export type ProfileViewScalarWhereWithAggregatesInput = {
    AND?: ProfileViewScalarWhereWithAggregatesInput | ProfileViewScalarWhereWithAggregatesInput[]
    OR?: ProfileViewScalarWhereWithAggregatesInput[]
    NOT?: ProfileViewScalarWhereWithAggregatesInput | ProfileViewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfileView"> | number
    viewerId?: StringWithAggregatesFilter<"ProfileView"> | string
    viewedId?: StringWithAggregatesFilter<"ProfileView"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileView"> | Date | string
  }

  export type VenueGroupMessageWhereInput = {
    AND?: VenueGroupMessageWhereInput | VenueGroupMessageWhereInput[]
    OR?: VenueGroupMessageWhereInput[]
    NOT?: VenueGroupMessageWhereInput | VenueGroupMessageWhereInput[]
    id?: IntFilter<"VenueGroupMessage"> | number
    content?: StringNullableFilter<"VenueGroupMessage"> | string | null
    imageUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    audioUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    videoUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    createdAt?: DateTimeFilter<"VenueGroupMessage"> | Date | string
    venueId?: IntFilter<"VenueGroupMessage"> | number
    senderId?: StringFilter<"VenueGroupMessage"> | string
    reports?: ReportListRelationFilter
    reactions?: GroupMessageReactionListRelationFilter
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VenueGroupMessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    venueId?: SortOrder
    senderId?: SortOrder
    reports?: ReportOrderByRelationAggregateInput
    reactions?: GroupMessageReactionOrderByRelationAggregateInput
    venue?: VenueOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    _relevance?: VenueGroupMessageOrderByRelevanceInput
  }

  export type VenueGroupMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VenueGroupMessageWhereInput | VenueGroupMessageWhereInput[]
    OR?: VenueGroupMessageWhereInput[]
    NOT?: VenueGroupMessageWhereInput | VenueGroupMessageWhereInput[]
    content?: StringNullableFilter<"VenueGroupMessage"> | string | null
    imageUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    audioUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    videoUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    createdAt?: DateTimeFilter<"VenueGroupMessage"> | Date | string
    venueId?: IntFilter<"VenueGroupMessage"> | number
    senderId?: StringFilter<"VenueGroupMessage"> | string
    reports?: ReportListRelationFilter
    reactions?: GroupMessageReactionListRelationFilter
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type VenueGroupMessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    audioUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    venueId?: SortOrder
    senderId?: SortOrder
    _count?: VenueGroupMessageCountOrderByAggregateInput
    _avg?: VenueGroupMessageAvgOrderByAggregateInput
    _max?: VenueGroupMessageMaxOrderByAggregateInput
    _min?: VenueGroupMessageMinOrderByAggregateInput
    _sum?: VenueGroupMessageSumOrderByAggregateInput
  }

  export type VenueGroupMessageScalarWhereWithAggregatesInput = {
    AND?: VenueGroupMessageScalarWhereWithAggregatesInput | VenueGroupMessageScalarWhereWithAggregatesInput[]
    OR?: VenueGroupMessageScalarWhereWithAggregatesInput[]
    NOT?: VenueGroupMessageScalarWhereWithAggregatesInput | VenueGroupMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VenueGroupMessage"> | number
    content?: StringNullableWithAggregatesFilter<"VenueGroupMessage"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"VenueGroupMessage"> | string | null
    audioUrl?: StringNullableWithAggregatesFilter<"VenueGroupMessage"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"VenueGroupMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VenueGroupMessage"> | Date | string
    venueId?: IntWithAggregatesFilter<"VenueGroupMessage"> | number
    senderId?: StringWithAggregatesFilter<"VenueGroupMessage"> | string
  }

  export type AccountDeletionTokenWhereInput = {
    AND?: AccountDeletionTokenWhereInput | AccountDeletionTokenWhereInput[]
    OR?: AccountDeletionTokenWhereInput[]
    NOT?: AccountDeletionTokenWhereInput | AccountDeletionTokenWhereInput[]
    id?: IntFilter<"AccountDeletionToken"> | number
    token?: StringFilter<"AccountDeletionToken"> | string
    expiresAt?: DateTimeFilter<"AccountDeletionToken"> | Date | string
    createdAt?: DateTimeFilter<"AccountDeletionToken"> | Date | string
    userId?: StringFilter<"AccountDeletionToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountDeletionTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountDeletionTokenOrderByRelevanceInput
  }

  export type AccountDeletionTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    userId?: string
    AND?: AccountDeletionTokenWhereInput | AccountDeletionTokenWhereInput[]
    OR?: AccountDeletionTokenWhereInput[]
    NOT?: AccountDeletionTokenWhereInput | AccountDeletionTokenWhereInput[]
    expiresAt?: DateTimeFilter<"AccountDeletionToken"> | Date | string
    createdAt?: DateTimeFilter<"AccountDeletionToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "userId">

  export type AccountDeletionTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: AccountDeletionTokenCountOrderByAggregateInput
    _avg?: AccountDeletionTokenAvgOrderByAggregateInput
    _max?: AccountDeletionTokenMaxOrderByAggregateInput
    _min?: AccountDeletionTokenMinOrderByAggregateInput
    _sum?: AccountDeletionTokenSumOrderByAggregateInput
  }

  export type AccountDeletionTokenScalarWhereWithAggregatesInput = {
    AND?: AccountDeletionTokenScalarWhereWithAggregatesInput | AccountDeletionTokenScalarWhereWithAggregatesInput[]
    OR?: AccountDeletionTokenScalarWhereWithAggregatesInput[]
    NOT?: AccountDeletionTokenScalarWhereWithAggregatesInput | AccountDeletionTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AccountDeletionToken"> | number
    token?: StringWithAggregatesFilter<"AccountDeletionToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"AccountDeletionToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AccountDeletionToken"> | Date | string
    userId?: StringWithAggregatesFilter<"AccountDeletionToken"> | string
  }

  export type EmailChangeTokenWhereInput = {
    AND?: EmailChangeTokenWhereInput | EmailChangeTokenWhereInput[]
    OR?: EmailChangeTokenWhereInput[]
    NOT?: EmailChangeTokenWhereInput | EmailChangeTokenWhereInput[]
    id?: IntFilter<"EmailChangeToken"> | number
    token?: StringFilter<"EmailChangeToken"> | string
    newEmail?: StringFilter<"EmailChangeToken"> | string
    expiresAt?: DateTimeFilter<"EmailChangeToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailChangeToken"> | Date | string
    userId?: StringFilter<"EmailChangeToken"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailChangeTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    newEmail?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: EmailChangeTokenOrderByRelevanceInput
  }

  export type EmailChangeTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    userId?: string
    AND?: EmailChangeTokenWhereInput | EmailChangeTokenWhereInput[]
    OR?: EmailChangeTokenWhereInput[]
    NOT?: EmailChangeTokenWhereInput | EmailChangeTokenWhereInput[]
    newEmail?: StringFilter<"EmailChangeToken"> | string
    expiresAt?: DateTimeFilter<"EmailChangeToken"> | Date | string
    createdAt?: DateTimeFilter<"EmailChangeToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "userId">

  export type EmailChangeTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    newEmail?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: EmailChangeTokenCountOrderByAggregateInput
    _avg?: EmailChangeTokenAvgOrderByAggregateInput
    _max?: EmailChangeTokenMaxOrderByAggregateInput
    _min?: EmailChangeTokenMinOrderByAggregateInput
    _sum?: EmailChangeTokenSumOrderByAggregateInput
  }

  export type EmailChangeTokenScalarWhereWithAggregatesInput = {
    AND?: EmailChangeTokenScalarWhereWithAggregatesInput | EmailChangeTokenScalarWhereWithAggregatesInput[]
    OR?: EmailChangeTokenScalarWhereWithAggregatesInput[]
    NOT?: EmailChangeTokenScalarWhereWithAggregatesInput | EmailChangeTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailChangeToken"> | number
    token?: StringWithAggregatesFilter<"EmailChangeToken"> | string
    newEmail?: StringWithAggregatesFilter<"EmailChangeToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailChangeToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailChangeToken"> | Date | string
    userId?: StringWithAggregatesFilter<"EmailChangeToken"> | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    userId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: RefreshTokenOrderByRelevanceInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    userId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RefreshToken"> | number
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type GroupMessageReactionWhereInput = {
    AND?: GroupMessageReactionWhereInput | GroupMessageReactionWhereInput[]
    OR?: GroupMessageReactionWhereInput[]
    NOT?: GroupMessageReactionWhereInput | GroupMessageReactionWhereInput[]
    id?: IntFilter<"GroupMessageReaction"> | number
    emoji?: StringFilter<"GroupMessageReaction"> | string
    createdAt?: DateTimeFilter<"GroupMessageReaction"> | Date | string
    messageId?: IntFilter<"GroupMessageReaction"> | number
    userId?: StringFilter<"GroupMessageReaction"> | string
    message?: XOR<VenueGroupMessageScalarRelationFilter, VenueGroupMessageWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GroupMessageReactionOrderByWithRelationInput = {
    id?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    message?: VenueGroupMessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: GroupMessageReactionOrderByRelevanceInput
  }

  export type GroupMessageReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    messageId_userId_emoji?: GroupMessageReactionMessageIdUserIdEmojiCompoundUniqueInput
    AND?: GroupMessageReactionWhereInput | GroupMessageReactionWhereInput[]
    OR?: GroupMessageReactionWhereInput[]
    NOT?: GroupMessageReactionWhereInput | GroupMessageReactionWhereInput[]
    emoji?: StringFilter<"GroupMessageReaction"> | string
    createdAt?: DateTimeFilter<"GroupMessageReaction"> | Date | string
    messageId?: IntFilter<"GroupMessageReaction"> | number
    userId?: StringFilter<"GroupMessageReaction"> | string
    message?: XOR<VenueGroupMessageScalarRelationFilter, VenueGroupMessageWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId_emoji">

  export type GroupMessageReactionOrderByWithAggregationInput = {
    id?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    _count?: GroupMessageReactionCountOrderByAggregateInput
    _avg?: GroupMessageReactionAvgOrderByAggregateInput
    _max?: GroupMessageReactionMaxOrderByAggregateInput
    _min?: GroupMessageReactionMinOrderByAggregateInput
    _sum?: GroupMessageReactionSumOrderByAggregateInput
  }

  export type GroupMessageReactionScalarWhereWithAggregatesInput = {
    AND?: GroupMessageReactionScalarWhereWithAggregatesInput | GroupMessageReactionScalarWhereWithAggregatesInput[]
    OR?: GroupMessageReactionScalarWhereWithAggregatesInput[]
    NOT?: GroupMessageReactionScalarWhereWithAggregatesInput | GroupMessageReactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupMessageReaction"> | number
    emoji?: StringWithAggregatesFilter<"GroupMessageReaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GroupMessageReaction"> | Date | string
    messageId?: IntWithAggregatesFilter<"GroupMessageReaction"> | number
    userId?: StringWithAggregatesFilter<"GroupMessageReaction"> | string
  }

  export type CheckInHistoryWhereInput = {
    AND?: CheckInHistoryWhereInput | CheckInHistoryWhereInput[]
    OR?: CheckInHistoryWhereInput[]
    NOT?: CheckInHistoryWhereInput | CheckInHistoryWhereInput[]
    id?: IntFilter<"CheckInHistory"> | number
    createdAt?: DateTimeFilter<"CheckInHistory"> | Date | string
    userId?: StringFilter<"CheckInHistory"> | string
    venueId?: IntFilter<"CheckInHistory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }

  export type CheckInHistoryOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    user?: UserOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    _relevance?: CheckInHistoryOrderByRelevanceInput
  }

  export type CheckInHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CheckInHistoryWhereInput | CheckInHistoryWhereInput[]
    OR?: CheckInHistoryWhereInput[]
    NOT?: CheckInHistoryWhereInput | CheckInHistoryWhereInput[]
    createdAt?: DateTimeFilter<"CheckInHistory"> | Date | string
    userId?: StringFilter<"CheckInHistory"> | string
    venueId?: IntFilter<"CheckInHistory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }, "id">

  export type CheckInHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
    _count?: CheckInHistoryCountOrderByAggregateInput
    _avg?: CheckInHistoryAvgOrderByAggregateInput
    _max?: CheckInHistoryMaxOrderByAggregateInput
    _min?: CheckInHistoryMinOrderByAggregateInput
    _sum?: CheckInHistorySumOrderByAggregateInput
  }

  export type CheckInHistoryScalarWhereWithAggregatesInput = {
    AND?: CheckInHistoryScalarWhereWithAggregatesInput | CheckInHistoryScalarWhereWithAggregatesInput[]
    OR?: CheckInHistoryScalarWhereWithAggregatesInput[]
    NOT?: CheckInHistoryScalarWhereWithAggregatesInput | CheckInHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CheckInHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CheckInHistory"> | Date | string
    userId?: StringWithAggregatesFilter<"CheckInHistory"> | string
    venueId?: IntWithAggregatesFilter<"CheckInHistory"> | number
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: IntFilter<"Badge"> | number
    code?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringFilter<"Badge"> | string
    ruleId?: IntNullableFilter<"Badge"> | number | null
    checkValue?: IntNullableFilter<"Badge"> | number | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    rule?: XOR<BadgeRuleNullableScalarRelationFilter, BadgeRuleWhereInput> | null
    users?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    ruleId?: SortOrderInput | SortOrder
    checkValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    rule?: BadgeRuleOrderByWithRelationInput
    users?: UserBadgeOrderByRelationAggregateInput
    _relevance?: BadgeOrderByRelevanceInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringFilter<"Badge"> | string
    ruleId?: IntNullableFilter<"Badge"> | number | null
    checkValue?: IntNullableFilter<"Badge"> | number | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    rule?: XOR<BadgeRuleNullableScalarRelationFilter, BadgeRuleWhereInput> | null
    users?: UserBadgeListRelationFilter
  }, "id" | "code">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    ruleId?: SortOrderInput | SortOrder
    checkValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Badge"> | number
    code?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    description?: StringWithAggregatesFilter<"Badge"> | string
    iconUrl?: StringWithAggregatesFilter<"Badge"> | string
    ruleId?: IntNullableWithAggregatesFilter<"Badge"> | number | null
    checkValue?: IntNullableWithAggregatesFilter<"Badge"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: IntFilter<"UserBadge"> | number
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
    _relevance?: UserBadgeOrderByRelevanceInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    userId_badgeId?: UserBadgeUserIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: IntFilter<"UserBadge"> | number
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }, "userId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _avg?: UserBadgeAvgOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
    _sum?: UserBadgeSumOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeId?: IntWithAggregatesFilter<"UserBadge"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type BadgeRuleWhereInput = {
    AND?: BadgeRuleWhereInput | BadgeRuleWhereInput[]
    OR?: BadgeRuleWhereInput[]
    NOT?: BadgeRuleWhereInput | BadgeRuleWhereInput[]
    id?: IntFilter<"BadgeRule"> | number
    code?: StringFilter<"BadgeRule"> | string
    name?: StringFilter<"BadgeRule"> | string
    description?: StringFilter<"BadgeRule"> | string
    triggerAction?: StringFilter<"BadgeRule"> | string
    badges?: BadgeListRelationFilter
  }

  export type BadgeRuleOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerAction?: SortOrder
    badges?: BadgeOrderByRelationAggregateInput
    _relevance?: BadgeRuleOrderByRelevanceInput
  }

  export type BadgeRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: BadgeRuleWhereInput | BadgeRuleWhereInput[]
    OR?: BadgeRuleWhereInput[]
    NOT?: BadgeRuleWhereInput | BadgeRuleWhereInput[]
    name?: StringFilter<"BadgeRule"> | string
    description?: StringFilter<"BadgeRule"> | string
    triggerAction?: StringFilter<"BadgeRule"> | string
    badges?: BadgeListRelationFilter
  }, "id" | "code">

  export type BadgeRuleOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerAction?: SortOrder
    _count?: BadgeRuleCountOrderByAggregateInput
    _avg?: BadgeRuleAvgOrderByAggregateInput
    _max?: BadgeRuleMaxOrderByAggregateInput
    _min?: BadgeRuleMinOrderByAggregateInput
    _sum?: BadgeRuleSumOrderByAggregateInput
  }

  export type BadgeRuleScalarWhereWithAggregatesInput = {
    AND?: BadgeRuleScalarWhereWithAggregatesInput | BadgeRuleScalarWhereWithAggregatesInput[]
    OR?: BadgeRuleScalarWhereWithAggregatesInput[]
    NOT?: BadgeRuleScalarWhereWithAggregatesInput | BadgeRuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BadgeRule"> | number
    code?: StringWithAggregatesFilter<"BadgeRule"> | string
    name?: StringWithAggregatesFilter<"BadgeRule"> | string
    description?: StringWithAggregatesFilter<"BadgeRule"> | string
    triggerAction?: StringWithAggregatesFilter<"BadgeRule"> | string
  }

  export type ChallengeTemplateWhereInput = {
    AND?: ChallengeTemplateWhereInput | ChallengeTemplateWhereInput[]
    OR?: ChallengeTemplateWhereInput[]
    NOT?: ChallengeTemplateWhereInput | ChallengeTemplateWhereInput[]
    id?: IntFilter<"ChallengeTemplate"> | number
    name?: StringFilter<"ChallengeTemplate"> | string
    description?: StringFilter<"ChallengeTemplate"> | string
    iconUrl?: StringNullableFilter<"ChallengeTemplate"> | string | null
    isActive?: BoolFilter<"ChallengeTemplate"> | boolean
    createdAt?: DateTimeFilter<"ChallengeTemplate"> | Date | string
    instances?: ChallengeInstanceListRelationFilter
  }

  export type ChallengeTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    instances?: ChallengeInstanceOrderByRelationAggregateInput
    _relevance?: ChallengeTemplateOrderByRelevanceInput
  }

  export type ChallengeTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeTemplateWhereInput | ChallengeTemplateWhereInput[]
    OR?: ChallengeTemplateWhereInput[]
    NOT?: ChallengeTemplateWhereInput | ChallengeTemplateWhereInput[]
    name?: StringFilter<"ChallengeTemplate"> | string
    description?: StringFilter<"ChallengeTemplate"> | string
    iconUrl?: StringNullableFilter<"ChallengeTemplate"> | string | null
    isActive?: BoolFilter<"ChallengeTemplate"> | boolean
    createdAt?: DateTimeFilter<"ChallengeTemplate"> | Date | string
    instances?: ChallengeInstanceListRelationFilter
  }, "id">

  export type ChallengeTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ChallengeTemplateCountOrderByAggregateInput
    _avg?: ChallengeTemplateAvgOrderByAggregateInput
    _max?: ChallengeTemplateMaxOrderByAggregateInput
    _min?: ChallengeTemplateMinOrderByAggregateInput
    _sum?: ChallengeTemplateSumOrderByAggregateInput
  }

  export type ChallengeTemplateScalarWhereWithAggregatesInput = {
    AND?: ChallengeTemplateScalarWhereWithAggregatesInput | ChallengeTemplateScalarWhereWithAggregatesInput[]
    OR?: ChallengeTemplateScalarWhereWithAggregatesInput[]
    NOT?: ChallengeTemplateScalarWhereWithAggregatesInput | ChallengeTemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeTemplate"> | number
    name?: StringWithAggregatesFilter<"ChallengeTemplate"> | string
    description?: StringWithAggregatesFilter<"ChallengeTemplate"> | string
    iconUrl?: StringNullableWithAggregatesFilter<"ChallengeTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"ChallengeTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeTemplate"> | Date | string
  }

  export type ChallengeInstanceWhereInput = {
    AND?: ChallengeInstanceWhereInput | ChallengeInstanceWhereInput[]
    OR?: ChallengeInstanceWhereInput[]
    NOT?: ChallengeInstanceWhereInput | ChallengeInstanceWhereInput[]
    id?: IntFilter<"ChallengeInstance"> | number
    status?: EnumChallengeInstanceStatusFilter<"ChallengeInstance"> | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFilter<"ChallengeInstance"> | Date | string
    templateId?: IntFilter<"ChallengeInstance"> | number
    challengerId?: StringFilter<"ChallengeInstance"> | string
    challengedId?: StringFilter<"ChallengeInstance"> | string
    connectionId?: IntFilter<"ChallengeInstance"> | number
    venueId?: IntFilter<"ChallengeInstance"> | number
    challengerCheckedIn?: BoolFilter<"ChallengeInstance"> | boolean
    challengedCheckedIn?: BoolFilter<"ChallengeInstance"> | boolean
    createdAt?: DateTimeFilter<"ChallengeInstance"> | Date | string
    updatedAt?: DateTimeFilter<"ChallengeInstance"> | Date | string
    template?: XOR<ChallengeTemplateScalarRelationFilter, ChallengeTemplateWhereInput>
    challenger?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenged?: XOR<UserScalarRelationFilter, UserWhereInput>
    connection?: XOR<ConnectionScalarRelationFilter, ConnectionWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }

  export type ChallengeInstanceOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    challengeTime?: SortOrder
    templateId?: SortOrder
    challengerId?: SortOrder
    challengedId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
    challengerCheckedIn?: SortOrder
    challengedCheckedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    template?: ChallengeTemplateOrderByWithRelationInput
    challenger?: UserOrderByWithRelationInput
    challenged?: UserOrderByWithRelationInput
    connection?: ConnectionOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    _relevance?: ChallengeInstanceOrderByRelevanceInput
  }

  export type ChallengeInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChallengeInstanceWhereInput | ChallengeInstanceWhereInput[]
    OR?: ChallengeInstanceWhereInput[]
    NOT?: ChallengeInstanceWhereInput | ChallengeInstanceWhereInput[]
    status?: EnumChallengeInstanceStatusFilter<"ChallengeInstance"> | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFilter<"ChallengeInstance"> | Date | string
    templateId?: IntFilter<"ChallengeInstance"> | number
    challengerId?: StringFilter<"ChallengeInstance"> | string
    challengedId?: StringFilter<"ChallengeInstance"> | string
    connectionId?: IntFilter<"ChallengeInstance"> | number
    venueId?: IntFilter<"ChallengeInstance"> | number
    challengerCheckedIn?: BoolFilter<"ChallengeInstance"> | boolean
    challengedCheckedIn?: BoolFilter<"ChallengeInstance"> | boolean
    createdAt?: DateTimeFilter<"ChallengeInstance"> | Date | string
    updatedAt?: DateTimeFilter<"ChallengeInstance"> | Date | string
    template?: XOR<ChallengeTemplateScalarRelationFilter, ChallengeTemplateWhereInput>
    challenger?: XOR<UserScalarRelationFilter, UserWhereInput>
    challenged?: XOR<UserScalarRelationFilter, UserWhereInput>
    connection?: XOR<ConnectionScalarRelationFilter, ConnectionWhereInput>
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
  }, "id">

  export type ChallengeInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    challengeTime?: SortOrder
    templateId?: SortOrder
    challengerId?: SortOrder
    challengedId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
    challengerCheckedIn?: SortOrder
    challengedCheckedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChallengeInstanceCountOrderByAggregateInput
    _avg?: ChallengeInstanceAvgOrderByAggregateInput
    _max?: ChallengeInstanceMaxOrderByAggregateInput
    _min?: ChallengeInstanceMinOrderByAggregateInput
    _sum?: ChallengeInstanceSumOrderByAggregateInput
  }

  export type ChallengeInstanceScalarWhereWithAggregatesInput = {
    AND?: ChallengeInstanceScalarWhereWithAggregatesInput | ChallengeInstanceScalarWhereWithAggregatesInput[]
    OR?: ChallengeInstanceScalarWhereWithAggregatesInput[]
    NOT?: ChallengeInstanceScalarWhereWithAggregatesInput | ChallengeInstanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChallengeInstance"> | number
    status?: EnumChallengeInstanceStatusWithAggregatesFilter<"ChallengeInstance"> | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeWithAggregatesFilter<"ChallengeInstance"> | Date | string
    templateId?: IntWithAggregatesFilter<"ChallengeInstance"> | number
    challengerId?: StringWithAggregatesFilter<"ChallengeInstance"> | string
    challengedId?: StringWithAggregatesFilter<"ChallengeInstance"> | string
    connectionId?: IntWithAggregatesFilter<"ChallengeInstance"> | number
    venueId?: IntWithAggregatesFilter<"ChallengeInstance"> | number
    challengerCheckedIn?: BoolWithAggregatesFilter<"ChallengeInstance"> | boolean
    challengedCheckedIn?: BoolWithAggregatesFilter<"ChallengeInstance"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChallengeInstance"> | Date | string
  }

  export type ProfileOptionCreateInput = {
    type: $Enums.OptionType
    code: string
    name: string
    profilesByOrientation?: ProfileCreateNestedManyWithoutSexualOrientationInput
    profilesByGoal?: ProfileCreateNestedManyWithoutRelationshipGoalInput
  }

  export type ProfileOptionUncheckedCreateInput = {
    id?: number
    type: $Enums.OptionType
    code: string
    name: string
    profilesByOrientation?: ProfileUncheckedCreateNestedManyWithoutSexualOrientationInput
    profilesByGoal?: ProfileUncheckedCreateNestedManyWithoutRelationshipGoalInput
  }

  export type ProfileOptionUpdateInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profilesByOrientation?: ProfileUpdateManyWithoutSexualOrientationNestedInput
    profilesByGoal?: ProfileUpdateManyWithoutRelationshipGoalNestedInput
  }

  export type ProfileOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profilesByOrientation?: ProfileUncheckedUpdateManyWithoutSexualOrientationNestedInput
    profilesByGoal?: ProfileUncheckedUpdateManyWithoutRelationshipGoalNestedInput
  }

  export type ProfileOptionCreateManyInput = {
    id?: number
    type: $Enums.OptionType
    code: string
    name: string
  }

  export type ProfileOptionUpdateManyMutationInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileCreateInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
    interests?: InterestCreateNestedManyWithoutProfilesInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
    sexualOrientation?: ProfileOptionCreateNestedOneWithoutProfilesByOrientationInput
    relationshipGoal?: ProfileOptionCreateNestedOneWithoutProfilesByGoalInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
    relationshipGoalId?: number | null
    interests?: InterestUncheckedCreateNestedManyWithoutProfilesInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    interests?: InterestUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    sexualOrientation?: ProfileOptionUpdateOneWithoutProfilesByOrientationNestedInput
    relationshipGoal?: ProfileOptionUpdateOneWithoutProfilesByGoalNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: InterestUncheckedUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
    relationshipGoalId?: number | null
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    name: string
    interests?: InterestCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    interests?: InterestUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    interests?: InterestUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    interests?: InterestUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestCreateInput = {
    name: string
    category: CategoryCreateNestedOneWithoutInterestsInput
    profiles?: ProfileCreateNestedManyWithoutInterestsInput
  }

  export type InterestUncheckedCreateInput = {
    id?: number
    name: string
    categoryId: number
    profiles?: ProfileUncheckedCreateNestedManyWithoutInterestsInput
  }

  export type InterestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutInterestsNestedInput
    profiles?: ProfileUpdateManyWithoutInterestsNestedInput
  }

  export type InterestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
    profiles?: ProfileUncheckedUpdateManyWithoutInterestsNestedInput
  }

  export type InterestCreateManyInput = {
    id?: number
    name: string
    categoryId: number
  }

  export type InterestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type VenueCreateInput = {
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionCreateNestedManyWithoutVenueInput
    groupMessages?: VenueGroupMessageCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedCreateNestedManyWithoutVenueInput
    groupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUpdateManyWithoutVenueNestedInput
    groupMessages?: VenueGroupMessageUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedUpdateManyWithoutVenueNestedInput
    groupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VenueUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActiveSessionCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    user: UserCreateNestedOneWithoutActiveSessionInput
    venue: VenueCreateNestedOneWithoutActiveSessionsInput
  }

  export type ActiveSessionUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    userId: string
    venueId: number
  }

  export type ActiveSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutActiveSessionNestedInput
    venue?: VenueUpdateOneRequiredWithoutActiveSessionsNestedInput
  }

  export type ActiveSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type ActiveSessionCreateManyInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    userId: string
    venueId: number
  }

  export type ActiveSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActiveSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type SignalCreateInput = {
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentSignalsInput
    receiver: UserCreateNestedOneWithoutReceivedSignalsInput
  }

  export type SignalUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    senderId: string
    receiverId: string
  }

  export type SignalUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentSignalsNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedSignalsNestedInput
  }

  export type SignalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type SignalCreateManyInput = {
    id?: number
    createdAt?: Date | string
    senderId: string
    receiverId: string
  }

  export type SignalUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionCreateInput = {
    createdAt?: Date | string
    userA: UserCreateNestedOneWithoutConnectionsAInput
    userB: UserCreateNestedOneWithoutConnectionsBInput
    messages?: MessageCreateNestedManyWithoutConnectionInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    userAId: string
    userBId: string
    messages?: MessageUncheckedCreateNestedManyWithoutConnectionInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutConnectionsANestedInput
    userB?: UserUpdateOneRequiredWithoutConnectionsBNestedInput
    messages?: MessageUpdateManyWithoutConnectionNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutConnectionNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionCreateManyInput = {
    id?: number
    createdAt?: Date | string
    userAId: string
    userBId: string
  }

  export type ConnectionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConnectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutMessagesInput
    connection: ConnectionCreateNestedOneWithoutMessagesInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    senderId: string
    connectionId: number
    isRead?: boolean
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutMessagesNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    senderId: string
    connectionId: number
    isRead?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlockCreateInput = {
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlockingInput
    blocked: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    blockerId: string
    blockedId: string
  }

  export type BlockUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlockingNestedInput
    blocked?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockCreateManyInput = {
    id?: number
    createdAt?: Date | string
    blockerId: string
    blockedId: string
  }

  export type BlockUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reportedGroupMessage?: VenueGroupMessageCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedUserId: string
    reportedMessageId?: number | null
    reportedGroupMessageId?: number | null
  }

  export type ReportUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reportedGroupMessage?: VenueGroupMessageUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportCreateManyInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedUserId: string
    reportedMessageId?: number | null
    reportedGroupMessageId?: number | null
  }

  export type ReportUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceCreateInput = {
    token: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: number
    token: string
    createdAt?: Date | string
    userId: string
  }

  export type DeviceUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCreateManyInput = {
    id?: number
    token: string
    createdAt?: Date | string
    userId: string
  }

  export type DeviceUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    type: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    type: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    type: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
    userId: string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateInput = {
    description: string
    screenshotUrl?: string | null
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutFeedbacksInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: number
    description: string
    screenshotUrl?: string | null
    createdAt?: Date | string
    authorId: string
  }

  export type FeedbackUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateManyInput = {
    id?: number
    description: string
    screenshotUrl?: string | null
    createdAt?: Date | string
    authorId: string
  }

  export type FeedbackUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type RoleCreateInput = {
    name: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogCreateInput = {
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    actorId?: string | null
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    actorId?: string | null
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BroadcastNotificationCreateInput = {
    title: string
    body: string
    createdAt?: Date | string
    sentBy: UserCreateNestedOneWithoutSentBroadcastsInput
  }

  export type BroadcastNotificationUncheckedCreateInput = {
    id?: number
    title: string
    body: string
    createdAt?: Date | string
    sentById: string
  }

  export type BroadcastNotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentBy?: UserUpdateOneRequiredWithoutSentBroadcastsNestedInput
  }

  export type BroadcastNotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
  }

  export type BroadcastNotificationCreateManyInput = {
    id?: number
    title: string
    body: string
    createdAt?: Date | string
    sentById: string
  }

  export type BroadcastNotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BroadcastNotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentById?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type PasswordResetTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateInput = {
    url: string
    isAvatar?: boolean
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPhotosInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: number
    url: string
    isAvatar?: boolean
    createdAt?: Date | string
    profileId: string
  }

  export type PhotoUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateManyInput = {
    id?: number
    url: string
    isAvatar?: boolean
    createdAt?: Date | string
    profileId: string
  }

  export type PhotoUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type IcebreakerQuestionCreateInput = {
    text: string
    category?: $Enums.IcebreakerCategory
    createdAt?: Date | string
  }

  export type IcebreakerQuestionUncheckedCreateInput = {
    id?: number
    text: string
    category?: $Enums.IcebreakerCategory
    createdAt?: Date | string
  }

  export type IcebreakerQuestionUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    category?: EnumIcebreakerCategoryFieldUpdateOperationsInput | $Enums.IcebreakerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IcebreakerQuestionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    category?: EnumIcebreakerCategoryFieldUpdateOperationsInput | $Enums.IcebreakerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IcebreakerQuestionCreateManyInput = {
    id?: number
    text: string
    category?: $Enums.IcebreakerCategory
    createdAt?: Date | string
  }

  export type IcebreakerQuestionUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    category?: EnumIcebreakerCategoryFieldUpdateOperationsInput | $Enums.IcebreakerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IcebreakerQuestionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    category?: EnumIcebreakerCategoryFieldUpdateOperationsInput | $Enums.IcebreakerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewCreateInput = {
    createdAt?: Date | string
    viewer: UserCreateNestedOneWithoutViewsMadeInput
    viewed: UserCreateNestedOneWithoutViewsReceivedInput
  }

  export type ProfileViewUncheckedCreateInput = {
    id?: number
    viewerId: string
    viewedId: string
    createdAt?: Date | string
  }

  export type ProfileViewUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewer?: UserUpdateOneRequiredWithoutViewsMadeNestedInput
    viewed?: UserUpdateOneRequiredWithoutViewsReceivedNestedInput
  }

  export type ProfileViewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    viewerId?: StringFieldUpdateOperationsInput | string
    viewedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewCreateManyInput = {
    id?: number
    viewerId: string
    viewedId: string
    createdAt?: Date | string
  }

  export type ProfileViewUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    viewerId?: StringFieldUpdateOperationsInput | string
    viewedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueGroupMessageCreateInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    reports?: ReportCreateNestedManyWithoutReportedGroupMessageInput
    reactions?: GroupMessageReactionCreateNestedManyWithoutMessageInput
    venue: VenueCreateNestedOneWithoutGroupMessagesInput
    sender: UserCreateNestedOneWithoutVenueGroupMessagesInput
  }

  export type VenueGroupMessageUncheckedCreateInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    venueId: number
    senderId: string
    reports?: ReportUncheckedCreateNestedManyWithoutReportedGroupMessageInput
    reactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type VenueGroupMessageUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutReportedGroupMessageNestedInput
    reactions?: GroupMessageReactionUpdateManyWithoutMessageNestedInput
    venue?: VenueUpdateOneRequiredWithoutGroupMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutVenueGroupMessagesNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    reports?: ReportUncheckedUpdateManyWithoutReportedGroupMessageNestedInput
    reactions?: GroupMessageReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type VenueGroupMessageCreateManyInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    venueId: number
    senderId: string
  }

  export type VenueGroupMessageUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueGroupMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountDeletionTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAccountDeletionTokenInput
  }

  export type AccountDeletionTokenUncheckedCreateInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type AccountDeletionTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountDeletionTokenNestedInput
  }

  export type AccountDeletionTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountDeletionTokenCreateManyInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type AccountDeletionTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeletionTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailChangeTokenCreateInput = {
    token: string
    newEmail: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEmailChangeTokenInput
  }

  export type EmailChangeTokenUncheckedCreateInput = {
    id?: number
    token: string
    newEmail: string
    expiresAt: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type EmailChangeTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailChangeTokenNestedInput
  }

  export type EmailChangeTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailChangeTokenCreateManyInput = {
    id?: number
    token: string
    newEmail: string
    expiresAt: Date | string
    createdAt?: Date | string
    userId: string
  }

  export type EmailChangeTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RefreshTokenCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: number
    token: string
    expiresAt: Date | string
    userId: string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: number
    token: string
    expiresAt: Date | string
    userId: string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageReactionCreateInput = {
    emoji: string
    createdAt?: Date | string
    message: VenueGroupMessageCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutGroupMessageReactionsInput
  }

  export type GroupMessageReactionUncheckedCreateInput = {
    id?: number
    emoji: string
    createdAt?: Date | string
    messageId: number
    userId: string
  }

  export type GroupMessageReactionUpdateInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: VenueGroupMessageUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutGroupMessageReactionsNestedInput
  }

  export type GroupMessageReactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupMessageReactionCreateManyInput = {
    id?: number
    emoji: string
    createdAt?: Date | string
    messageId: number
    userId: string
  }

  export type GroupMessageReactionUpdateManyMutationInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageReactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckInHistoryCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCheckInHistoryInput
    venue: VenueCreateNestedOneWithoutCheckInHistoryInput
  }

  export type CheckInHistoryUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    venueId: number
  }

  export type CheckInHistoryUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCheckInHistoryNestedInput
    venue?: VenueUpdateOneRequiredWithoutCheckInHistoryNestedInput
  }

  export type CheckInHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInHistoryCreateManyInput = {
    id?: number
    createdAt?: Date | string
    userId: string
    venueId: number
  }

  export type CheckInHistoryUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckInHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type BadgeCreateInput = {
    code: string
    name: string
    description: string
    iconUrl: string
    checkValue?: number | null
    createdAt?: Date | string
    rule?: BadgeRuleCreateNestedOneWithoutBadgesInput
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description: string
    iconUrl: string
    ruleId?: number | null
    checkValue?: number | null
    createdAt?: Date | string
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: BadgeRuleUpdateOneWithoutBadgesNestedInput
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    ruleId?: NullableIntFieldUpdateOperationsInput | number | null
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: number
    code: string
    name: string
    description: string
    iconUrl: string
    ruleId?: number | null
    checkValue?: number | null
    createdAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    ruleId?: NullableIntFieldUpdateOperationsInput | number | null
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateInput = {
    userId: string
    badgeId: number
    createdAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    userId: string
    badgeId: number
    createdAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    badgeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeRuleCreateInput = {
    code: string
    name: string
    description: string
    triggerAction: string
    badges?: BadgeCreateNestedManyWithoutRuleInput
  }

  export type BadgeRuleUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    description: string
    triggerAction: string
    badges?: BadgeUncheckedCreateNestedManyWithoutRuleInput
  }

  export type BadgeRuleUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    triggerAction?: StringFieldUpdateOperationsInput | string
    badges?: BadgeUpdateManyWithoutRuleNestedInput
  }

  export type BadgeRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    triggerAction?: StringFieldUpdateOperationsInput | string
    badges?: BadgeUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type BadgeRuleCreateManyInput = {
    id?: number
    code: string
    name: string
    description: string
    triggerAction: string
  }

  export type BadgeRuleUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    triggerAction?: StringFieldUpdateOperationsInput | string
  }

  export type BadgeRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    triggerAction?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeTemplateCreateInput = {
    name: string
    description: string
    iconUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    instances?: ChallengeInstanceCreateNestedManyWithoutTemplateInput
  }

  export type ChallengeTemplateUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    iconUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    instances?: ChallengeInstanceUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ChallengeTemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: ChallengeInstanceUpdateManyWithoutTemplateNestedInput
  }

  export type ChallengeTemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instances?: ChallengeInstanceUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ChallengeTemplateCreateManyInput = {
    id?: number
    name: string
    description: string
    iconUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChallengeTemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeTemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceCreateInput = {
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template: ChallengeTemplateCreateNestedOneWithoutInstancesInput
    challenger: UserCreateNestedOneWithoutSentChallengesInput
    challenged: UserCreateNestedOneWithoutReceivedChallengesInput
    connection: ConnectionCreateNestedOneWithoutChallengesInput
    venue: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeInstanceUncheckedCreateInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceUpdateInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ChallengeTemplateUpdateOneRequiredWithoutInstancesNestedInput
    challenger?: UserUpdateOneRequiredWithoutSentChallengesNestedInput
    challenged?: UserUpdateOneRequiredWithoutReceivedChallengesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutChallengesNestedInput
    venue?: VenueUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeInstanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceCreateManyInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceUpdateManyMutationInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumOptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OptionType[]
    notIn?: $Enums.OptionType[]
    not?: NestedEnumOptionTypeFilter<$PrismaModel> | $Enums.OptionType
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOptionOrderByRelevanceInput = {
    fields: ProfileOptionOrderByRelevanceFieldEnum | ProfileOptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProfileOptionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type ProfileOptionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProfileOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type ProfileOptionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type ProfileOptionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumOptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OptionType[]
    notIn?: $Enums.OptionType[]
    not?: NestedEnumOptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.OptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptionTypeFilter<$PrismaModel>
    _max?: NestedEnumOptionTypeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[]
    notIn?: $Enums.AuthProvider[]
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type ActiveSessionNullableScalarRelationFilter = {
    is?: ActiveSessionWhereInput | null
    isNot?: ActiveSessionWhereInput | null
  }

  export type SignalListRelationFilter = {
    every?: SignalWhereInput
    some?: SignalWhereInput
    none?: SignalWhereInput
  }

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput
    some?: ConnectionWhereInput
    none?: ConnectionWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type BroadcastNotificationListRelationFilter = {
    every?: BroadcastNotificationWhereInput
    some?: BroadcastNotificationWhereInput
    none?: BroadcastNotificationWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type ProfileViewListRelationFilter = {
    every?: ProfileViewWhereInput
    some?: ProfileViewWhereInput
    none?: ProfileViewWhereInput
  }

  export type VenueGroupMessageListRelationFilter = {
    every?: VenueGroupMessageWhereInput
    some?: VenueGroupMessageWhereInput
    none?: VenueGroupMessageWhereInput
  }

  export type AccountDeletionTokenNullableScalarRelationFilter = {
    is?: AccountDeletionTokenWhereInput | null
    isNot?: AccountDeletionTokenWhereInput | null
  }

  export type EmailChangeTokenNullableScalarRelationFilter = {
    is?: EmailChangeTokenWhereInput | null
    isNot?: EmailChangeTokenWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type GroupMessageReactionListRelationFilter = {
    every?: GroupMessageReactionWhereInput
    some?: GroupMessageReactionWhereInput
    none?: GroupMessageReactionWhereInput
  }

  export type CheckInHistoryListRelationFilter = {
    every?: CheckInHistoryWhereInput
    some?: CheckInHistoryWhereInput
    none?: CheckInHistoryWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type ChallengeInstanceListRelationFilter = {
    every?: ChallengeInstanceWhereInput
    some?: ChallengeInstanceWhereInput
    none?: ChallengeInstanceWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SignalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BroadcastNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueGroupMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupMessageReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckInHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    subscription?: SortOrder
    subscriptionExpiresAt?: SortOrder
    premiumExpiresAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    subscription?: SortOrder
    subscriptionExpiresAt?: SortOrder
    premiumExpiresAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    authProvider?: SortOrder
    googleId?: SortOrder
    appleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    subscription?: SortOrder
    subscriptionExpiresAt?: SortOrder
    premiumExpiresAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[]
    notIn?: $Enums.AuthProvider[]
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPersonalityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | null
    notIn?: $Enums.PersonalityType[] | null
    not?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel> | $Enums.PersonalityType | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type InterestListRelationFilter = {
    every?: InterestWhereInput
    some?: InterestWhereInput
    none?: InterestWhereInput
  }

  export type PhotoListRelationFilter = {
    every?: PhotoWhereInput
    some?: PhotoWhereInput
    none?: PhotoWhereInput
  }

  export type ProfileOptionNullableScalarRelationFilter = {
    is?: ProfileOptionWhereInput | null
    isNot?: ProfileOptionWhereInput | null
  }

  export type InterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileOrderByRelevanceInput = {
    fields: ProfileOrderByRelevanceFieldEnum | ProfileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    university?: SortOrder
    city?: SortOrder
    personality?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    extraSignalCredits?: SortOrder
    hideViewFootprints?: SortOrder
    preferredMinAge?: SortOrder
    preferredMaxAge?: SortOrder
    notifyOnNewSignal?: SortOrder
    notifyOnNewMatch?: SortOrder
    notifyOnNewMessage?: SortOrder
    isVerified?: SortOrder
    verificationStatus?: SortOrder
    verificationPhotoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provisionalSignalsUsed?: SortOrder
    currentStatus?: SortOrder
    statusExpiresAt?: SortOrder
    sexualOrientationId?: SortOrder
    relationshipGoalId?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    age?: SortOrder
    extraSignalCredits?: SortOrder
    preferredMinAge?: SortOrder
    preferredMaxAge?: SortOrder
    provisionalSignalsUsed?: SortOrder
    sexualOrientationId?: SortOrder
    relationshipGoalId?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    university?: SortOrder
    city?: SortOrder
    personality?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    extraSignalCredits?: SortOrder
    hideViewFootprints?: SortOrder
    preferredMinAge?: SortOrder
    preferredMaxAge?: SortOrder
    notifyOnNewSignal?: SortOrder
    notifyOnNewMatch?: SortOrder
    notifyOnNewMessage?: SortOrder
    isVerified?: SortOrder
    verificationStatus?: SortOrder
    verificationPhotoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provisionalSignalsUsed?: SortOrder
    currentStatus?: SortOrder
    statusExpiresAt?: SortOrder
    sexualOrientationId?: SortOrder
    relationshipGoalId?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    university?: SortOrder
    city?: SortOrder
    personality?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    extraSignalCredits?: SortOrder
    hideViewFootprints?: SortOrder
    preferredMinAge?: SortOrder
    preferredMaxAge?: SortOrder
    notifyOnNewSignal?: SortOrder
    notifyOnNewMatch?: SortOrder
    notifyOnNewMessage?: SortOrder
    isVerified?: SortOrder
    verificationStatus?: SortOrder
    verificationPhotoUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provisionalSignalsUsed?: SortOrder
    currentStatus?: SortOrder
    statusExpiresAt?: SortOrder
    sexualOrientationId?: SortOrder
    relationshipGoalId?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    age?: SortOrder
    extraSignalCredits?: SortOrder
    preferredMinAge?: SortOrder
    preferredMaxAge?: SortOrder
    provisionalSignalsUsed?: SortOrder
    sexualOrientationId?: SortOrder
    relationshipGoalId?: SortOrder
  }

  export type EnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | null
    notIn?: $Enums.PersonalityType[] | null
    not?: NestedEnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PersonalityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type CategoryOrderByRelevanceInput = {
    fields: CategoryOrderByRelevanceFieldEnum | CategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type InterestOrderByRelevanceInput = {
    fields: InterestOrderByRelevanceFieldEnum | InterestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InterestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
  }

  export type InterestAvgOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type InterestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
  }

  export type InterestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    categoryId?: SortOrder
  }

  export type InterestSumOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumVenueCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueCategory | EnumVenueCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VenueCategory[]
    notIn?: $Enums.VenueCategory[]
    not?: NestedEnumVenueCategoryFilter<$PrismaModel> | $Enums.VenueCategory
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActiveSessionListRelationFilter = {
    every?: ActiveSessionWhereInput
    some?: ActiveSessionWhereInput
    none?: ActiveSessionWhereInput
  }

  export type ActiveSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueOrderByRelevanceInput = {
    fields: VenueOrderByRelevanceFieldEnum | VenueOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    category?: SortOrder
    statsSummary?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    category?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    description?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isActive?: SortOrder
    isFeatured?: SortOrder
    category?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumVenueCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueCategory | EnumVenueCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VenueCategory[]
    notIn?: $Enums.VenueCategory[]
    not?: NestedEnumVenueCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VenueCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVenueCategoryFilter<$PrismaModel>
    _max?: NestedEnumVenueCategoryFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type VenueScalarRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type ActiveSessionOrderByRelevanceInput = {
    fields: ActiveSessionOrderByRelevanceFieldEnum | ActiveSessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActiveSessionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isIncognito?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
  }

  export type ActiveSessionAvgOrderByAggregateInput = {
    venueId?: SortOrder
  }

  export type ActiveSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isIncognito?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
  }

  export type ActiveSessionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    isIncognito?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
  }

  export type ActiveSessionSumOrderByAggregateInput = {
    venueId?: SortOrder
  }

  export type SignalOrderByRelevanceInput = {
    fields: SignalOrderByRelevanceFieldEnum | SignalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SignalSenderIdReceiverIdCompoundUniqueInput = {
    senderId: string
    receiverId: string
  }

  export type SignalCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type SignalAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SignalMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type SignalMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type SignalSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConnectionOrderByRelevanceInput = {
    fields: ConnectionOrderByRelevanceFieldEnum | ConnectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ConnectionUserAIdUserBIdCompoundUniqueInput = {
    userAId: string
    userBId: string
  }

  export type ConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
  }

  export type ConnectionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
  }

  export type ConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
  }

  export type ConnectionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConnectionScalarRelationFilter = {
    is?: ConnectionWhereInput
    isNot?: ConnectionWhereInput
  }

  export type MessageOrderByRelevanceInput = {
    fields: MessageOrderByRelevanceFieldEnum | MessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    connectionId?: SortOrder
    isRead?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    connectionId?: SortOrder
    isRead?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    createdAt?: SortOrder
    senderId?: SortOrder
    connectionId?: SortOrder
    isRead?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
  }

  export type BlockOrderByRelevanceInput = {
    fields: BlockOrderByRelevanceFieldEnum | BlockOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BlockBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: string
    blockedId: string
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type BlockAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type BlockSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type VenueGroupMessageNullableScalarRelationFilter = {
    is?: VenueGroupMessageWhereInput | null
    isNot?: VenueGroupMessageWhereInput | null
  }

  export type ReportOrderByRelevanceInput = {
    fields: ReportOrderByRelevanceFieldEnum | ReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedMessageId?: SortOrder
    reportedGroupMessageId?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    reportedMessageId?: SortOrder
    reportedGroupMessageId?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedMessageId?: SortOrder
    reportedGroupMessageId?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporterId?: SortOrder
    reportedUserId?: SortOrder
    reportedMessageId?: SortOrder
    reportedGroupMessageId?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    reportedMessageId?: SortOrder
    reportedGroupMessageId?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type DeviceOrderByRelevanceInput = {
    fields: DeviceOrderByRelevanceFieldEnum | DeviceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DeviceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DeviceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationOrderByRelevanceInput = {
    fields: NotificationOrderByRelevanceFieldEnum | NotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FeedbackOrderByRelevanceInput = {
    fields: FeedbackOrderByRelevanceFieldEnum | FeedbackOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    screenshotUrl?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    screenshotUrl?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    screenshotUrl?: SortOrder
    createdAt?: SortOrder
    authorId?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogOrderByRelevanceInput = {
    fields: AuditLogOrderByRelevanceFieldEnum | AuditLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BroadcastNotificationOrderByRelevanceInput = {
    fields: BroadcastNotificationOrderByRelevanceFieldEnum | BroadcastNotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BroadcastNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    sentById?: SortOrder
  }

  export type BroadcastNotificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BroadcastNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    sentById?: SortOrder
  }

  export type BroadcastNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    sentById?: SortOrder
  }

  export type BroadcastNotificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PasswordResetTokenOrderByRelevanceInput = {
    fields: PasswordResetTokenOrderByRelevanceFieldEnum | PasswordResetTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type PasswordResetTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type PhotoOrderByRelevanceInput = {
    fields: PhotoOrderByRelevanceFieldEnum | PhotoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    isAvatar?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
  }

  export type PhotoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    isAvatar?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    isAvatar?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
  }

  export type PhotoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumIcebreakerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IcebreakerCategory | EnumIcebreakerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IcebreakerCategory[]
    notIn?: $Enums.IcebreakerCategory[]
    not?: NestedEnumIcebreakerCategoryFilter<$PrismaModel> | $Enums.IcebreakerCategory
  }

  export type IcebreakerQuestionOrderByRelevanceInput = {
    fields: IcebreakerQuestionOrderByRelevanceFieldEnum | IcebreakerQuestionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type IcebreakerQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type IcebreakerQuestionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IcebreakerQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type IcebreakerQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type IcebreakerQuestionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumIcebreakerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IcebreakerCategory | EnumIcebreakerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IcebreakerCategory[]
    notIn?: $Enums.IcebreakerCategory[]
    not?: NestedEnumIcebreakerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IcebreakerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIcebreakerCategoryFilter<$PrismaModel>
    _max?: NestedEnumIcebreakerCategoryFilter<$PrismaModel>
  }

  export type ProfileViewOrderByRelevanceInput = {
    fields: ProfileViewOrderByRelevanceFieldEnum | ProfileViewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProfileViewViewerIdViewedIdCompoundUniqueInput = {
    viewerId: string
    viewedId: string
  }

  export type ProfileViewCountOrderByAggregateInput = {
    id?: SortOrder
    viewerId?: SortOrder
    viewedId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileViewAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProfileViewMaxOrderByAggregateInput = {
    id?: SortOrder
    viewerId?: SortOrder
    viewedId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileViewMinOrderByAggregateInput = {
    id?: SortOrder
    viewerId?: SortOrder
    viewedId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileViewSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VenueGroupMessageOrderByRelevanceInput = {
    fields: VenueGroupMessageOrderByRelevanceFieldEnum | VenueGroupMessageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VenueGroupMessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    venueId?: SortOrder
    senderId?: SortOrder
  }

  export type VenueGroupMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
  }

  export type VenueGroupMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    venueId?: SortOrder
    senderId?: SortOrder
  }

  export type VenueGroupMessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    imageUrl?: SortOrder
    audioUrl?: SortOrder
    videoUrl?: SortOrder
    createdAt?: SortOrder
    venueId?: SortOrder
    senderId?: SortOrder
  }

  export type VenueGroupMessageSumOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
  }

  export type AccountDeletionTokenOrderByRelevanceInput = {
    fields: AccountDeletionTokenOrderByRelevanceFieldEnum | AccountDeletionTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountDeletionTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AccountDeletionTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountDeletionTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AccountDeletionTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type AccountDeletionTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailChangeTokenOrderByRelevanceInput = {
    fields: EmailChangeTokenOrderByRelevanceFieldEnum | EmailChangeTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmailChangeTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    newEmail?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EmailChangeTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmailChangeTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    newEmail?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EmailChangeTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    newEmail?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EmailChangeTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RefreshTokenOrderByRelevanceInput = {
    fields: RefreshTokenOrderByRelevanceFieldEnum | RefreshTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VenueGroupMessageScalarRelationFilter = {
    is?: VenueGroupMessageWhereInput
    isNot?: VenueGroupMessageWhereInput
  }

  export type GroupMessageReactionOrderByRelevanceInput = {
    fields: GroupMessageReactionOrderByRelevanceFieldEnum | GroupMessageReactionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GroupMessageReactionMessageIdUserIdEmojiCompoundUniqueInput = {
    messageId: number
    userId: string
    emoji: string
  }

  export type GroupMessageReactionCountOrderByAggregateInput = {
    id?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
  }

  export type GroupMessageReactionAvgOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
  }

  export type GroupMessageReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
  }

  export type GroupMessageReactionMinOrderByAggregateInput = {
    id?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
  }

  export type GroupMessageReactionSumOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
  }

  export type CheckInHistoryOrderByRelevanceInput = {
    fields: CheckInHistoryOrderByRelevanceFieldEnum | CheckInHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CheckInHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
  }

  export type CheckInHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
  }

  export type CheckInHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
  }

  export type CheckInHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    venueId?: SortOrder
  }

  export type CheckInHistorySumOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
  }

  export type BadgeRuleNullableScalarRelationFilter = {
    is?: BadgeRuleWhereInput | null
    isNot?: BadgeRuleWhereInput | null
  }

  export type BadgeOrderByRelevanceInput = {
    fields: BadgeOrderByRelevanceFieldEnum | BadgeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    ruleId?: SortOrder
    checkValue?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    checkValue?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    ruleId?: SortOrder
    checkValue?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    ruleId?: SortOrder
    checkValue?: SortOrder
    createdAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    id?: SortOrder
    ruleId?: SortOrder
    checkValue?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeOrderByRelevanceInput = {
    fields: UserBadgeOrderByRelevanceFieldEnum | UserBadgeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserBadgeUserIdBadgeIdCompoundUniqueInput = {
    userId: string
    badgeId: number
  }

  export type UserBadgeCountOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBadgeAvgOrderByAggregateInput = {
    badgeId?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    userId?: SortOrder
    badgeId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBadgeSumOrderByAggregateInput = {
    badgeId?: SortOrder
  }

  export type BadgeListRelationFilter = {
    every?: BadgeWhereInput
    some?: BadgeWhereInput
    none?: BadgeWhereInput
  }

  export type BadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BadgeRuleOrderByRelevanceInput = {
    fields: BadgeRuleOrderByRelevanceFieldEnum | BadgeRuleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BadgeRuleCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerAction?: SortOrder
  }

  export type BadgeRuleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BadgeRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerAction?: SortOrder
  }

  export type BadgeRuleMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerAction?: SortOrder
  }

  export type BadgeRuleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChallengeTemplateOrderByRelevanceInput = {
    fields: ChallengeTemplateOrderByRelevanceFieldEnum | ChallengeTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeTemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChallengeTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeTemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumChallengeInstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeInstanceStatus | EnumChallengeInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeInstanceStatus[]
    notIn?: $Enums.ChallengeInstanceStatus[]
    not?: NestedEnumChallengeInstanceStatusFilter<$PrismaModel> | $Enums.ChallengeInstanceStatus
  }

  export type ChallengeTemplateScalarRelationFilter = {
    is?: ChallengeTemplateWhereInput
    isNot?: ChallengeTemplateWhereInput
  }

  export type ChallengeInstanceOrderByRelevanceInput = {
    fields: ChallengeInstanceOrderByRelevanceFieldEnum | ChallengeInstanceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ChallengeInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    challengeTime?: SortOrder
    templateId?: SortOrder
    challengerId?: SortOrder
    challengedId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
    challengerCheckedIn?: SortOrder
    challengedCheckedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeInstanceAvgOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
  }

  export type ChallengeInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    challengeTime?: SortOrder
    templateId?: SortOrder
    challengerId?: SortOrder
    challengedId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
    challengerCheckedIn?: SortOrder
    challengedCheckedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    challengeTime?: SortOrder
    templateId?: SortOrder
    challengerId?: SortOrder
    challengedId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
    challengerCheckedIn?: SortOrder
    challengedCheckedIn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeInstanceSumOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    connectionId?: SortOrder
    venueId?: SortOrder
  }

  export type EnumChallengeInstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeInstanceStatus | EnumChallengeInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeInstanceStatus[]
    notIn?: $Enums.ChallengeInstanceStatus[]
    not?: NestedEnumChallengeInstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeInstanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeInstanceStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeInstanceStatusFilter<$PrismaModel>
  }

  export type ProfileCreateNestedManyWithoutSexualOrientationInput = {
    create?: XOR<ProfileCreateWithoutSexualOrientationInput, ProfileUncheckedCreateWithoutSexualOrientationInput> | ProfileCreateWithoutSexualOrientationInput[] | ProfileUncheckedCreateWithoutSexualOrientationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutSexualOrientationInput | ProfileCreateOrConnectWithoutSexualOrientationInput[]
    createMany?: ProfileCreateManySexualOrientationInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProfileCreateNestedManyWithoutRelationshipGoalInput = {
    create?: XOR<ProfileCreateWithoutRelationshipGoalInput, ProfileUncheckedCreateWithoutRelationshipGoalInput> | ProfileCreateWithoutRelationshipGoalInput[] | ProfileUncheckedCreateWithoutRelationshipGoalInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutRelationshipGoalInput | ProfileCreateOrConnectWithoutRelationshipGoalInput[]
    createMany?: ProfileCreateManyRelationshipGoalInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutSexualOrientationInput = {
    create?: XOR<ProfileCreateWithoutSexualOrientationInput, ProfileUncheckedCreateWithoutSexualOrientationInput> | ProfileCreateWithoutSexualOrientationInput[] | ProfileUncheckedCreateWithoutSexualOrientationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutSexualOrientationInput | ProfileCreateOrConnectWithoutSexualOrientationInput[]
    createMany?: ProfileCreateManySexualOrientationInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutRelationshipGoalInput = {
    create?: XOR<ProfileCreateWithoutRelationshipGoalInput, ProfileUncheckedCreateWithoutRelationshipGoalInput> | ProfileCreateWithoutRelationshipGoalInput[] | ProfileUncheckedCreateWithoutRelationshipGoalInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutRelationshipGoalInput | ProfileCreateOrConnectWithoutRelationshipGoalInput[]
    createMany?: ProfileCreateManyRelationshipGoalInputEnvelope
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type EnumOptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.OptionType
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ProfileUpdateManyWithoutSexualOrientationNestedInput = {
    create?: XOR<ProfileCreateWithoutSexualOrientationInput, ProfileUncheckedCreateWithoutSexualOrientationInput> | ProfileCreateWithoutSexualOrientationInput[] | ProfileUncheckedCreateWithoutSexualOrientationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutSexualOrientationInput | ProfileCreateOrConnectWithoutSexualOrientationInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutSexualOrientationInput | ProfileUpsertWithWhereUniqueWithoutSexualOrientationInput[]
    createMany?: ProfileCreateManySexualOrientationInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutSexualOrientationInput | ProfileUpdateWithWhereUniqueWithoutSexualOrientationInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutSexualOrientationInput | ProfileUpdateManyWithWhereWithoutSexualOrientationInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ProfileUpdateManyWithoutRelationshipGoalNestedInput = {
    create?: XOR<ProfileCreateWithoutRelationshipGoalInput, ProfileUncheckedCreateWithoutRelationshipGoalInput> | ProfileCreateWithoutRelationshipGoalInput[] | ProfileUncheckedCreateWithoutRelationshipGoalInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutRelationshipGoalInput | ProfileCreateOrConnectWithoutRelationshipGoalInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutRelationshipGoalInput | ProfileUpsertWithWhereUniqueWithoutRelationshipGoalInput[]
    createMany?: ProfileCreateManyRelationshipGoalInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutRelationshipGoalInput | ProfileUpdateWithWhereUniqueWithoutRelationshipGoalInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutRelationshipGoalInput | ProfileUpdateManyWithWhereWithoutRelationshipGoalInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUncheckedUpdateManyWithoutSexualOrientationNestedInput = {
    create?: XOR<ProfileCreateWithoutSexualOrientationInput, ProfileUncheckedCreateWithoutSexualOrientationInput> | ProfileCreateWithoutSexualOrientationInput[] | ProfileUncheckedCreateWithoutSexualOrientationInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutSexualOrientationInput | ProfileCreateOrConnectWithoutSexualOrientationInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutSexualOrientationInput | ProfileUpsertWithWhereUniqueWithoutSexualOrientationInput[]
    createMany?: ProfileCreateManySexualOrientationInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutSexualOrientationInput | ProfileUpdateWithWhereUniqueWithoutSexualOrientationInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutSexualOrientationInput | ProfileUpdateManyWithWhereWithoutSexualOrientationInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutRelationshipGoalNestedInput = {
    create?: XOR<ProfileCreateWithoutRelationshipGoalInput, ProfileUncheckedCreateWithoutRelationshipGoalInput> | ProfileCreateWithoutRelationshipGoalInput[] | ProfileUncheckedCreateWithoutRelationshipGoalInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutRelationshipGoalInput | ProfileCreateOrConnectWithoutRelationshipGoalInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutRelationshipGoalInput | ProfileUpsertWithWhereUniqueWithoutRelationshipGoalInput[]
    createMany?: ProfileCreateManyRelationshipGoalInputEnvelope
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutRelationshipGoalInput | ProfileUpdateWithWhereUniqueWithoutRelationshipGoalInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutRelationshipGoalInput | ProfileUpdateManyWithWhereWithoutRelationshipGoalInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type ActiveSessionCreateNestedOneWithoutUserInput = {
    create?: XOR<ActiveSessionCreateWithoutUserInput, ActiveSessionUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutUserInput
    connect?: ActiveSessionWhereUniqueInput
  }

  export type SignalCreateNestedManyWithoutSenderInput = {
    create?: XOR<SignalCreateWithoutSenderInput, SignalUncheckedCreateWithoutSenderInput> | SignalCreateWithoutSenderInput[] | SignalUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutSenderInput | SignalCreateOrConnectWithoutSenderInput[]
    createMany?: SignalCreateManySenderInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type SignalCreateNestedManyWithoutReceiverInput = {
    create?: XOR<SignalCreateWithoutReceiverInput, SignalUncheckedCreateWithoutReceiverInput> | SignalCreateWithoutReceiverInput[] | SignalUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutReceiverInput | SignalCreateOrConnectWithoutReceiverInput[]
    createMany?: SignalCreateManyReceiverInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutUserAInput = {
    create?: XOR<ConnectionCreateWithoutUserAInput, ConnectionUncheckedCreateWithoutUserAInput> | ConnectionCreateWithoutUserAInput[] | ConnectionUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserAInput | ConnectionCreateOrConnectWithoutUserAInput[]
    createMany?: ConnectionCreateManyUserAInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutUserBInput = {
    create?: XOR<ConnectionCreateWithoutUserBInput, ConnectionUncheckedCreateWithoutUserBInput> | ConnectionCreateWithoutUserBInput[] | ConnectionUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserBInput | ConnectionCreateOrConnectWithoutUserBInput[]
    createMany?: ConnectionCreateManyUserBInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type DeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutAuthorInput = {
    create?: XOR<FeedbackCreateWithoutAuthorInput, FeedbackUncheckedCreateWithoutAuthorInput> | FeedbackCreateWithoutAuthorInput[] | FeedbackUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutAuthorInput | FeedbackCreateOrConnectWithoutAuthorInput[]
    createMany?: FeedbackCreateManyAuthorInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BroadcastNotificationCreateNestedManyWithoutSentByInput = {
    create?: XOR<BroadcastNotificationCreateWithoutSentByInput, BroadcastNotificationUncheckedCreateWithoutSentByInput> | BroadcastNotificationCreateWithoutSentByInput[] | BroadcastNotificationUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: BroadcastNotificationCreateOrConnectWithoutSentByInput | BroadcastNotificationCreateOrConnectWithoutSentByInput[]
    createMany?: BroadcastNotificationCreateManySentByInputEnvelope
    connect?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ProfileViewCreateNestedManyWithoutViewerInput = {
    create?: XOR<ProfileViewCreateWithoutViewerInput, ProfileViewUncheckedCreateWithoutViewerInput> | ProfileViewCreateWithoutViewerInput[] | ProfileViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewerInput | ProfileViewCreateOrConnectWithoutViewerInput[]
    createMany?: ProfileViewCreateManyViewerInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type ProfileViewCreateNestedManyWithoutViewedInput = {
    create?: XOR<ProfileViewCreateWithoutViewedInput, ProfileViewUncheckedCreateWithoutViewedInput> | ProfileViewCreateWithoutViewedInput[] | ProfileViewUncheckedCreateWithoutViewedInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedInput | ProfileViewCreateOrConnectWithoutViewedInput[]
    createMany?: ProfileViewCreateManyViewedInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type VenueGroupMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<VenueGroupMessageCreateWithoutSenderInput, VenueGroupMessageUncheckedCreateWithoutSenderInput> | VenueGroupMessageCreateWithoutSenderInput[] | VenueGroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutSenderInput | VenueGroupMessageCreateOrConnectWithoutSenderInput[]
    createMany?: VenueGroupMessageCreateManySenderInputEnvelope
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
  }

  export type AccountDeletionTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountDeletionTokenCreateWithoutUserInput, AccountDeletionTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountDeletionTokenCreateOrConnectWithoutUserInput
    connect?: AccountDeletionTokenWhereUniqueInput
  }

  export type EmailChangeTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailChangeTokenCreateWithoutUserInput, EmailChangeTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailChangeTokenCreateOrConnectWithoutUserInput
    connect?: EmailChangeTokenWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type GroupMessageReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMessageReactionCreateWithoutUserInput, GroupMessageReactionUncheckedCreateWithoutUserInput> | GroupMessageReactionCreateWithoutUserInput[] | GroupMessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutUserInput | GroupMessageReactionCreateOrConnectWithoutUserInput[]
    createMany?: GroupMessageReactionCreateManyUserInputEnvelope
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
  }

  export type CheckInHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CheckInHistoryCreateWithoutUserInput, CheckInHistoryUncheckedCreateWithoutUserInput> | CheckInHistoryCreateWithoutUserInput[] | CheckInHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutUserInput | CheckInHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CheckInHistoryCreateManyUserInputEnvelope
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type ChallengeInstanceCreateNestedManyWithoutChallengerInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengerInput, ChallengeInstanceUncheckedCreateWithoutChallengerInput> | ChallengeInstanceCreateWithoutChallengerInput[] | ChallengeInstanceUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengerInput | ChallengeInstanceCreateOrConnectWithoutChallengerInput[]
    createMany?: ChallengeInstanceCreateManyChallengerInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type ChallengeInstanceCreateNestedManyWithoutChallengedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengedInput, ChallengeInstanceUncheckedCreateWithoutChallengedInput> | ChallengeInstanceCreateWithoutChallengedInput[] | ChallengeInstanceUncheckedCreateWithoutChallengedInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengedInput | ChallengeInstanceCreateOrConnectWithoutChallengedInput[]
    createMany?: ChallengeInstanceCreateManyChallengedInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type ActiveSessionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ActiveSessionCreateWithoutUserInput, ActiveSessionUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutUserInput
    connect?: ActiveSessionWhereUniqueInput
  }

  export type SignalUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<SignalCreateWithoutSenderInput, SignalUncheckedCreateWithoutSenderInput> | SignalCreateWithoutSenderInput[] | SignalUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutSenderInput | SignalCreateOrConnectWithoutSenderInput[]
    createMany?: SignalCreateManySenderInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type SignalUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<SignalCreateWithoutReceiverInput, SignalUncheckedCreateWithoutReceiverInput> | SignalCreateWithoutReceiverInput[] | SignalUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutReceiverInput | SignalCreateOrConnectWithoutReceiverInput[]
    createMany?: SignalCreateManyReceiverInputEnvelope
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutUserAInput = {
    create?: XOR<ConnectionCreateWithoutUserAInput, ConnectionUncheckedCreateWithoutUserAInput> | ConnectionCreateWithoutUserAInput[] | ConnectionUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserAInput | ConnectionCreateOrConnectWithoutUserAInput[]
    createMany?: ConnectionCreateManyUserAInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutUserBInput = {
    create?: XOR<ConnectionCreateWithoutUserBInput, ConnectionUncheckedCreateWithoutUserBInput> | ConnectionCreateWithoutUserBInput[] | ConnectionUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserBInput | ConnectionCreateOrConnectWithoutUserBInput[]
    createMany?: ConnectionCreateManyUserBInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedUserInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<FeedbackCreateWithoutAuthorInput, FeedbackUncheckedCreateWithoutAuthorInput> | FeedbackCreateWithoutAuthorInput[] | FeedbackUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutAuthorInput | FeedbackCreateOrConnectWithoutAuthorInput[]
    createMany?: FeedbackCreateManyAuthorInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput = {
    create?: XOR<BroadcastNotificationCreateWithoutSentByInput, BroadcastNotificationUncheckedCreateWithoutSentByInput> | BroadcastNotificationCreateWithoutSentByInput[] | BroadcastNotificationUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: BroadcastNotificationCreateOrConnectWithoutSentByInput | BroadcastNotificationCreateOrConnectWithoutSentByInput[]
    createMany?: BroadcastNotificationCreateManySentByInputEnvelope
    connect?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type ProfileViewUncheckedCreateNestedManyWithoutViewerInput = {
    create?: XOR<ProfileViewCreateWithoutViewerInput, ProfileViewUncheckedCreateWithoutViewerInput> | ProfileViewCreateWithoutViewerInput[] | ProfileViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewerInput | ProfileViewCreateOrConnectWithoutViewerInput[]
    createMany?: ProfileViewCreateManyViewerInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type ProfileViewUncheckedCreateNestedManyWithoutViewedInput = {
    create?: XOR<ProfileViewCreateWithoutViewedInput, ProfileViewUncheckedCreateWithoutViewedInput> | ProfileViewCreateWithoutViewedInput[] | ProfileViewUncheckedCreateWithoutViewedInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedInput | ProfileViewCreateOrConnectWithoutViewedInput[]
    createMany?: ProfileViewCreateManyViewedInputEnvelope
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
  }

  export type VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<VenueGroupMessageCreateWithoutSenderInput, VenueGroupMessageUncheckedCreateWithoutSenderInput> | VenueGroupMessageCreateWithoutSenderInput[] | VenueGroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutSenderInput | VenueGroupMessageCreateOrConnectWithoutSenderInput[]
    createMany?: VenueGroupMessageCreateManySenderInputEnvelope
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
  }

  export type AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountDeletionTokenCreateWithoutUserInput, AccountDeletionTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountDeletionTokenCreateOrConnectWithoutUserInput
    connect?: AccountDeletionTokenWhereUniqueInput
  }

  export type EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailChangeTokenCreateWithoutUserInput, EmailChangeTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailChangeTokenCreateOrConnectWithoutUserInput
    connect?: EmailChangeTokenWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GroupMessageReactionCreateWithoutUserInput, GroupMessageReactionUncheckedCreateWithoutUserInput> | GroupMessageReactionCreateWithoutUserInput[] | GroupMessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutUserInput | GroupMessageReactionCreateOrConnectWithoutUserInput[]
    createMany?: GroupMessageReactionCreateManyUserInputEnvelope
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
  }

  export type CheckInHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CheckInHistoryCreateWithoutUserInput, CheckInHistoryUncheckedCreateWithoutUserInput> | CheckInHistoryCreateWithoutUserInput[] | CheckInHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutUserInput | CheckInHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CheckInHistoryCreateManyUserInputEnvelope
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengerInput, ChallengeInstanceUncheckedCreateWithoutChallengerInput> | ChallengeInstanceCreateWithoutChallengerInput[] | ChallengeInstanceUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengerInput | ChallengeInstanceCreateOrConnectWithoutChallengerInput[]
    createMany?: ChallengeInstanceCreateManyChallengerInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengedInput, ChallengeInstanceUncheckedCreateWithoutChallengedInput> | ChallengeInstanceCreateWithoutChallengedInput[] | ChallengeInstanceUncheckedCreateWithoutChallengedInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengedInput | ChallengeInstanceCreateOrConnectWithoutChallengedInput[]
    createMany?: ChallengeInstanceCreateManyChallengedInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumSubscriptionPlanFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionPlan
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ActiveSessionUpdateOneWithoutUserNestedInput = {
    create?: XOR<ActiveSessionCreateWithoutUserInput, ActiveSessionUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutUserInput
    upsert?: ActiveSessionUpsertWithoutUserInput
    disconnect?: ActiveSessionWhereInput | boolean
    delete?: ActiveSessionWhereInput | boolean
    connect?: ActiveSessionWhereUniqueInput
    update?: XOR<XOR<ActiveSessionUpdateToOneWithWhereWithoutUserInput, ActiveSessionUpdateWithoutUserInput>, ActiveSessionUncheckedUpdateWithoutUserInput>
  }

  export type SignalUpdateManyWithoutSenderNestedInput = {
    create?: XOR<SignalCreateWithoutSenderInput, SignalUncheckedCreateWithoutSenderInput> | SignalCreateWithoutSenderInput[] | SignalUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutSenderInput | SignalCreateOrConnectWithoutSenderInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutSenderInput | SignalUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: SignalCreateManySenderInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutSenderInput | SignalUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutSenderInput | SignalUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type SignalUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<SignalCreateWithoutReceiverInput, SignalUncheckedCreateWithoutReceiverInput> | SignalCreateWithoutReceiverInput[] | SignalUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutReceiverInput | SignalCreateOrConnectWithoutReceiverInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutReceiverInput | SignalUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: SignalCreateManyReceiverInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutReceiverInput | SignalUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutReceiverInput | SignalUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutUserANestedInput = {
    create?: XOR<ConnectionCreateWithoutUserAInput, ConnectionUncheckedCreateWithoutUserAInput> | ConnectionCreateWithoutUserAInput[] | ConnectionUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserAInput | ConnectionCreateOrConnectWithoutUserAInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutUserAInput | ConnectionUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: ConnectionCreateManyUserAInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutUserAInput | ConnectionUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutUserAInput | ConnectionUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutUserBNestedInput = {
    create?: XOR<ConnectionCreateWithoutUserBInput, ConnectionUncheckedCreateWithoutUserBInput> | ConnectionCreateWithoutUserBInput[] | ConnectionUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserBInput | ConnectionCreateOrConnectWithoutUserBInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutUserBInput | ConnectionUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: ConnectionCreateManyUserBInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutUserBInput | ConnectionUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutUserBInput | ConnectionUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type DeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<FeedbackCreateWithoutAuthorInput, FeedbackUncheckedCreateWithoutAuthorInput> | FeedbackCreateWithoutAuthorInput[] | FeedbackUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutAuthorInput | FeedbackCreateOrConnectWithoutAuthorInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutAuthorInput | FeedbackUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: FeedbackCreateManyAuthorInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutAuthorInput | FeedbackUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutAuthorInput | FeedbackUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BroadcastNotificationUpdateManyWithoutSentByNestedInput = {
    create?: XOR<BroadcastNotificationCreateWithoutSentByInput, BroadcastNotificationUncheckedCreateWithoutSentByInput> | BroadcastNotificationCreateWithoutSentByInput[] | BroadcastNotificationUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: BroadcastNotificationCreateOrConnectWithoutSentByInput | BroadcastNotificationCreateOrConnectWithoutSentByInput[]
    upsert?: BroadcastNotificationUpsertWithWhereUniqueWithoutSentByInput | BroadcastNotificationUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: BroadcastNotificationCreateManySentByInputEnvelope
    set?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    disconnect?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    delete?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    connect?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    update?: BroadcastNotificationUpdateWithWhereUniqueWithoutSentByInput | BroadcastNotificationUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: BroadcastNotificationUpdateManyWithWhereWithoutSentByInput | BroadcastNotificationUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: BroadcastNotificationScalarWhereInput | BroadcastNotificationScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ProfileViewUpdateManyWithoutViewerNestedInput = {
    create?: XOR<ProfileViewCreateWithoutViewerInput, ProfileViewUncheckedCreateWithoutViewerInput> | ProfileViewCreateWithoutViewerInput[] | ProfileViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewerInput | ProfileViewCreateOrConnectWithoutViewerInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutViewerInput | ProfileViewUpsertWithWhereUniqueWithoutViewerInput[]
    createMany?: ProfileViewCreateManyViewerInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutViewerInput | ProfileViewUpdateWithWhereUniqueWithoutViewerInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutViewerInput | ProfileViewUpdateManyWithWhereWithoutViewerInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type ProfileViewUpdateManyWithoutViewedNestedInput = {
    create?: XOR<ProfileViewCreateWithoutViewedInput, ProfileViewUncheckedCreateWithoutViewedInput> | ProfileViewCreateWithoutViewedInput[] | ProfileViewUncheckedCreateWithoutViewedInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedInput | ProfileViewCreateOrConnectWithoutViewedInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutViewedInput | ProfileViewUpsertWithWhereUniqueWithoutViewedInput[]
    createMany?: ProfileViewCreateManyViewedInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutViewedInput | ProfileViewUpdateWithWhereUniqueWithoutViewedInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutViewedInput | ProfileViewUpdateManyWithWhereWithoutViewedInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type VenueGroupMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<VenueGroupMessageCreateWithoutSenderInput, VenueGroupMessageUncheckedCreateWithoutSenderInput> | VenueGroupMessageCreateWithoutSenderInput[] | VenueGroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutSenderInput | VenueGroupMessageCreateOrConnectWithoutSenderInput[]
    upsert?: VenueGroupMessageUpsertWithWhereUniqueWithoutSenderInput | VenueGroupMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: VenueGroupMessageCreateManySenderInputEnvelope
    set?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    disconnect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    delete?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    update?: VenueGroupMessageUpdateWithWhereUniqueWithoutSenderInput | VenueGroupMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: VenueGroupMessageUpdateManyWithWhereWithoutSenderInput | VenueGroupMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: VenueGroupMessageScalarWhereInput | VenueGroupMessageScalarWhereInput[]
  }

  export type AccountDeletionTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountDeletionTokenCreateWithoutUserInput, AccountDeletionTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountDeletionTokenCreateOrConnectWithoutUserInput
    upsert?: AccountDeletionTokenUpsertWithoutUserInput
    disconnect?: AccountDeletionTokenWhereInput | boolean
    delete?: AccountDeletionTokenWhereInput | boolean
    connect?: AccountDeletionTokenWhereUniqueInput
    update?: XOR<XOR<AccountDeletionTokenUpdateToOneWithWhereWithoutUserInput, AccountDeletionTokenUpdateWithoutUserInput>, AccountDeletionTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailChangeTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailChangeTokenCreateWithoutUserInput, EmailChangeTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailChangeTokenCreateOrConnectWithoutUserInput
    upsert?: EmailChangeTokenUpsertWithoutUserInput
    disconnect?: EmailChangeTokenWhereInput | boolean
    delete?: EmailChangeTokenWhereInput | boolean
    connect?: EmailChangeTokenWhereUniqueInput
    update?: XOR<XOR<EmailChangeTokenUpdateToOneWithWhereWithoutUserInput, EmailChangeTokenUpdateWithoutUserInput>, EmailChangeTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type GroupMessageReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMessageReactionCreateWithoutUserInput, GroupMessageReactionUncheckedCreateWithoutUserInput> | GroupMessageReactionCreateWithoutUserInput[] | GroupMessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutUserInput | GroupMessageReactionCreateOrConnectWithoutUserInput[]
    upsert?: GroupMessageReactionUpsertWithWhereUniqueWithoutUserInput | GroupMessageReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMessageReactionCreateManyUserInputEnvelope
    set?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    disconnect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    delete?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    update?: GroupMessageReactionUpdateWithWhereUniqueWithoutUserInput | GroupMessageReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMessageReactionUpdateManyWithWhereWithoutUserInput | GroupMessageReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMessageReactionScalarWhereInput | GroupMessageReactionScalarWhereInput[]
  }

  export type CheckInHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CheckInHistoryCreateWithoutUserInput, CheckInHistoryUncheckedCreateWithoutUserInput> | CheckInHistoryCreateWithoutUserInput[] | CheckInHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutUserInput | CheckInHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CheckInHistoryUpsertWithWhereUniqueWithoutUserInput | CheckInHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CheckInHistoryCreateManyUserInputEnvelope
    set?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    disconnect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    delete?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    update?: CheckInHistoryUpdateWithWhereUniqueWithoutUserInput | CheckInHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CheckInHistoryUpdateManyWithWhereWithoutUserInput | CheckInHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CheckInHistoryScalarWhereInput | CheckInHistoryScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type ChallengeInstanceUpdateManyWithoutChallengerNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengerInput, ChallengeInstanceUncheckedCreateWithoutChallengerInput> | ChallengeInstanceCreateWithoutChallengerInput[] | ChallengeInstanceUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengerInput | ChallengeInstanceCreateOrConnectWithoutChallengerInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutChallengerInput | ChallengeInstanceUpsertWithWhereUniqueWithoutChallengerInput[]
    createMany?: ChallengeInstanceCreateManyChallengerInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutChallengerInput | ChallengeInstanceUpdateWithWhereUniqueWithoutChallengerInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutChallengerInput | ChallengeInstanceUpdateManyWithWhereWithoutChallengerInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type ChallengeInstanceUpdateManyWithoutChallengedNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengedInput, ChallengeInstanceUncheckedCreateWithoutChallengedInput> | ChallengeInstanceCreateWithoutChallengedInput[] | ChallengeInstanceUncheckedCreateWithoutChallengedInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengedInput | ChallengeInstanceCreateOrConnectWithoutChallengedInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutChallengedInput | ChallengeInstanceUpsertWithWhereUniqueWithoutChallengedInput[]
    createMany?: ChallengeInstanceCreateManyChallengedInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutChallengedInput | ChallengeInstanceUpdateWithWhereUniqueWithoutChallengedInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutChallengedInput | ChallengeInstanceUpdateManyWithWhereWithoutChallengedInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ActiveSessionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ActiveSessionCreateWithoutUserInput, ActiveSessionUncheckedCreateWithoutUserInput>
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutUserInput
    upsert?: ActiveSessionUpsertWithoutUserInput
    disconnect?: ActiveSessionWhereInput | boolean
    delete?: ActiveSessionWhereInput | boolean
    connect?: ActiveSessionWhereUniqueInput
    update?: XOR<XOR<ActiveSessionUpdateToOneWithWhereWithoutUserInput, ActiveSessionUpdateWithoutUserInput>, ActiveSessionUncheckedUpdateWithoutUserInput>
  }

  export type SignalUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<SignalCreateWithoutSenderInput, SignalUncheckedCreateWithoutSenderInput> | SignalCreateWithoutSenderInput[] | SignalUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutSenderInput | SignalCreateOrConnectWithoutSenderInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutSenderInput | SignalUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: SignalCreateManySenderInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutSenderInput | SignalUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutSenderInput | SignalUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type SignalUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<SignalCreateWithoutReceiverInput, SignalUncheckedCreateWithoutReceiverInput> | SignalCreateWithoutReceiverInput[] | SignalUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: SignalCreateOrConnectWithoutReceiverInput | SignalCreateOrConnectWithoutReceiverInput[]
    upsert?: SignalUpsertWithWhereUniqueWithoutReceiverInput | SignalUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: SignalCreateManyReceiverInputEnvelope
    set?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    disconnect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    delete?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    connect?: SignalWhereUniqueInput | SignalWhereUniqueInput[]
    update?: SignalUpdateWithWhereUniqueWithoutReceiverInput | SignalUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: SignalUpdateManyWithWhereWithoutReceiverInput | SignalUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: SignalScalarWhereInput | SignalScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutUserANestedInput = {
    create?: XOR<ConnectionCreateWithoutUserAInput, ConnectionUncheckedCreateWithoutUserAInput> | ConnectionCreateWithoutUserAInput[] | ConnectionUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserAInput | ConnectionCreateOrConnectWithoutUserAInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutUserAInput | ConnectionUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: ConnectionCreateManyUserAInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutUserAInput | ConnectionUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutUserAInput | ConnectionUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutUserBNestedInput = {
    create?: XOR<ConnectionCreateWithoutUserBInput, ConnectionUncheckedCreateWithoutUserBInput> | ConnectionCreateWithoutUserBInput[] | ConnectionUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutUserBInput | ConnectionCreateOrConnectWithoutUserBInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutUserBInput | ConnectionUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: ConnectionCreateManyUserBInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutUserBInput | ConnectionUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutUserBInput | ConnectionUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput> | ReportCreateWithoutReporterInput[] | ReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReporterInput | ReportCreateOrConnectWithoutReporterInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReporterInput | ReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: ReportCreateManyReporterInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReporterInput | ReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReporterInput | ReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserNestedInput = {
    create?: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput> | ReportCreateWithoutReportedUserInput[] | ReportUncheckedCreateWithoutReportedUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedUserInput | ReportCreateOrConnectWithoutReportedUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedUserInput | ReportUpsertWithWhereUniqueWithoutReportedUserInput[]
    createMany?: ReportCreateManyReportedUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedUserInput | ReportUpdateWithWhereUniqueWithoutReportedUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedUserInput | ReportUpdateManyWithWhereWithoutReportedUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<FeedbackCreateWithoutAuthorInput, FeedbackUncheckedCreateWithoutAuthorInput> | FeedbackCreateWithoutAuthorInput[] | FeedbackUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutAuthorInput | FeedbackCreateOrConnectWithoutAuthorInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutAuthorInput | FeedbackUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: FeedbackCreateManyAuthorInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutAuthorInput | FeedbackUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutAuthorInput | FeedbackUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput = {
    create?: XOR<BroadcastNotificationCreateWithoutSentByInput, BroadcastNotificationUncheckedCreateWithoutSentByInput> | BroadcastNotificationCreateWithoutSentByInput[] | BroadcastNotificationUncheckedCreateWithoutSentByInput[]
    connectOrCreate?: BroadcastNotificationCreateOrConnectWithoutSentByInput | BroadcastNotificationCreateOrConnectWithoutSentByInput[]
    upsert?: BroadcastNotificationUpsertWithWhereUniqueWithoutSentByInput | BroadcastNotificationUpsertWithWhereUniqueWithoutSentByInput[]
    createMany?: BroadcastNotificationCreateManySentByInputEnvelope
    set?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    disconnect?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    delete?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    connect?: BroadcastNotificationWhereUniqueInput | BroadcastNotificationWhereUniqueInput[]
    update?: BroadcastNotificationUpdateWithWhereUniqueWithoutSentByInput | BroadcastNotificationUpdateWithWhereUniqueWithoutSentByInput[]
    updateMany?: BroadcastNotificationUpdateManyWithWhereWithoutSentByInput | BroadcastNotificationUpdateManyWithWhereWithoutSentByInput[]
    deleteMany?: BroadcastNotificationScalarWhereInput | BroadcastNotificationScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type ProfileViewUncheckedUpdateManyWithoutViewerNestedInput = {
    create?: XOR<ProfileViewCreateWithoutViewerInput, ProfileViewUncheckedCreateWithoutViewerInput> | ProfileViewCreateWithoutViewerInput[] | ProfileViewUncheckedCreateWithoutViewerInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewerInput | ProfileViewCreateOrConnectWithoutViewerInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutViewerInput | ProfileViewUpsertWithWhereUniqueWithoutViewerInput[]
    createMany?: ProfileViewCreateManyViewerInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutViewerInput | ProfileViewUpdateWithWhereUniqueWithoutViewerInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutViewerInput | ProfileViewUpdateManyWithWhereWithoutViewerInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type ProfileViewUncheckedUpdateManyWithoutViewedNestedInput = {
    create?: XOR<ProfileViewCreateWithoutViewedInput, ProfileViewUncheckedCreateWithoutViewedInput> | ProfileViewCreateWithoutViewedInput[] | ProfileViewUncheckedCreateWithoutViewedInput[]
    connectOrCreate?: ProfileViewCreateOrConnectWithoutViewedInput | ProfileViewCreateOrConnectWithoutViewedInput[]
    upsert?: ProfileViewUpsertWithWhereUniqueWithoutViewedInput | ProfileViewUpsertWithWhereUniqueWithoutViewedInput[]
    createMany?: ProfileViewCreateManyViewedInputEnvelope
    set?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    disconnect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    delete?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    connect?: ProfileViewWhereUniqueInput | ProfileViewWhereUniqueInput[]
    update?: ProfileViewUpdateWithWhereUniqueWithoutViewedInput | ProfileViewUpdateWithWhereUniqueWithoutViewedInput[]
    updateMany?: ProfileViewUpdateManyWithWhereWithoutViewedInput | ProfileViewUpdateManyWithWhereWithoutViewedInput[]
    deleteMany?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
  }

  export type VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<VenueGroupMessageCreateWithoutSenderInput, VenueGroupMessageUncheckedCreateWithoutSenderInput> | VenueGroupMessageCreateWithoutSenderInput[] | VenueGroupMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutSenderInput | VenueGroupMessageCreateOrConnectWithoutSenderInput[]
    upsert?: VenueGroupMessageUpsertWithWhereUniqueWithoutSenderInput | VenueGroupMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: VenueGroupMessageCreateManySenderInputEnvelope
    set?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    disconnect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    delete?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    update?: VenueGroupMessageUpdateWithWhereUniqueWithoutSenderInput | VenueGroupMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: VenueGroupMessageUpdateManyWithWhereWithoutSenderInput | VenueGroupMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: VenueGroupMessageScalarWhereInput | VenueGroupMessageScalarWhereInput[]
  }

  export type AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountDeletionTokenCreateWithoutUserInput, AccountDeletionTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountDeletionTokenCreateOrConnectWithoutUserInput
    upsert?: AccountDeletionTokenUpsertWithoutUserInput
    disconnect?: AccountDeletionTokenWhereInput | boolean
    delete?: AccountDeletionTokenWhereInput | boolean
    connect?: AccountDeletionTokenWhereUniqueInput
    update?: XOR<XOR<AccountDeletionTokenUpdateToOneWithWhereWithoutUserInput, AccountDeletionTokenUpdateWithoutUserInput>, AccountDeletionTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailChangeTokenCreateWithoutUserInput, EmailChangeTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailChangeTokenCreateOrConnectWithoutUserInput
    upsert?: EmailChangeTokenUpsertWithoutUserInput
    disconnect?: EmailChangeTokenWhereInput | boolean
    delete?: EmailChangeTokenWhereInput | boolean
    connect?: EmailChangeTokenWhereUniqueInput
    update?: XOR<XOR<EmailChangeTokenUpdateToOneWithWhereWithoutUserInput, EmailChangeTokenUpdateWithoutUserInput>, EmailChangeTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GroupMessageReactionCreateWithoutUserInput, GroupMessageReactionUncheckedCreateWithoutUserInput> | GroupMessageReactionCreateWithoutUserInput[] | GroupMessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutUserInput | GroupMessageReactionCreateOrConnectWithoutUserInput[]
    upsert?: GroupMessageReactionUpsertWithWhereUniqueWithoutUserInput | GroupMessageReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GroupMessageReactionCreateManyUserInputEnvelope
    set?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    disconnect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    delete?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    update?: GroupMessageReactionUpdateWithWhereUniqueWithoutUserInput | GroupMessageReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GroupMessageReactionUpdateManyWithWhereWithoutUserInput | GroupMessageReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GroupMessageReactionScalarWhereInput | GroupMessageReactionScalarWhereInput[]
  }

  export type CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CheckInHistoryCreateWithoutUserInput, CheckInHistoryUncheckedCreateWithoutUserInput> | CheckInHistoryCreateWithoutUserInput[] | CheckInHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutUserInput | CheckInHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CheckInHistoryUpsertWithWhereUniqueWithoutUserInput | CheckInHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CheckInHistoryCreateManyUserInputEnvelope
    set?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    disconnect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    delete?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    update?: CheckInHistoryUpdateWithWhereUniqueWithoutUserInput | CheckInHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CheckInHistoryUpdateManyWithWhereWithoutUserInput | CheckInHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CheckInHistoryScalarWhereInput | CheckInHistoryScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengerInput, ChallengeInstanceUncheckedCreateWithoutChallengerInput> | ChallengeInstanceCreateWithoutChallengerInput[] | ChallengeInstanceUncheckedCreateWithoutChallengerInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengerInput | ChallengeInstanceCreateOrConnectWithoutChallengerInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutChallengerInput | ChallengeInstanceUpsertWithWhereUniqueWithoutChallengerInput[]
    createMany?: ChallengeInstanceCreateManyChallengerInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutChallengerInput | ChallengeInstanceUpdateWithWhereUniqueWithoutChallengerInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutChallengerInput | ChallengeInstanceUpdateManyWithWhereWithoutChallengerInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutChallengedInput, ChallengeInstanceUncheckedCreateWithoutChallengedInput> | ChallengeInstanceCreateWithoutChallengedInput[] | ChallengeInstanceUncheckedCreateWithoutChallengedInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutChallengedInput | ChallengeInstanceCreateOrConnectWithoutChallengedInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutChallengedInput | ChallengeInstanceUpsertWithWhereUniqueWithoutChallengedInput[]
    createMany?: ChallengeInstanceCreateManyChallengedInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutChallengedInput | ChallengeInstanceUpdateWithWhereUniqueWithoutChallengedInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutChallengedInput | ChallengeInstanceUpdateManyWithWhereWithoutChallengedInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type InterestCreateNestedManyWithoutProfilesInput = {
    create?: XOR<InterestCreateWithoutProfilesInput, InterestUncheckedCreateWithoutProfilesInput> | InterestCreateWithoutProfilesInput[] | InterestUncheckedCreateWithoutProfilesInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutProfilesInput | InterestCreateOrConnectWithoutProfilesInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type PhotoCreateNestedManyWithoutProfileInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type ProfileOptionCreateNestedOneWithoutProfilesByOrientationInput = {
    create?: XOR<ProfileOptionCreateWithoutProfilesByOrientationInput, ProfileOptionUncheckedCreateWithoutProfilesByOrientationInput>
    connectOrCreate?: ProfileOptionCreateOrConnectWithoutProfilesByOrientationInput
    connect?: ProfileOptionWhereUniqueInput
  }

  export type ProfileOptionCreateNestedOneWithoutProfilesByGoalInput = {
    create?: XOR<ProfileOptionCreateWithoutProfilesByGoalInput, ProfileOptionUncheckedCreateWithoutProfilesByGoalInput>
    connectOrCreate?: ProfileOptionCreateOrConnectWithoutProfilesByGoalInput
    connect?: ProfileOptionWhereUniqueInput
  }

  export type InterestUncheckedCreateNestedManyWithoutProfilesInput = {
    create?: XOR<InterestCreateWithoutProfilesInput, InterestUncheckedCreateWithoutProfilesInput> | InterestCreateWithoutProfilesInput[] | InterestUncheckedCreateWithoutProfilesInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutProfilesInput | InterestCreateOrConnectWithoutProfilesInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type PhotoUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type NullableEnumPersonalityTypeFieldUpdateOperationsInput = {
    set?: $Enums.PersonalityType | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type InterestUpdateManyWithoutProfilesNestedInput = {
    create?: XOR<InterestCreateWithoutProfilesInput, InterestUncheckedCreateWithoutProfilesInput> | InterestCreateWithoutProfilesInput[] | InterestUncheckedCreateWithoutProfilesInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutProfilesInput | InterestCreateOrConnectWithoutProfilesInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutProfilesInput | InterestUpsertWithWhereUniqueWithoutProfilesInput[]
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutProfilesInput | InterestUpdateWithWhereUniqueWithoutProfilesInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutProfilesInput | InterestUpdateManyWithWhereWithoutProfilesInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type PhotoUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutProfileInput | PhotoUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutProfileInput | PhotoUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutProfileInput | PhotoUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type ProfileOptionUpdateOneWithoutProfilesByOrientationNestedInput = {
    create?: XOR<ProfileOptionCreateWithoutProfilesByOrientationInput, ProfileOptionUncheckedCreateWithoutProfilesByOrientationInput>
    connectOrCreate?: ProfileOptionCreateOrConnectWithoutProfilesByOrientationInput
    upsert?: ProfileOptionUpsertWithoutProfilesByOrientationInput
    disconnect?: ProfileOptionWhereInput | boolean
    delete?: ProfileOptionWhereInput | boolean
    connect?: ProfileOptionWhereUniqueInput
    update?: XOR<XOR<ProfileOptionUpdateToOneWithWhereWithoutProfilesByOrientationInput, ProfileOptionUpdateWithoutProfilesByOrientationInput>, ProfileOptionUncheckedUpdateWithoutProfilesByOrientationInput>
  }

  export type ProfileOptionUpdateOneWithoutProfilesByGoalNestedInput = {
    create?: XOR<ProfileOptionCreateWithoutProfilesByGoalInput, ProfileOptionUncheckedCreateWithoutProfilesByGoalInput>
    connectOrCreate?: ProfileOptionCreateOrConnectWithoutProfilesByGoalInput
    upsert?: ProfileOptionUpsertWithoutProfilesByGoalInput
    disconnect?: ProfileOptionWhereInput | boolean
    delete?: ProfileOptionWhereInput | boolean
    connect?: ProfileOptionWhereUniqueInput
    update?: XOR<XOR<ProfileOptionUpdateToOneWithWhereWithoutProfilesByGoalInput, ProfileOptionUpdateWithoutProfilesByGoalInput>, ProfileOptionUncheckedUpdateWithoutProfilesByGoalInput>
  }

  export type InterestUncheckedUpdateManyWithoutProfilesNestedInput = {
    create?: XOR<InterestCreateWithoutProfilesInput, InterestUncheckedCreateWithoutProfilesInput> | InterestCreateWithoutProfilesInput[] | InterestUncheckedCreateWithoutProfilesInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutProfilesInput | InterestCreateOrConnectWithoutProfilesInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutProfilesInput | InterestUpsertWithWhereUniqueWithoutProfilesInput[]
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutProfilesInput | InterestUpdateWithWhereUniqueWithoutProfilesInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutProfilesInput | InterestUpdateManyWithWhereWithoutProfilesInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type PhotoUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput> | PhotoCreateWithoutProfileInput[] | PhotoUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutProfileInput | PhotoCreateOrConnectWithoutProfileInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutProfileInput | PhotoUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PhotoCreateManyProfileInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutProfileInput | PhotoUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutProfileInput | PhotoUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type InterestCreateNestedManyWithoutCategoryInput = {
    create?: XOR<InterestCreateWithoutCategoryInput, InterestUncheckedCreateWithoutCategoryInput> | InterestCreateWithoutCategoryInput[] | InterestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutCategoryInput | InterestCreateOrConnectWithoutCategoryInput[]
    createMany?: InterestCreateManyCategoryInputEnvelope
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type InterestUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<InterestCreateWithoutCategoryInput, InterestUncheckedCreateWithoutCategoryInput> | InterestCreateWithoutCategoryInput[] | InterestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutCategoryInput | InterestCreateOrConnectWithoutCategoryInput[]
    createMany?: InterestCreateManyCategoryInputEnvelope
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
  }

  export type InterestUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<InterestCreateWithoutCategoryInput, InterestUncheckedCreateWithoutCategoryInput> | InterestCreateWithoutCategoryInput[] | InterestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutCategoryInput | InterestCreateOrConnectWithoutCategoryInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutCategoryInput | InterestUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: InterestCreateManyCategoryInputEnvelope
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutCategoryInput | InterestUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutCategoryInput | InterestUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type InterestUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<InterestCreateWithoutCategoryInput, InterestUncheckedCreateWithoutCategoryInput> | InterestCreateWithoutCategoryInput[] | InterestUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: InterestCreateOrConnectWithoutCategoryInput | InterestCreateOrConnectWithoutCategoryInput[]
    upsert?: InterestUpsertWithWhereUniqueWithoutCategoryInput | InterestUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: InterestCreateManyCategoryInputEnvelope
    set?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    disconnect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    delete?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    connect?: InterestWhereUniqueInput | InterestWhereUniqueInput[]
    update?: InterestUpdateWithWhereUniqueWithoutCategoryInput | InterestUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: InterestUpdateManyWithWhereWithoutCategoryInput | InterestUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: InterestScalarWhereInput | InterestScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutInterestsInput = {
    create?: XOR<CategoryCreateWithoutInterestsInput, CategoryUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutInterestsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ProfileCreateNestedManyWithoutInterestsInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput> | ProfileCreateWithoutInterestsInput[] | ProfileUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput | ProfileCreateOrConnectWithoutInterestsInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedManyWithoutInterestsInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput> | ProfileCreateWithoutInterestsInput[] | ProfileUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput | ProfileCreateOrConnectWithoutInterestsInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<CategoryCreateWithoutInterestsInput, CategoryUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutInterestsInput
    upsert?: CategoryUpsertWithoutInterestsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutInterestsInput, CategoryUpdateWithoutInterestsInput>, CategoryUncheckedUpdateWithoutInterestsInput>
  }

  export type ProfileUpdateManyWithoutInterestsNestedInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput> | ProfileCreateWithoutInterestsInput[] | ProfileUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput | ProfileCreateOrConnectWithoutInterestsInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutInterestsInput | ProfileUpsertWithWhereUniqueWithoutInterestsInput[]
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutInterestsInput | ProfileUpdateWithWhereUniqueWithoutInterestsInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutInterestsInput | ProfileUpdateManyWithWhereWithoutInterestsInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateManyWithoutInterestsNestedInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput> | ProfileCreateWithoutInterestsInput[] | ProfileUncheckedCreateWithoutInterestsInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput | ProfileCreateOrConnectWithoutInterestsInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutInterestsInput | ProfileUpsertWithWhereUniqueWithoutInterestsInput[]
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutInterestsInput | ProfileUpdateWithWhereUniqueWithoutInterestsInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutInterestsInput | ProfileUpdateManyWithWhereWithoutInterestsInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type ActiveSessionCreateNestedManyWithoutVenueInput = {
    create?: XOR<ActiveSessionCreateWithoutVenueInput, ActiveSessionUncheckedCreateWithoutVenueInput> | ActiveSessionCreateWithoutVenueInput[] | ActiveSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutVenueInput | ActiveSessionCreateOrConnectWithoutVenueInput[]
    createMany?: ActiveSessionCreateManyVenueInputEnvelope
    connect?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
  }

  export type VenueGroupMessageCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueGroupMessageCreateWithoutVenueInput, VenueGroupMessageUncheckedCreateWithoutVenueInput> | VenueGroupMessageCreateWithoutVenueInput[] | VenueGroupMessageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutVenueInput | VenueGroupMessageCreateOrConnectWithoutVenueInput[]
    createMany?: VenueGroupMessageCreateManyVenueInputEnvelope
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
  }

  export type CheckInHistoryCreateNestedManyWithoutVenueInput = {
    create?: XOR<CheckInHistoryCreateWithoutVenueInput, CheckInHistoryUncheckedCreateWithoutVenueInput> | CheckInHistoryCreateWithoutVenueInput[] | CheckInHistoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutVenueInput | CheckInHistoryCreateOrConnectWithoutVenueInput[]
    createMany?: CheckInHistoryCreateManyVenueInputEnvelope
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
  }

  export type ChallengeInstanceCreateNestedManyWithoutVenueInput = {
    create?: XOR<ChallengeInstanceCreateWithoutVenueInput, ChallengeInstanceUncheckedCreateWithoutVenueInput> | ChallengeInstanceCreateWithoutVenueInput[] | ChallengeInstanceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutVenueInput | ChallengeInstanceCreateOrConnectWithoutVenueInput[]
    createMany?: ChallengeInstanceCreateManyVenueInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type ActiveSessionUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ActiveSessionCreateWithoutVenueInput, ActiveSessionUncheckedCreateWithoutVenueInput> | ActiveSessionCreateWithoutVenueInput[] | ActiveSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutVenueInput | ActiveSessionCreateOrConnectWithoutVenueInput[]
    createMany?: ActiveSessionCreateManyVenueInputEnvelope
    connect?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
  }

  export type VenueGroupMessageUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<VenueGroupMessageCreateWithoutVenueInput, VenueGroupMessageUncheckedCreateWithoutVenueInput> | VenueGroupMessageCreateWithoutVenueInput[] | VenueGroupMessageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutVenueInput | VenueGroupMessageCreateOrConnectWithoutVenueInput[]
    createMany?: VenueGroupMessageCreateManyVenueInputEnvelope
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
  }

  export type CheckInHistoryUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<CheckInHistoryCreateWithoutVenueInput, CheckInHistoryUncheckedCreateWithoutVenueInput> | CheckInHistoryCreateWithoutVenueInput[] | CheckInHistoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutVenueInput | CheckInHistoryCreateOrConnectWithoutVenueInput[]
    createMany?: CheckInHistoryCreateManyVenueInputEnvelope
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
  }

  export type ChallengeInstanceUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ChallengeInstanceCreateWithoutVenueInput, ChallengeInstanceUncheckedCreateWithoutVenueInput> | ChallengeInstanceCreateWithoutVenueInput[] | ChallengeInstanceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutVenueInput | ChallengeInstanceCreateOrConnectWithoutVenueInput[]
    createMany?: ChallengeInstanceCreateManyVenueInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVenueCategoryFieldUpdateOperationsInput = {
    set?: $Enums.VenueCategory
  }

  export type ActiveSessionUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ActiveSessionCreateWithoutVenueInput, ActiveSessionUncheckedCreateWithoutVenueInput> | ActiveSessionCreateWithoutVenueInput[] | ActiveSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutVenueInput | ActiveSessionCreateOrConnectWithoutVenueInput[]
    upsert?: ActiveSessionUpsertWithWhereUniqueWithoutVenueInput | ActiveSessionUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ActiveSessionCreateManyVenueInputEnvelope
    set?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    disconnect?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    delete?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    connect?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    update?: ActiveSessionUpdateWithWhereUniqueWithoutVenueInput | ActiveSessionUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ActiveSessionUpdateManyWithWhereWithoutVenueInput | ActiveSessionUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ActiveSessionScalarWhereInput | ActiveSessionScalarWhereInput[]
  }

  export type VenueGroupMessageUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueGroupMessageCreateWithoutVenueInput, VenueGroupMessageUncheckedCreateWithoutVenueInput> | VenueGroupMessageCreateWithoutVenueInput[] | VenueGroupMessageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutVenueInput | VenueGroupMessageCreateOrConnectWithoutVenueInput[]
    upsert?: VenueGroupMessageUpsertWithWhereUniqueWithoutVenueInput | VenueGroupMessageUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueGroupMessageCreateManyVenueInputEnvelope
    set?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    disconnect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    delete?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    update?: VenueGroupMessageUpdateWithWhereUniqueWithoutVenueInput | VenueGroupMessageUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueGroupMessageUpdateManyWithWhereWithoutVenueInput | VenueGroupMessageUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueGroupMessageScalarWhereInput | VenueGroupMessageScalarWhereInput[]
  }

  export type CheckInHistoryUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CheckInHistoryCreateWithoutVenueInput, CheckInHistoryUncheckedCreateWithoutVenueInput> | CheckInHistoryCreateWithoutVenueInput[] | CheckInHistoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutVenueInput | CheckInHistoryCreateOrConnectWithoutVenueInput[]
    upsert?: CheckInHistoryUpsertWithWhereUniqueWithoutVenueInput | CheckInHistoryUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CheckInHistoryCreateManyVenueInputEnvelope
    set?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    disconnect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    delete?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    update?: CheckInHistoryUpdateWithWhereUniqueWithoutVenueInput | CheckInHistoryUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CheckInHistoryUpdateManyWithWhereWithoutVenueInput | CheckInHistoryUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CheckInHistoryScalarWhereInput | CheckInHistoryScalarWhereInput[]
  }

  export type ChallengeInstanceUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutVenueInput, ChallengeInstanceUncheckedCreateWithoutVenueInput> | ChallengeInstanceCreateWithoutVenueInput[] | ChallengeInstanceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutVenueInput | ChallengeInstanceCreateOrConnectWithoutVenueInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutVenueInput | ChallengeInstanceUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ChallengeInstanceCreateManyVenueInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutVenueInput | ChallengeInstanceUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutVenueInput | ChallengeInstanceUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type ActiveSessionUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ActiveSessionCreateWithoutVenueInput, ActiveSessionUncheckedCreateWithoutVenueInput> | ActiveSessionCreateWithoutVenueInput[] | ActiveSessionUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ActiveSessionCreateOrConnectWithoutVenueInput | ActiveSessionCreateOrConnectWithoutVenueInput[]
    upsert?: ActiveSessionUpsertWithWhereUniqueWithoutVenueInput | ActiveSessionUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ActiveSessionCreateManyVenueInputEnvelope
    set?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    disconnect?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    delete?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    connect?: ActiveSessionWhereUniqueInput | ActiveSessionWhereUniqueInput[]
    update?: ActiveSessionUpdateWithWhereUniqueWithoutVenueInput | ActiveSessionUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ActiveSessionUpdateManyWithWhereWithoutVenueInput | ActiveSessionUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ActiveSessionScalarWhereInput | ActiveSessionScalarWhereInput[]
  }

  export type VenueGroupMessageUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<VenueGroupMessageCreateWithoutVenueInput, VenueGroupMessageUncheckedCreateWithoutVenueInput> | VenueGroupMessageCreateWithoutVenueInput[] | VenueGroupMessageUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutVenueInput | VenueGroupMessageCreateOrConnectWithoutVenueInput[]
    upsert?: VenueGroupMessageUpsertWithWhereUniqueWithoutVenueInput | VenueGroupMessageUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: VenueGroupMessageCreateManyVenueInputEnvelope
    set?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    disconnect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    delete?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    connect?: VenueGroupMessageWhereUniqueInput | VenueGroupMessageWhereUniqueInput[]
    update?: VenueGroupMessageUpdateWithWhereUniqueWithoutVenueInput | VenueGroupMessageUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: VenueGroupMessageUpdateManyWithWhereWithoutVenueInput | VenueGroupMessageUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: VenueGroupMessageScalarWhereInput | VenueGroupMessageScalarWhereInput[]
  }

  export type CheckInHistoryUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<CheckInHistoryCreateWithoutVenueInput, CheckInHistoryUncheckedCreateWithoutVenueInput> | CheckInHistoryCreateWithoutVenueInput[] | CheckInHistoryUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: CheckInHistoryCreateOrConnectWithoutVenueInput | CheckInHistoryCreateOrConnectWithoutVenueInput[]
    upsert?: CheckInHistoryUpsertWithWhereUniqueWithoutVenueInput | CheckInHistoryUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: CheckInHistoryCreateManyVenueInputEnvelope
    set?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    disconnect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    delete?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    connect?: CheckInHistoryWhereUniqueInput | CheckInHistoryWhereUniqueInput[]
    update?: CheckInHistoryUpdateWithWhereUniqueWithoutVenueInput | CheckInHistoryUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: CheckInHistoryUpdateManyWithWhereWithoutVenueInput | CheckInHistoryUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: CheckInHistoryScalarWhereInput | CheckInHistoryScalarWhereInput[]
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutVenueInput, ChallengeInstanceUncheckedCreateWithoutVenueInput> | ChallengeInstanceCreateWithoutVenueInput[] | ChallengeInstanceUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutVenueInput | ChallengeInstanceCreateOrConnectWithoutVenueInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutVenueInput | ChallengeInstanceUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ChallengeInstanceCreateManyVenueInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutVenueInput | ChallengeInstanceUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutVenueInput | ChallengeInstanceUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutActiveSessionInput = {
    create?: XOR<UserCreateWithoutActiveSessionInput, UserUncheckedCreateWithoutActiveSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveSessionInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutActiveSessionsInput = {
    create?: XOR<VenueCreateWithoutActiveSessionsInput, VenueUncheckedCreateWithoutActiveSessionsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutActiveSessionsInput
    connect?: VenueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActiveSessionNestedInput = {
    create?: XOR<UserCreateWithoutActiveSessionInput, UserUncheckedCreateWithoutActiveSessionInput>
    connectOrCreate?: UserCreateOrConnectWithoutActiveSessionInput
    upsert?: UserUpsertWithoutActiveSessionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActiveSessionInput, UserUpdateWithoutActiveSessionInput>, UserUncheckedUpdateWithoutActiveSessionInput>
  }

  export type VenueUpdateOneRequiredWithoutActiveSessionsNestedInput = {
    create?: XOR<VenueCreateWithoutActiveSessionsInput, VenueUncheckedCreateWithoutActiveSessionsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutActiveSessionsInput
    upsert?: VenueUpsertWithoutActiveSessionsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutActiveSessionsInput, VenueUpdateWithoutActiveSessionsInput>, VenueUncheckedUpdateWithoutActiveSessionsInput>
  }

  export type UserCreateNestedOneWithoutSentSignalsInput = {
    create?: XOR<UserCreateWithoutSentSignalsInput, UserUncheckedCreateWithoutSentSignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentSignalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedSignalsInput = {
    create?: XOR<UserCreateWithoutReceivedSignalsInput, UserUncheckedCreateWithoutReceivedSignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedSignalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentSignalsNestedInput = {
    create?: XOR<UserCreateWithoutSentSignalsInput, UserUncheckedCreateWithoutSentSignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentSignalsInput
    upsert?: UserUpsertWithoutSentSignalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentSignalsInput, UserUpdateWithoutSentSignalsInput>, UserUncheckedUpdateWithoutSentSignalsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedSignalsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedSignalsInput, UserUncheckedCreateWithoutReceivedSignalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedSignalsInput
    upsert?: UserUpsertWithoutReceivedSignalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedSignalsInput, UserUpdateWithoutReceivedSignalsInput>, UserUncheckedUpdateWithoutReceivedSignalsInput>
  }

  export type UserCreateNestedOneWithoutConnectionsAInput = {
    create?: XOR<UserCreateWithoutConnectionsAInput, UserUncheckedCreateWithoutConnectionsAInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsAInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConnectionsBInput = {
    create?: XOR<UserCreateWithoutConnectionsBInput, UserUncheckedCreateWithoutConnectionsBInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsBInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConnectionInput = {
    create?: XOR<MessageCreateWithoutConnectionInput, MessageUncheckedCreateWithoutConnectionInput> | MessageCreateWithoutConnectionInput[] | MessageUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConnectionInput | MessageCreateOrConnectWithoutConnectionInput[]
    createMany?: MessageCreateManyConnectionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChallengeInstanceCreateNestedManyWithoutConnectionInput = {
    create?: XOR<ChallengeInstanceCreateWithoutConnectionInput, ChallengeInstanceUncheckedCreateWithoutConnectionInput> | ChallengeInstanceCreateWithoutConnectionInput[] | ChallengeInstanceUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutConnectionInput | ChallengeInstanceCreateOrConnectWithoutConnectionInput[]
    createMany?: ChallengeInstanceCreateManyConnectionInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConnectionInput = {
    create?: XOR<MessageCreateWithoutConnectionInput, MessageUncheckedCreateWithoutConnectionInput> | MessageCreateWithoutConnectionInput[] | MessageUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConnectionInput | MessageCreateOrConnectWithoutConnectionInput[]
    createMany?: MessageCreateManyConnectionInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ChallengeInstanceUncheckedCreateNestedManyWithoutConnectionInput = {
    create?: XOR<ChallengeInstanceCreateWithoutConnectionInput, ChallengeInstanceUncheckedCreateWithoutConnectionInput> | ChallengeInstanceCreateWithoutConnectionInput[] | ChallengeInstanceUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutConnectionInput | ChallengeInstanceCreateOrConnectWithoutConnectionInput[]
    createMany?: ChallengeInstanceCreateManyConnectionInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConnectionsANestedInput = {
    create?: XOR<UserCreateWithoutConnectionsAInput, UserUncheckedCreateWithoutConnectionsAInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsAInput
    upsert?: UserUpsertWithoutConnectionsAInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectionsAInput, UserUpdateWithoutConnectionsAInput>, UserUncheckedUpdateWithoutConnectionsAInput>
  }

  export type UserUpdateOneRequiredWithoutConnectionsBNestedInput = {
    create?: XOR<UserCreateWithoutConnectionsBInput, UserUncheckedCreateWithoutConnectionsBInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectionsBInput
    upsert?: UserUpsertWithoutConnectionsBInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectionsBInput, UserUpdateWithoutConnectionsBInput>, UserUncheckedUpdateWithoutConnectionsBInput>
  }

  export type MessageUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<MessageCreateWithoutConnectionInput, MessageUncheckedCreateWithoutConnectionInput> | MessageCreateWithoutConnectionInput[] | MessageUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConnectionInput | MessageCreateOrConnectWithoutConnectionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConnectionInput | MessageUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: MessageCreateManyConnectionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConnectionInput | MessageUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConnectionInput | MessageUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChallengeInstanceUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutConnectionInput, ChallengeInstanceUncheckedCreateWithoutConnectionInput> | ChallengeInstanceCreateWithoutConnectionInput[] | ChallengeInstanceUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutConnectionInput | ChallengeInstanceCreateOrConnectWithoutConnectionInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutConnectionInput | ChallengeInstanceUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: ChallengeInstanceCreateManyConnectionInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutConnectionInput | ChallengeInstanceUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutConnectionInput | ChallengeInstanceUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<MessageCreateWithoutConnectionInput, MessageUncheckedCreateWithoutConnectionInput> | MessageCreateWithoutConnectionInput[] | MessageUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConnectionInput | MessageCreateOrConnectWithoutConnectionInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConnectionInput | MessageUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: MessageCreateManyConnectionInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConnectionInput | MessageUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConnectionInput | MessageUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutConnectionInput, ChallengeInstanceUncheckedCreateWithoutConnectionInput> | ChallengeInstanceCreateWithoutConnectionInput[] | ChallengeInstanceUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutConnectionInput | ChallengeInstanceCreateOrConnectWithoutConnectionInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutConnectionInput | ChallengeInstanceUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: ChallengeInstanceCreateManyConnectionInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutConnectionInput | ChallengeInstanceUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutConnectionInput | ChallengeInstanceUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConnectionCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConnectionCreateWithoutMessagesInput, ConnectionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConnectionCreateOrConnectWithoutMessagesInput
    connect?: ConnectionWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutReportedMessageInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedMessageInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type ConnectionUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConnectionCreateWithoutMessagesInput, ConnectionUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConnectionCreateOrConnectWithoutMessagesInput
    upsert?: ConnectionUpsertWithoutMessagesInput
    connect?: ConnectionWhereUniqueInput
    update?: XOR<XOR<ConnectionUpdateToOneWithWhereWithoutMessagesInput, ConnectionUpdateWithoutMessagesInput>, ConnectionUncheckedUpdateWithoutMessagesInput>
  }

  export type ReportUpdateManyWithoutReportedMessageNestedInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedMessageInput | ReportUpsertWithWhereUniqueWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedMessageInput | ReportUpdateWithWhereUniqueWithoutReportedMessageInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedMessageInput | ReportUpdateManyWithWhereWithoutReportedMessageInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedMessageNestedInput = {
    create?: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput> | ReportCreateWithoutReportedMessageInput[] | ReportUncheckedCreateWithoutReportedMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedMessageInput | ReportCreateOrConnectWithoutReportedMessageInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedMessageInput | ReportUpsertWithWhereUniqueWithoutReportedMessageInput[]
    createMany?: ReportCreateManyReportedMessageInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedMessageInput | ReportUpdateWithWhereUniqueWithoutReportedMessageInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedMessageInput | ReportUpdateManyWithWhereWithoutReportedMessageInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlockingInput = {
    create?: XOR<UserCreateWithoutBlockingInput, UserUncheckedCreateWithoutBlockingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlockingNestedInput = {
    create?: XOR<UserCreateWithoutBlockingInput, UserUncheckedCreateWithoutBlockingInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockingInput
    upsert?: UserUpsertWithoutBlockingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockingInput, UserUpdateWithoutBlockingInput>, UserUncheckedUpdateWithoutBlockingInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    upsert?: UserUpsertWithoutBlockedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedByInput, UserUpdateWithoutBlockedByInput>, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserCreateNestedOneWithoutReportsMadeInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsReceivedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutReportsInput = {
    create?: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReportsInput
    connect?: MessageWhereUniqueInput
  }

  export type VenueGroupMessageCreateNestedOneWithoutReportsInput = {
    create?: XOR<VenueGroupMessageCreateWithoutReportsInput, VenueGroupMessageUncheckedCreateWithoutReportsInput>
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutReportsInput
    connect?: VenueGroupMessageWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserUpdateOneRequiredWithoutReportsMadeNestedInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    upsert?: UserUpsertWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsMadeInput, UserUpdateWithoutReportsMadeInput>, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type UserUpdateOneRequiredWithoutReportsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsReceivedInput
    upsert?: UserUpsertWithoutReportsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsReceivedInput, UserUpdateWithoutReportsReceivedInput>, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type MessageUpdateOneWithoutReportsNestedInput = {
    create?: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReportsInput
    upsert?: MessageUpsertWithoutReportsInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReportsInput, MessageUpdateWithoutReportsInput>, MessageUncheckedUpdateWithoutReportsInput>
  }

  export type VenueGroupMessageUpdateOneWithoutReportsNestedInput = {
    create?: XOR<VenueGroupMessageCreateWithoutReportsInput, VenueGroupMessageUncheckedCreateWithoutReportsInput>
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutReportsInput
    upsert?: VenueGroupMessageUpsertWithoutReportsInput
    disconnect?: VenueGroupMessageWhereInput | boolean
    delete?: VenueGroupMessageWhereInput | boolean
    connect?: VenueGroupMessageWhereUniqueInput
    update?: XOR<XOR<VenueGroupMessageUpdateToOneWithWhereWithoutReportsInput, VenueGroupMessageUpdateWithoutReportsInput>, VenueGroupMessageUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevicesInput, UserUpdateWithoutDevicesInput>, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedbacksInput
    upsert?: UserUpsertWithoutFeedbacksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedbacksInput, UserUpdateWithoutFeedbacksInput>, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutSentBroadcastsInput = {
    create?: XOR<UserCreateWithoutSentBroadcastsInput, UserUncheckedCreateWithoutSentBroadcastsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentBroadcastsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentBroadcastsNestedInput = {
    create?: XOR<UserCreateWithoutSentBroadcastsInput, UserUncheckedCreateWithoutSentBroadcastsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentBroadcastsInput
    upsert?: UserUpsertWithoutSentBroadcastsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentBroadcastsInput, UserUpdateWithoutSentBroadcastsInput>, UserUncheckedUpdateWithoutSentBroadcastsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type ProfileCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhotosInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPhotosInput
    upsert?: ProfileUpsertWithoutPhotosInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPhotosInput, ProfileUpdateWithoutPhotosInput>, ProfileUncheckedUpdateWithoutPhotosInput>
  }

  export type EnumIcebreakerCategoryFieldUpdateOperationsInput = {
    set?: $Enums.IcebreakerCategory
  }

  export type UserCreateNestedOneWithoutViewsMadeInput = {
    create?: XOR<UserCreateWithoutViewsMadeInput, UserUncheckedCreateWithoutViewsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutViewsReceivedInput = {
    create?: XOR<UserCreateWithoutViewsReceivedInput, UserUncheckedCreateWithoutViewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutViewsMadeNestedInput = {
    create?: XOR<UserCreateWithoutViewsMadeInput, UserUncheckedCreateWithoutViewsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewsMadeInput
    upsert?: UserUpsertWithoutViewsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewsMadeInput, UserUpdateWithoutViewsMadeInput>, UserUncheckedUpdateWithoutViewsMadeInput>
  }

  export type UserUpdateOneRequiredWithoutViewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutViewsReceivedInput, UserUncheckedCreateWithoutViewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutViewsReceivedInput
    upsert?: UserUpsertWithoutViewsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutViewsReceivedInput, UserUpdateWithoutViewsReceivedInput>, UserUncheckedUpdateWithoutViewsReceivedInput>
  }

  export type ReportCreateNestedManyWithoutReportedGroupMessageInput = {
    create?: XOR<ReportCreateWithoutReportedGroupMessageInput, ReportUncheckedCreateWithoutReportedGroupMessageInput> | ReportCreateWithoutReportedGroupMessageInput[] | ReportUncheckedCreateWithoutReportedGroupMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedGroupMessageInput | ReportCreateOrConnectWithoutReportedGroupMessageInput[]
    createMany?: ReportCreateManyReportedGroupMessageInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type GroupMessageReactionCreateNestedManyWithoutMessageInput = {
    create?: XOR<GroupMessageReactionCreateWithoutMessageInput, GroupMessageReactionUncheckedCreateWithoutMessageInput> | GroupMessageReactionCreateWithoutMessageInput[] | GroupMessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutMessageInput | GroupMessageReactionCreateOrConnectWithoutMessageInput[]
    createMany?: GroupMessageReactionCreateManyMessageInputEnvelope
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
  }

  export type VenueCreateNestedOneWithoutGroupMessagesInput = {
    create?: XOR<VenueCreateWithoutGroupMessagesInput, VenueUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutGroupMessagesInput
    connect?: VenueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVenueGroupMessagesInput = {
    create?: XOR<UserCreateWithoutVenueGroupMessagesInput, UserUncheckedCreateWithoutVenueGroupMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVenueGroupMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedGroupMessageInput = {
    create?: XOR<ReportCreateWithoutReportedGroupMessageInput, ReportUncheckedCreateWithoutReportedGroupMessageInput> | ReportCreateWithoutReportedGroupMessageInput[] | ReportUncheckedCreateWithoutReportedGroupMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedGroupMessageInput | ReportCreateOrConnectWithoutReportedGroupMessageInput[]
    createMany?: ReportCreateManyReportedGroupMessageInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type GroupMessageReactionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<GroupMessageReactionCreateWithoutMessageInput, GroupMessageReactionUncheckedCreateWithoutMessageInput> | GroupMessageReactionCreateWithoutMessageInput[] | GroupMessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutMessageInput | GroupMessageReactionCreateOrConnectWithoutMessageInput[]
    createMany?: GroupMessageReactionCreateManyMessageInputEnvelope
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
  }

  export type ReportUpdateManyWithoutReportedGroupMessageNestedInput = {
    create?: XOR<ReportCreateWithoutReportedGroupMessageInput, ReportUncheckedCreateWithoutReportedGroupMessageInput> | ReportCreateWithoutReportedGroupMessageInput[] | ReportUncheckedCreateWithoutReportedGroupMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedGroupMessageInput | ReportCreateOrConnectWithoutReportedGroupMessageInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedGroupMessageInput | ReportUpsertWithWhereUniqueWithoutReportedGroupMessageInput[]
    createMany?: ReportCreateManyReportedGroupMessageInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedGroupMessageInput | ReportUpdateWithWhereUniqueWithoutReportedGroupMessageInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedGroupMessageInput | ReportUpdateManyWithWhereWithoutReportedGroupMessageInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type GroupMessageReactionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<GroupMessageReactionCreateWithoutMessageInput, GroupMessageReactionUncheckedCreateWithoutMessageInput> | GroupMessageReactionCreateWithoutMessageInput[] | GroupMessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutMessageInput | GroupMessageReactionCreateOrConnectWithoutMessageInput[]
    upsert?: GroupMessageReactionUpsertWithWhereUniqueWithoutMessageInput | GroupMessageReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: GroupMessageReactionCreateManyMessageInputEnvelope
    set?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    disconnect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    delete?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    update?: GroupMessageReactionUpdateWithWhereUniqueWithoutMessageInput | GroupMessageReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: GroupMessageReactionUpdateManyWithWhereWithoutMessageInput | GroupMessageReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: GroupMessageReactionScalarWhereInput | GroupMessageReactionScalarWhereInput[]
  }

  export type VenueUpdateOneRequiredWithoutGroupMessagesNestedInput = {
    create?: XOR<VenueCreateWithoutGroupMessagesInput, VenueUncheckedCreateWithoutGroupMessagesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutGroupMessagesInput
    upsert?: VenueUpsertWithoutGroupMessagesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutGroupMessagesInput, VenueUpdateWithoutGroupMessagesInput>, VenueUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutVenueGroupMessagesNestedInput = {
    create?: XOR<UserCreateWithoutVenueGroupMessagesInput, UserUncheckedCreateWithoutVenueGroupMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVenueGroupMessagesInput
    upsert?: UserUpsertWithoutVenueGroupMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVenueGroupMessagesInput, UserUpdateWithoutVenueGroupMessagesInput>, UserUncheckedUpdateWithoutVenueGroupMessagesInput>
  }

  export type ReportUncheckedUpdateManyWithoutReportedGroupMessageNestedInput = {
    create?: XOR<ReportCreateWithoutReportedGroupMessageInput, ReportUncheckedCreateWithoutReportedGroupMessageInput> | ReportCreateWithoutReportedGroupMessageInput[] | ReportUncheckedCreateWithoutReportedGroupMessageInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedGroupMessageInput | ReportCreateOrConnectWithoutReportedGroupMessageInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedGroupMessageInput | ReportUpsertWithWhereUniqueWithoutReportedGroupMessageInput[]
    createMany?: ReportCreateManyReportedGroupMessageInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedGroupMessageInput | ReportUpdateWithWhereUniqueWithoutReportedGroupMessageInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedGroupMessageInput | ReportUpdateManyWithWhereWithoutReportedGroupMessageInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type GroupMessageReactionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<GroupMessageReactionCreateWithoutMessageInput, GroupMessageReactionUncheckedCreateWithoutMessageInput> | GroupMessageReactionCreateWithoutMessageInput[] | GroupMessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: GroupMessageReactionCreateOrConnectWithoutMessageInput | GroupMessageReactionCreateOrConnectWithoutMessageInput[]
    upsert?: GroupMessageReactionUpsertWithWhereUniqueWithoutMessageInput | GroupMessageReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: GroupMessageReactionCreateManyMessageInputEnvelope
    set?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    disconnect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    delete?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    connect?: GroupMessageReactionWhereUniqueInput | GroupMessageReactionWhereUniqueInput[]
    update?: GroupMessageReactionUpdateWithWhereUniqueWithoutMessageInput | GroupMessageReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: GroupMessageReactionUpdateManyWithWhereWithoutMessageInput | GroupMessageReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: GroupMessageReactionScalarWhereInput | GroupMessageReactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountDeletionTokenInput = {
    create?: XOR<UserCreateWithoutAccountDeletionTokenInput, UserUncheckedCreateWithoutAccountDeletionTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountDeletionTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountDeletionTokenNestedInput = {
    create?: XOR<UserCreateWithoutAccountDeletionTokenInput, UserUncheckedCreateWithoutAccountDeletionTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountDeletionTokenInput
    upsert?: UserUpsertWithoutAccountDeletionTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountDeletionTokenInput, UserUpdateWithoutAccountDeletionTokenInput>, UserUncheckedUpdateWithoutAccountDeletionTokenInput>
  }

  export type UserCreateNestedOneWithoutEmailChangeTokenInput = {
    create?: XOR<UserCreateWithoutEmailChangeTokenInput, UserUncheckedCreateWithoutEmailChangeTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailChangeTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailChangeTokenNestedInput = {
    create?: XOR<UserCreateWithoutEmailChangeTokenInput, UserUncheckedCreateWithoutEmailChangeTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailChangeTokenInput
    upsert?: UserUpsertWithoutEmailChangeTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailChangeTokenInput, UserUpdateWithoutEmailChangeTokenInput>, UserUncheckedUpdateWithoutEmailChangeTokenInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type VenueGroupMessageCreateNestedOneWithoutReactionsInput = {
    create?: XOR<VenueGroupMessageCreateWithoutReactionsInput, VenueGroupMessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutReactionsInput
    connect?: VenueGroupMessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupMessageReactionsInput = {
    create?: XOR<UserCreateWithoutGroupMessageReactionsInput, UserUncheckedCreateWithoutGroupMessageReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMessageReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type VenueGroupMessageUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<VenueGroupMessageCreateWithoutReactionsInput, VenueGroupMessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: VenueGroupMessageCreateOrConnectWithoutReactionsInput
    upsert?: VenueGroupMessageUpsertWithoutReactionsInput
    connect?: VenueGroupMessageWhereUniqueInput
    update?: XOR<XOR<VenueGroupMessageUpdateToOneWithWhereWithoutReactionsInput, VenueGroupMessageUpdateWithoutReactionsInput>, VenueGroupMessageUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutGroupMessageReactionsNestedInput = {
    create?: XOR<UserCreateWithoutGroupMessageReactionsInput, UserUncheckedCreateWithoutGroupMessageReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupMessageReactionsInput
    upsert?: UserUpsertWithoutGroupMessageReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupMessageReactionsInput, UserUpdateWithoutGroupMessageReactionsInput>, UserUncheckedUpdateWithoutGroupMessageReactionsInput>
  }

  export type UserCreateNestedOneWithoutCheckInHistoryInput = {
    create?: XOR<UserCreateWithoutCheckInHistoryInput, UserUncheckedCreateWithoutCheckInHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckInHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutCheckInHistoryInput = {
    create?: XOR<VenueCreateWithoutCheckInHistoryInput, VenueUncheckedCreateWithoutCheckInHistoryInput>
    connectOrCreate?: VenueCreateOrConnectWithoutCheckInHistoryInput
    connect?: VenueWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCheckInHistoryNestedInput = {
    create?: XOR<UserCreateWithoutCheckInHistoryInput, UserUncheckedCreateWithoutCheckInHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCheckInHistoryInput
    upsert?: UserUpsertWithoutCheckInHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCheckInHistoryInput, UserUpdateWithoutCheckInHistoryInput>, UserUncheckedUpdateWithoutCheckInHistoryInput>
  }

  export type VenueUpdateOneRequiredWithoutCheckInHistoryNestedInput = {
    create?: XOR<VenueCreateWithoutCheckInHistoryInput, VenueUncheckedCreateWithoutCheckInHistoryInput>
    connectOrCreate?: VenueCreateOrConnectWithoutCheckInHistoryInput
    upsert?: VenueUpsertWithoutCheckInHistoryInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutCheckInHistoryInput, VenueUpdateWithoutCheckInHistoryInput>, VenueUncheckedUpdateWithoutCheckInHistoryInput>
  }

  export type BadgeRuleCreateNestedOneWithoutBadgesInput = {
    create?: XOR<BadgeRuleCreateWithoutBadgesInput, BadgeRuleUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeRuleCreateOrConnectWithoutBadgesInput
    connect?: BadgeRuleWhereUniqueInput
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type BadgeRuleUpdateOneWithoutBadgesNestedInput = {
    create?: XOR<BadgeRuleCreateWithoutBadgesInput, BadgeRuleUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeRuleCreateOrConnectWithoutBadgesInput
    upsert?: BadgeRuleUpsertWithoutBadgesInput
    disconnect?: BadgeRuleWhereInput | boolean
    delete?: BadgeRuleWhereInput | boolean
    connect?: BadgeRuleWhereUniqueInput
    update?: XOR<XOR<BadgeRuleUpdateToOneWithWhereWithoutBadgesInput, BadgeRuleUpdateWithoutBadgesInput>, BadgeRuleUncheckedUpdateWithoutBadgesInput>
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutUsersInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutUsersInput
    upsert?: BadgeUpsertWithoutUsersInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutUsersInput, BadgeUpdateWithoutUsersInput>, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeCreateNestedManyWithoutRuleInput = {
    create?: XOR<BadgeCreateWithoutRuleInput, BadgeUncheckedCreateWithoutRuleInput> | BadgeCreateWithoutRuleInput[] | BadgeUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutRuleInput | BadgeCreateOrConnectWithoutRuleInput[]
    createMany?: BadgeCreateManyRuleInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<BadgeCreateWithoutRuleInput, BadgeUncheckedCreateWithoutRuleInput> | BadgeCreateWithoutRuleInput[] | BadgeUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutRuleInput | BadgeCreateOrConnectWithoutRuleInput[]
    createMany?: BadgeCreateManyRuleInputEnvelope
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
  }

  export type BadgeUpdateManyWithoutRuleNestedInput = {
    create?: XOR<BadgeCreateWithoutRuleInput, BadgeUncheckedCreateWithoutRuleInput> | BadgeCreateWithoutRuleInput[] | BadgeUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutRuleInput | BadgeCreateOrConnectWithoutRuleInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutRuleInput | BadgeUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: BadgeCreateManyRuleInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutRuleInput | BadgeUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutRuleInput | BadgeUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type BadgeUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<BadgeCreateWithoutRuleInput, BadgeUncheckedCreateWithoutRuleInput> | BadgeCreateWithoutRuleInput[] | BadgeUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: BadgeCreateOrConnectWithoutRuleInput | BadgeCreateOrConnectWithoutRuleInput[]
    upsert?: BadgeUpsertWithWhereUniqueWithoutRuleInput | BadgeUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: BadgeCreateManyRuleInputEnvelope
    set?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    disconnect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    delete?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    connect?: BadgeWhereUniqueInput | BadgeWhereUniqueInput[]
    update?: BadgeUpdateWithWhereUniqueWithoutRuleInput | BadgeUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: BadgeUpdateManyWithWhereWithoutRuleInput | BadgeUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
  }

  export type ChallengeInstanceCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ChallengeInstanceCreateWithoutTemplateInput, ChallengeInstanceUncheckedCreateWithoutTemplateInput> | ChallengeInstanceCreateWithoutTemplateInput[] | ChallengeInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutTemplateInput | ChallengeInstanceCreateOrConnectWithoutTemplateInput[]
    createMany?: ChallengeInstanceCreateManyTemplateInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type ChallengeInstanceUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ChallengeInstanceCreateWithoutTemplateInput, ChallengeInstanceUncheckedCreateWithoutTemplateInput> | ChallengeInstanceCreateWithoutTemplateInput[] | ChallengeInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutTemplateInput | ChallengeInstanceCreateOrConnectWithoutTemplateInput[]
    createMany?: ChallengeInstanceCreateManyTemplateInputEnvelope
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
  }

  export type ChallengeInstanceUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutTemplateInput, ChallengeInstanceUncheckedCreateWithoutTemplateInput> | ChallengeInstanceCreateWithoutTemplateInput[] | ChallengeInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutTemplateInput | ChallengeInstanceCreateOrConnectWithoutTemplateInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutTemplateInput | ChallengeInstanceUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ChallengeInstanceCreateManyTemplateInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutTemplateInput | ChallengeInstanceUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutTemplateInput | ChallengeInstanceUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ChallengeInstanceCreateWithoutTemplateInput, ChallengeInstanceUncheckedCreateWithoutTemplateInput> | ChallengeInstanceCreateWithoutTemplateInput[] | ChallengeInstanceUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ChallengeInstanceCreateOrConnectWithoutTemplateInput | ChallengeInstanceCreateOrConnectWithoutTemplateInput[]
    upsert?: ChallengeInstanceUpsertWithWhereUniqueWithoutTemplateInput | ChallengeInstanceUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ChallengeInstanceCreateManyTemplateInputEnvelope
    set?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    disconnect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    delete?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    connect?: ChallengeInstanceWhereUniqueInput | ChallengeInstanceWhereUniqueInput[]
    update?: ChallengeInstanceUpdateWithWhereUniqueWithoutTemplateInput | ChallengeInstanceUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ChallengeInstanceUpdateManyWithWhereWithoutTemplateInput | ChallengeInstanceUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
  }

  export type ChallengeTemplateCreateNestedOneWithoutInstancesInput = {
    create?: XOR<ChallengeTemplateCreateWithoutInstancesInput, ChallengeTemplateUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ChallengeTemplateCreateOrConnectWithoutInstancesInput
    connect?: ChallengeTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentChallengesInput = {
    create?: XOR<UserCreateWithoutSentChallengesInput, UserUncheckedCreateWithoutSentChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedChallengesInput = {
    create?: XOR<UserCreateWithoutReceivedChallengesInput, UserUncheckedCreateWithoutReceivedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedChallengesInput
    connect?: UserWhereUniqueInput
  }

  export type ConnectionCreateNestedOneWithoutChallengesInput = {
    create?: XOR<ConnectionCreateWithoutChallengesInput, ConnectionUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: ConnectionCreateOrConnectWithoutChallengesInput
    connect?: ConnectionWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutChallengesInput = {
    create?: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutChallengesInput
    connect?: VenueWhereUniqueInput
  }

  export type EnumChallengeInstanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeInstanceStatus
  }

  export type ChallengeTemplateUpdateOneRequiredWithoutInstancesNestedInput = {
    create?: XOR<ChallengeTemplateCreateWithoutInstancesInput, ChallengeTemplateUncheckedCreateWithoutInstancesInput>
    connectOrCreate?: ChallengeTemplateCreateOrConnectWithoutInstancesInput
    upsert?: ChallengeTemplateUpsertWithoutInstancesInput
    connect?: ChallengeTemplateWhereUniqueInput
    update?: XOR<XOR<ChallengeTemplateUpdateToOneWithWhereWithoutInstancesInput, ChallengeTemplateUpdateWithoutInstancesInput>, ChallengeTemplateUncheckedUpdateWithoutInstancesInput>
  }

  export type UserUpdateOneRequiredWithoutSentChallengesNestedInput = {
    create?: XOR<UserCreateWithoutSentChallengesInput, UserUncheckedCreateWithoutSentChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentChallengesInput
    upsert?: UserUpsertWithoutSentChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentChallengesInput, UserUpdateWithoutSentChallengesInput>, UserUncheckedUpdateWithoutSentChallengesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedChallengesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedChallengesInput, UserUncheckedCreateWithoutReceivedChallengesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedChallengesInput
    upsert?: UserUpsertWithoutReceivedChallengesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedChallengesInput, UserUpdateWithoutReceivedChallengesInput>, UserUncheckedUpdateWithoutReceivedChallengesInput>
  }

  export type ConnectionUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<ConnectionCreateWithoutChallengesInput, ConnectionUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: ConnectionCreateOrConnectWithoutChallengesInput
    upsert?: ConnectionUpsertWithoutChallengesInput
    connect?: ConnectionWhereUniqueInput
    update?: XOR<XOR<ConnectionUpdateToOneWithWhereWithoutChallengesInput, ConnectionUpdateWithoutChallengesInput>, ConnectionUncheckedUpdateWithoutChallengesInput>
  }

  export type VenueUpdateOneRequiredWithoutChallengesNestedInput = {
    create?: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutChallengesInput
    upsert?: VenueUpsertWithoutChallengesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutChallengesInput, VenueUpdateWithoutChallengesInput>, VenueUncheckedUpdateWithoutChallengesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumOptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OptionType[]
    notIn?: $Enums.OptionType[]
    not?: NestedEnumOptionTypeFilter<$PrismaModel> | $Enums.OptionType
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumOptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OptionType | EnumOptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OptionType[]
    notIn?: $Enums.OptionType[]
    not?: NestedEnumOptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.OptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOptionTypeFilter<$PrismaModel>
    _max?: NestedEnumOptionTypeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[]
    notIn?: $Enums.AuthProvider[]
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumSubscriptionPlanFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanFilter<$PrismaModel> | $Enums.SubscriptionPlan
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[]
    notIn?: $Enums.AuthProvider[]
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionPlan | EnumSubscriptionPlanFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionPlan[]
    notIn?: $Enums.SubscriptionPlan[]
    not?: NestedEnumSubscriptionPlanWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionPlan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionPlanFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPersonalityTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | null
    notIn?: $Enums.PersonalityType[] | null
    not?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel> | $Enums.PersonalityType | null
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonalityType | EnumPersonalityTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PersonalityType[] | null
    notIn?: $Enums.PersonalityType[] | null
    not?: NestedEnumPersonalityTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PersonalityType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPersonalityTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[]
    notIn?: $Enums.VerificationStatus[]
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumVenueCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueCategory | EnumVenueCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VenueCategory[]
    notIn?: $Enums.VenueCategory[]
    not?: NestedEnumVenueCategoryFilter<$PrismaModel> | $Enums.VenueCategory
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumVenueCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueCategory | EnumVenueCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.VenueCategory[]
    notIn?: $Enums.VenueCategory[]
    not?: NestedEnumVenueCategoryWithAggregatesFilter<$PrismaModel> | $Enums.VenueCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVenueCategoryFilter<$PrismaModel>
    _max?: NestedEnumVenueCategoryFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumIcebreakerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IcebreakerCategory | EnumIcebreakerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IcebreakerCategory[]
    notIn?: $Enums.IcebreakerCategory[]
    not?: NestedEnumIcebreakerCategoryFilter<$PrismaModel> | $Enums.IcebreakerCategory
  }

  export type NestedEnumIcebreakerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IcebreakerCategory | EnumIcebreakerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IcebreakerCategory[]
    notIn?: $Enums.IcebreakerCategory[]
    not?: NestedEnumIcebreakerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IcebreakerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIcebreakerCategoryFilter<$PrismaModel>
    _max?: NestedEnumIcebreakerCategoryFilter<$PrismaModel>
  }

  export type NestedEnumChallengeInstanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeInstanceStatus | EnumChallengeInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeInstanceStatus[]
    notIn?: $Enums.ChallengeInstanceStatus[]
    not?: NestedEnumChallengeInstanceStatusFilter<$PrismaModel> | $Enums.ChallengeInstanceStatus
  }

  export type NestedEnumChallengeInstanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeInstanceStatus | EnumChallengeInstanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeInstanceStatus[]
    notIn?: $Enums.ChallengeInstanceStatus[]
    not?: NestedEnumChallengeInstanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeInstanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeInstanceStatusFilter<$PrismaModel>
    _max?: NestedEnumChallengeInstanceStatusFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutSexualOrientationInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
    interests?: InterestCreateNestedManyWithoutProfilesInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
    relationshipGoal?: ProfileOptionCreateNestedOneWithoutProfilesByGoalInput
  }

  export type ProfileUncheckedCreateWithoutSexualOrientationInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    relationshipGoalId?: number | null
    interests?: InterestUncheckedCreateNestedManyWithoutProfilesInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutSexualOrientationInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSexualOrientationInput, ProfileUncheckedCreateWithoutSexualOrientationInput>
  }

  export type ProfileCreateManySexualOrientationInputEnvelope = {
    data: ProfileCreateManySexualOrientationInput | ProfileCreateManySexualOrientationInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutRelationshipGoalInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
    interests?: InterestCreateNestedManyWithoutProfilesInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
    sexualOrientation?: ProfileOptionCreateNestedOneWithoutProfilesByOrientationInput
  }

  export type ProfileUncheckedCreateWithoutRelationshipGoalInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
    interests?: InterestUncheckedCreateNestedManyWithoutProfilesInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutRelationshipGoalInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutRelationshipGoalInput, ProfileUncheckedCreateWithoutRelationshipGoalInput>
  }

  export type ProfileCreateManyRelationshipGoalInputEnvelope = {
    data: ProfileCreateManyRelationshipGoalInput | ProfileCreateManyRelationshipGoalInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithWhereUniqueWithoutSexualOrientationInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutSexualOrientationInput, ProfileUncheckedUpdateWithoutSexualOrientationInput>
    create: XOR<ProfileCreateWithoutSexualOrientationInput, ProfileUncheckedCreateWithoutSexualOrientationInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutSexualOrientationInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutSexualOrientationInput, ProfileUncheckedUpdateWithoutSexualOrientationInput>
  }

  export type ProfileUpdateManyWithWhereWithoutSexualOrientationInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutSexualOrientationInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    age?: IntFilter<"Profile"> | number
    gender?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    university?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    personality?: EnumPersonalityTypeNullableFilter<"Profile"> | $Enums.PersonalityType | null
    userId?: StringFilter<"Profile"> | string
    phoneNumber?: StringNullableFilter<"Profile"> | string | null
    extraSignalCredits?: IntFilter<"Profile"> | number
    hideViewFootprints?: BoolFilter<"Profile"> | boolean
    preferredMinAge?: IntNullableFilter<"Profile"> | number | null
    preferredMaxAge?: IntNullableFilter<"Profile"> | number | null
    notifyOnNewSignal?: BoolFilter<"Profile"> | boolean
    notifyOnNewMatch?: BoolFilter<"Profile"> | boolean
    notifyOnNewMessage?: BoolFilter<"Profile"> | boolean
    isVerified?: BoolFilter<"Profile"> | boolean
    verificationStatus?: EnumVerificationStatusFilter<"Profile"> | $Enums.VerificationStatus
    verificationPhotoUrl?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    provisionalSignalsUsed?: IntFilter<"Profile"> | number
    currentStatus?: StringNullableFilter<"Profile"> | string | null
    statusExpiresAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    sexualOrientationId?: IntNullableFilter<"Profile"> | number | null
    relationshipGoalId?: IntNullableFilter<"Profile"> | number | null
  }

  export type ProfileUpsertWithWhereUniqueWithoutRelationshipGoalInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutRelationshipGoalInput, ProfileUncheckedUpdateWithoutRelationshipGoalInput>
    create: XOR<ProfileCreateWithoutRelationshipGoalInput, ProfileUncheckedCreateWithoutRelationshipGoalInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutRelationshipGoalInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutRelationshipGoalInput, ProfileUncheckedUpdateWithoutRelationshipGoalInput>
  }

  export type ProfileUpdateManyWithWhereWithoutRelationshipGoalInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutRelationshipGoalInput>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    interests?: InterestCreateNestedManyWithoutProfilesInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
    sexualOrientation?: ProfileOptionCreateNestedOneWithoutProfilesByOrientationInput
    relationshipGoal?: ProfileOptionCreateNestedOneWithoutProfilesByGoalInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
    relationshipGoalId?: number | null
    interests?: InterestUncheckedCreateNestedManyWithoutProfilesInput
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ActiveSessionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    venue: VenueCreateNestedOneWithoutActiveSessionsInput
  }

  export type ActiveSessionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    venueId: number
  }

  export type ActiveSessionCreateOrConnectWithoutUserInput = {
    where: ActiveSessionWhereUniqueInput
    create: XOR<ActiveSessionCreateWithoutUserInput, ActiveSessionUncheckedCreateWithoutUserInput>
  }

  export type SignalCreateWithoutSenderInput = {
    createdAt?: Date | string
    receiver: UserCreateNestedOneWithoutReceivedSignalsInput
  }

  export type SignalUncheckedCreateWithoutSenderInput = {
    id?: number
    createdAt?: Date | string
    receiverId: string
  }

  export type SignalCreateOrConnectWithoutSenderInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutSenderInput, SignalUncheckedCreateWithoutSenderInput>
  }

  export type SignalCreateManySenderInputEnvelope = {
    data: SignalCreateManySenderInput | SignalCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type SignalCreateWithoutReceiverInput = {
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentSignalsInput
  }

  export type SignalUncheckedCreateWithoutReceiverInput = {
    id?: number
    createdAt?: Date | string
    senderId: string
  }

  export type SignalCreateOrConnectWithoutReceiverInput = {
    where: SignalWhereUniqueInput
    create: XOR<SignalCreateWithoutReceiverInput, SignalUncheckedCreateWithoutReceiverInput>
  }

  export type SignalCreateManyReceiverInputEnvelope = {
    data: SignalCreateManyReceiverInput | SignalCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutUserAInput = {
    createdAt?: Date | string
    userB: UserCreateNestedOneWithoutConnectionsBInput
    messages?: MessageCreateNestedManyWithoutConnectionInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionUncheckedCreateWithoutUserAInput = {
    id?: number
    createdAt?: Date | string
    userBId: string
    messages?: MessageUncheckedCreateNestedManyWithoutConnectionInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionCreateOrConnectWithoutUserAInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutUserAInput, ConnectionUncheckedCreateWithoutUserAInput>
  }

  export type ConnectionCreateManyUserAInputEnvelope = {
    data: ConnectionCreateManyUserAInput | ConnectionCreateManyUserAInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutUserBInput = {
    createdAt?: Date | string
    userA: UserCreateNestedOneWithoutConnectionsAInput
    messages?: MessageCreateNestedManyWithoutConnectionInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionUncheckedCreateWithoutUserBInput = {
    id?: number
    createdAt?: Date | string
    userAId: string
    messages?: MessageUncheckedCreateNestedManyWithoutConnectionInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionCreateOrConnectWithoutUserBInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutUserBInput, ConnectionUncheckedCreateWithoutUserBInput>
  }

  export type ConnectionCreateManyUserBInputEnvelope = {
    data: ConnectionCreateManyUserBInput | ConnectionCreateManyUserBInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean
    connection: ConnectionCreateNestedOneWithoutMessagesInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    connectionId: number
    isRead?: boolean
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockedInput = {
    createdAt?: Date | string
    blocker: UserCreateNestedOneWithoutBlockingInput
  }

  export type BlockUncheckedCreateWithoutBlockedInput = {
    id?: number
    createdAt?: Date | string
    blockerId: string
  }

  export type BlockCreateOrConnectWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockCreateManyBlockedInputEnvelope = {
    data: BlockCreateManyBlockedInput | BlockCreateManyBlockedInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockerInput = {
    createdAt?: Date | string
    blocked: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockUncheckedCreateWithoutBlockerInput = {
    id?: number
    createdAt?: Date | string
    blockedId: string
  }

  export type BlockCreateOrConnectWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockCreateManyBlockerInputEnvelope = {
    data: BlockCreateManyBlockerInput | BlockCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReporterInput = {
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reportedGroupMessage?: VenueGroupMessageCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReporterInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedUserId: string
    reportedMessageId?: number | null
    reportedGroupMessageId?: number | null
  }

  export type ReportCreateOrConnectWithoutReporterInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportCreateManyReporterInputEnvelope = {
    data: ReportCreateManyReporterInput | ReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutReportedUserInput = {
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
    reportedGroupMessage?: VenueGroupMessageCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedUserInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedMessageId?: number | null
    reportedGroupMessageId?: number | null
  }

  export type ReportCreateOrConnectWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportCreateManyReportedUserInputEnvelope = {
    data: ReportCreateManyReportedUserInput | ReportCreateManyReportedUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
  }

  export type DeviceUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
  }

  export type DeviceCreateOrConnectWithoutUserInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceCreateManyUserInputEnvelope = {
    data: DeviceCreateManyUserInput | DeviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedbackCreateWithoutAuthorInput = {
    description: string
    screenshotUrl?: string | null
    createdAt?: Date | string
  }

  export type FeedbackUncheckedCreateWithoutAuthorInput = {
    id?: number
    description: string
    screenshotUrl?: string | null
    createdAt?: Date | string
  }

  export type FeedbackCreateOrConnectWithoutAuthorInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutAuthorInput, FeedbackUncheckedCreateWithoutAuthorInput>
  }

  export type FeedbackCreateManyAuthorInputEnvelope = {
    data: FeedbackCreateManyAuthorInput | FeedbackCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type AuditLogCreateWithoutActorInput = {
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: number
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type BroadcastNotificationCreateWithoutSentByInput = {
    title: string
    body: string
    createdAt?: Date | string
  }

  export type BroadcastNotificationUncheckedCreateWithoutSentByInput = {
    id?: number
    title: string
    body: string
    createdAt?: Date | string
  }

  export type BroadcastNotificationCreateOrConnectWithoutSentByInput = {
    where: BroadcastNotificationWhereUniqueInput
    create: XOR<BroadcastNotificationCreateWithoutSentByInput, BroadcastNotificationUncheckedCreateWithoutSentByInput>
  }

  export type BroadcastNotificationCreateManySentByInputEnvelope = {
    data: BroadcastNotificationCreateManySentByInput | BroadcastNotificationCreateManySentByInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileViewCreateWithoutViewerInput = {
    createdAt?: Date | string
    viewed: UserCreateNestedOneWithoutViewsReceivedInput
  }

  export type ProfileViewUncheckedCreateWithoutViewerInput = {
    id?: number
    viewedId: string
    createdAt?: Date | string
  }

  export type ProfileViewCreateOrConnectWithoutViewerInput = {
    where: ProfileViewWhereUniqueInput
    create: XOR<ProfileViewCreateWithoutViewerInput, ProfileViewUncheckedCreateWithoutViewerInput>
  }

  export type ProfileViewCreateManyViewerInputEnvelope = {
    data: ProfileViewCreateManyViewerInput | ProfileViewCreateManyViewerInput[]
    skipDuplicates?: boolean
  }

  export type ProfileViewCreateWithoutViewedInput = {
    createdAt?: Date | string
    viewer: UserCreateNestedOneWithoutViewsMadeInput
  }

  export type ProfileViewUncheckedCreateWithoutViewedInput = {
    id?: number
    viewerId: string
    createdAt?: Date | string
  }

  export type ProfileViewCreateOrConnectWithoutViewedInput = {
    where: ProfileViewWhereUniqueInput
    create: XOR<ProfileViewCreateWithoutViewedInput, ProfileViewUncheckedCreateWithoutViewedInput>
  }

  export type ProfileViewCreateManyViewedInputEnvelope = {
    data: ProfileViewCreateManyViewedInput | ProfileViewCreateManyViewedInput[]
    skipDuplicates?: boolean
  }

  export type VenueGroupMessageCreateWithoutSenderInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    reports?: ReportCreateNestedManyWithoutReportedGroupMessageInput
    reactions?: GroupMessageReactionCreateNestedManyWithoutMessageInput
    venue: VenueCreateNestedOneWithoutGroupMessagesInput
  }

  export type VenueGroupMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    venueId: number
    reports?: ReportUncheckedCreateNestedManyWithoutReportedGroupMessageInput
    reactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type VenueGroupMessageCreateOrConnectWithoutSenderInput = {
    where: VenueGroupMessageWhereUniqueInput
    create: XOR<VenueGroupMessageCreateWithoutSenderInput, VenueGroupMessageUncheckedCreateWithoutSenderInput>
  }

  export type VenueGroupMessageCreateManySenderInputEnvelope = {
    data: VenueGroupMessageCreateManySenderInput | VenueGroupMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type AccountDeletionTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AccountDeletionTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AccountDeletionTokenCreateOrConnectWithoutUserInput = {
    where: AccountDeletionTokenWhereUniqueInput
    create: XOR<AccountDeletionTokenCreateWithoutUserInput, AccountDeletionTokenUncheckedCreateWithoutUserInput>
  }

  export type EmailChangeTokenCreateWithoutUserInput = {
    token: string
    newEmail: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailChangeTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    newEmail: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type EmailChangeTokenCreateOrConnectWithoutUserInput = {
    where: EmailChangeTokenWhereUniqueInput
    create: XOR<EmailChangeTokenCreateWithoutUserInput, EmailChangeTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GroupMessageReactionCreateWithoutUserInput = {
    emoji: string
    createdAt?: Date | string
    message: VenueGroupMessageCreateNestedOneWithoutReactionsInput
  }

  export type GroupMessageReactionUncheckedCreateWithoutUserInput = {
    id?: number
    emoji: string
    createdAt?: Date | string
    messageId: number
  }

  export type GroupMessageReactionCreateOrConnectWithoutUserInput = {
    where: GroupMessageReactionWhereUniqueInput
    create: XOR<GroupMessageReactionCreateWithoutUserInput, GroupMessageReactionUncheckedCreateWithoutUserInput>
  }

  export type GroupMessageReactionCreateManyUserInputEnvelope = {
    data: GroupMessageReactionCreateManyUserInput | GroupMessageReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CheckInHistoryCreateWithoutUserInput = {
    createdAt?: Date | string
    venue: VenueCreateNestedOneWithoutCheckInHistoryInput
  }

  export type CheckInHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    venueId: number
  }

  export type CheckInHistoryCreateOrConnectWithoutUserInput = {
    where: CheckInHistoryWhereUniqueInput
    create: XOR<CheckInHistoryCreateWithoutUserInput, CheckInHistoryUncheckedCreateWithoutUserInput>
  }

  export type CheckInHistoryCreateManyUserInputEnvelope = {
    data: CheckInHistoryCreateManyUserInput | CheckInHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutUserInput = {
    createdAt?: Date | string
    badge: BadgeCreateNestedOneWithoutUsersInput
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    badgeId: number
    createdAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeInstanceCreateWithoutChallengerInput = {
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template: ChallengeTemplateCreateNestedOneWithoutInstancesInput
    challenged: UserCreateNestedOneWithoutReceivedChallengesInput
    connection: ConnectionCreateNestedOneWithoutChallengesInput
    venue: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeInstanceUncheckedCreateWithoutChallengerInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceCreateOrConnectWithoutChallengerInput = {
    where: ChallengeInstanceWhereUniqueInput
    create: XOR<ChallengeInstanceCreateWithoutChallengerInput, ChallengeInstanceUncheckedCreateWithoutChallengerInput>
  }

  export type ChallengeInstanceCreateManyChallengerInputEnvelope = {
    data: ChallengeInstanceCreateManyChallengerInput | ChallengeInstanceCreateManyChallengerInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeInstanceCreateWithoutChallengedInput = {
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template: ChallengeTemplateCreateNestedOneWithoutInstancesInput
    challenger: UserCreateNestedOneWithoutSentChallengesInput
    connection: ConnectionCreateNestedOneWithoutChallengesInput
    venue: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeInstanceUncheckedCreateWithoutChallengedInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceCreateOrConnectWithoutChallengedInput = {
    where: ChallengeInstanceWhereUniqueInput
    create: XOR<ChallengeInstanceCreateWithoutChallengedInput, ChallengeInstanceUncheckedCreateWithoutChallengedInput>
  }

  export type ChallengeInstanceCreateManyChallengedInputEnvelope = {
    data: ChallengeInstanceCreateManyChallengedInput | ChallengeInstanceCreateManyChallengedInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    interests?: InterestUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    sexualOrientation?: ProfileOptionUpdateOneWithoutProfilesByOrientationNestedInput
    relationshipGoal?: ProfileOptionUpdateOneWithoutProfilesByGoalNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: InterestUncheckedUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ActiveSessionUpsertWithoutUserInput = {
    update: XOR<ActiveSessionUpdateWithoutUserInput, ActiveSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ActiveSessionCreateWithoutUserInput, ActiveSessionUncheckedCreateWithoutUserInput>
    where?: ActiveSessionWhereInput
  }

  export type ActiveSessionUpdateToOneWithWhereWithoutUserInput = {
    where?: ActiveSessionWhereInput
    data: XOR<ActiveSessionUpdateWithoutUserInput, ActiveSessionUncheckedUpdateWithoutUserInput>
  }

  export type ActiveSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    venue?: VenueUpdateOneRequiredWithoutActiveSessionsNestedInput
  }

  export type ActiveSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type SignalUpsertWithWhereUniqueWithoutSenderInput = {
    where: SignalWhereUniqueInput
    update: XOR<SignalUpdateWithoutSenderInput, SignalUncheckedUpdateWithoutSenderInput>
    create: XOR<SignalCreateWithoutSenderInput, SignalUncheckedCreateWithoutSenderInput>
  }

  export type SignalUpdateWithWhereUniqueWithoutSenderInput = {
    where: SignalWhereUniqueInput
    data: XOR<SignalUpdateWithoutSenderInput, SignalUncheckedUpdateWithoutSenderInput>
  }

  export type SignalUpdateManyWithWhereWithoutSenderInput = {
    where: SignalScalarWhereInput
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyWithoutSenderInput>
  }

  export type SignalScalarWhereInput = {
    AND?: SignalScalarWhereInput | SignalScalarWhereInput[]
    OR?: SignalScalarWhereInput[]
    NOT?: SignalScalarWhereInput | SignalScalarWhereInput[]
    id?: IntFilter<"Signal"> | number
    createdAt?: DateTimeFilter<"Signal"> | Date | string
    senderId?: StringFilter<"Signal"> | string
    receiverId?: StringFilter<"Signal"> | string
  }

  export type SignalUpsertWithWhereUniqueWithoutReceiverInput = {
    where: SignalWhereUniqueInput
    update: XOR<SignalUpdateWithoutReceiverInput, SignalUncheckedUpdateWithoutReceiverInput>
    create: XOR<SignalCreateWithoutReceiverInput, SignalUncheckedCreateWithoutReceiverInput>
  }

  export type SignalUpdateWithWhereUniqueWithoutReceiverInput = {
    where: SignalWhereUniqueInput
    data: XOR<SignalUpdateWithoutReceiverInput, SignalUncheckedUpdateWithoutReceiverInput>
  }

  export type SignalUpdateManyWithWhereWithoutReceiverInput = {
    where: SignalScalarWhereInput
    data: XOR<SignalUpdateManyMutationInput, SignalUncheckedUpdateManyWithoutReceiverInput>
  }

  export type ConnectionUpsertWithWhereUniqueWithoutUserAInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutUserAInput, ConnectionUncheckedUpdateWithoutUserAInput>
    create: XOR<ConnectionCreateWithoutUserAInput, ConnectionUncheckedCreateWithoutUserAInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutUserAInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutUserAInput, ConnectionUncheckedUpdateWithoutUserAInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutUserAInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutUserAInput>
  }

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    OR?: ConnectionScalarWhereInput[]
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    id?: IntFilter<"Connection"> | number
    createdAt?: DateTimeFilter<"Connection"> | Date | string
    userAId?: StringFilter<"Connection"> | string
    userBId?: StringFilter<"Connection"> | string
  }

  export type ConnectionUpsertWithWhereUniqueWithoutUserBInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutUserBInput, ConnectionUncheckedUpdateWithoutUserBInput>
    create: XOR<ConnectionCreateWithoutUserBInput, ConnectionUncheckedCreateWithoutUserBInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutUserBInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutUserBInput, ConnectionUncheckedUpdateWithoutUserBInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutUserBInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutUserBInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    content?: StringNullableFilter<"Message"> | string | null
    imageUrl?: StringNullableFilter<"Message"> | string | null
    audioUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    senderId?: StringFilter<"Message"> | string
    connectionId?: IntFilter<"Message"> | number
    isRead?: BoolFilter<"Message"> | boolean
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockedInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: IntFilter<"Block"> | number
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blockerId?: StringFilter<"Block"> | string
    blockedId?: StringFilter<"Block"> | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockerInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
    create: XOR<ReportCreateWithoutReporterInput, ReportUncheckedCreateWithoutReporterInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReporterInput, ReportUncheckedUpdateWithoutReporterInput>
  }

  export type ReportUpdateManyWithWhereWithoutReporterInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: IntFilter<"Report"> | number
    reason?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    reporterId?: StringFilter<"Report"> | string
    reportedUserId?: StringFilter<"Report"> | string
    reportedMessageId?: IntNullableFilter<"Report"> | number | null
    reportedGroupMessageId?: IntNullableFilter<"Report"> | number | null
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
    create: XOR<ReportCreateWithoutReportedUserInput, ReportUncheckedCreateWithoutReportedUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedUserInput, ReportUncheckedUpdateWithoutReportedUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedUserInput>
  }

  export type DeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUpdateManyWithWhereWithoutUserInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: IntFilter<"Device"> | number
    token?: StringFilter<"Device"> | string
    createdAt?: DateTimeFilter<"Device"> | Date | string
    userId?: StringFilter<"Device"> | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    content?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    userId?: StringFilter<"Notification"> | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutAuthorInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutAuthorInput, FeedbackUncheckedUpdateWithoutAuthorInput>
    create: XOR<FeedbackCreateWithoutAuthorInput, FeedbackUncheckedCreateWithoutAuthorInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutAuthorInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutAuthorInput, FeedbackUncheckedUpdateWithoutAuthorInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutAuthorInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutAuthorInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: IntFilter<"Feedback"> | number
    description?: StringFilter<"Feedback"> | string
    screenshotUrl?: StringNullableFilter<"Feedback"> | string | null
    createdAt?: DateTimeFilter<"Feedback"> | Date | string
    authorId?: StringFilter<"Feedback"> | string
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    actorId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BroadcastNotificationUpsertWithWhereUniqueWithoutSentByInput = {
    where: BroadcastNotificationWhereUniqueInput
    update: XOR<BroadcastNotificationUpdateWithoutSentByInput, BroadcastNotificationUncheckedUpdateWithoutSentByInput>
    create: XOR<BroadcastNotificationCreateWithoutSentByInput, BroadcastNotificationUncheckedCreateWithoutSentByInput>
  }

  export type BroadcastNotificationUpdateWithWhereUniqueWithoutSentByInput = {
    where: BroadcastNotificationWhereUniqueInput
    data: XOR<BroadcastNotificationUpdateWithoutSentByInput, BroadcastNotificationUncheckedUpdateWithoutSentByInput>
  }

  export type BroadcastNotificationUpdateManyWithWhereWithoutSentByInput = {
    where: BroadcastNotificationScalarWhereInput
    data: XOR<BroadcastNotificationUpdateManyMutationInput, BroadcastNotificationUncheckedUpdateManyWithoutSentByInput>
  }

  export type BroadcastNotificationScalarWhereInput = {
    AND?: BroadcastNotificationScalarWhereInput | BroadcastNotificationScalarWhereInput[]
    OR?: BroadcastNotificationScalarWhereInput[]
    NOT?: BroadcastNotificationScalarWhereInput | BroadcastNotificationScalarWhereInput[]
    id?: IntFilter<"BroadcastNotification"> | number
    title?: StringFilter<"BroadcastNotification"> | string
    body?: StringFilter<"BroadcastNotification"> | string
    createdAt?: DateTimeFilter<"BroadcastNotification"> | Date | string
    sentById?: StringFilter<"BroadcastNotification"> | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: IntFilter<"PasswordResetToken"> | number
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    userId?: StringFilter<"PasswordResetToken"> | string
  }

  export type ProfileViewUpsertWithWhereUniqueWithoutViewerInput = {
    where: ProfileViewWhereUniqueInput
    update: XOR<ProfileViewUpdateWithoutViewerInput, ProfileViewUncheckedUpdateWithoutViewerInput>
    create: XOR<ProfileViewCreateWithoutViewerInput, ProfileViewUncheckedCreateWithoutViewerInput>
  }

  export type ProfileViewUpdateWithWhereUniqueWithoutViewerInput = {
    where: ProfileViewWhereUniqueInput
    data: XOR<ProfileViewUpdateWithoutViewerInput, ProfileViewUncheckedUpdateWithoutViewerInput>
  }

  export type ProfileViewUpdateManyWithWhereWithoutViewerInput = {
    where: ProfileViewScalarWhereInput
    data: XOR<ProfileViewUpdateManyMutationInput, ProfileViewUncheckedUpdateManyWithoutViewerInput>
  }

  export type ProfileViewScalarWhereInput = {
    AND?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
    OR?: ProfileViewScalarWhereInput[]
    NOT?: ProfileViewScalarWhereInput | ProfileViewScalarWhereInput[]
    id?: IntFilter<"ProfileView"> | number
    viewerId?: StringFilter<"ProfileView"> | string
    viewedId?: StringFilter<"ProfileView"> | string
    createdAt?: DateTimeFilter<"ProfileView"> | Date | string
  }

  export type ProfileViewUpsertWithWhereUniqueWithoutViewedInput = {
    where: ProfileViewWhereUniqueInput
    update: XOR<ProfileViewUpdateWithoutViewedInput, ProfileViewUncheckedUpdateWithoutViewedInput>
    create: XOR<ProfileViewCreateWithoutViewedInput, ProfileViewUncheckedCreateWithoutViewedInput>
  }

  export type ProfileViewUpdateWithWhereUniqueWithoutViewedInput = {
    where: ProfileViewWhereUniqueInput
    data: XOR<ProfileViewUpdateWithoutViewedInput, ProfileViewUncheckedUpdateWithoutViewedInput>
  }

  export type ProfileViewUpdateManyWithWhereWithoutViewedInput = {
    where: ProfileViewScalarWhereInput
    data: XOR<ProfileViewUpdateManyMutationInput, ProfileViewUncheckedUpdateManyWithoutViewedInput>
  }

  export type VenueGroupMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: VenueGroupMessageWhereUniqueInput
    update: XOR<VenueGroupMessageUpdateWithoutSenderInput, VenueGroupMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<VenueGroupMessageCreateWithoutSenderInput, VenueGroupMessageUncheckedCreateWithoutSenderInput>
  }

  export type VenueGroupMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: VenueGroupMessageWhereUniqueInput
    data: XOR<VenueGroupMessageUpdateWithoutSenderInput, VenueGroupMessageUncheckedUpdateWithoutSenderInput>
  }

  export type VenueGroupMessageUpdateManyWithWhereWithoutSenderInput = {
    where: VenueGroupMessageScalarWhereInput
    data: XOR<VenueGroupMessageUpdateManyMutationInput, VenueGroupMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type VenueGroupMessageScalarWhereInput = {
    AND?: VenueGroupMessageScalarWhereInput | VenueGroupMessageScalarWhereInput[]
    OR?: VenueGroupMessageScalarWhereInput[]
    NOT?: VenueGroupMessageScalarWhereInput | VenueGroupMessageScalarWhereInput[]
    id?: IntFilter<"VenueGroupMessage"> | number
    content?: StringNullableFilter<"VenueGroupMessage"> | string | null
    imageUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    audioUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    videoUrl?: StringNullableFilter<"VenueGroupMessage"> | string | null
    createdAt?: DateTimeFilter<"VenueGroupMessage"> | Date | string
    venueId?: IntFilter<"VenueGroupMessage"> | number
    senderId?: StringFilter<"VenueGroupMessage"> | string
  }

  export type AccountDeletionTokenUpsertWithoutUserInput = {
    update: XOR<AccountDeletionTokenUpdateWithoutUserInput, AccountDeletionTokenUncheckedUpdateWithoutUserInput>
    create: XOR<AccountDeletionTokenCreateWithoutUserInput, AccountDeletionTokenUncheckedCreateWithoutUserInput>
    where?: AccountDeletionTokenWhereInput
  }

  export type AccountDeletionTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountDeletionTokenWhereInput
    data: XOR<AccountDeletionTokenUpdateWithoutUserInput, AccountDeletionTokenUncheckedUpdateWithoutUserInput>
  }

  export type AccountDeletionTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountDeletionTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeTokenUpsertWithoutUserInput = {
    update: XOR<EmailChangeTokenUpdateWithoutUserInput, EmailChangeTokenUncheckedUpdateWithoutUserInput>
    create: XOR<EmailChangeTokenCreateWithoutUserInput, EmailChangeTokenUncheckedCreateWithoutUserInput>
    where?: EmailChangeTokenWhereInput
  }

  export type EmailChangeTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: EmailChangeTokenWhereInput
    data: XOR<EmailChangeTokenUpdateWithoutUserInput, EmailChangeTokenUncheckedUpdateWithoutUserInput>
  }

  export type EmailChangeTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: IntFilter<"RefreshToken"> | number
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    userId?: StringFilter<"RefreshToken"> | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type GroupMessageReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: GroupMessageReactionWhereUniqueInput
    update: XOR<GroupMessageReactionUpdateWithoutUserInput, GroupMessageReactionUncheckedUpdateWithoutUserInput>
    create: XOR<GroupMessageReactionCreateWithoutUserInput, GroupMessageReactionUncheckedCreateWithoutUserInput>
  }

  export type GroupMessageReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: GroupMessageReactionWhereUniqueInput
    data: XOR<GroupMessageReactionUpdateWithoutUserInput, GroupMessageReactionUncheckedUpdateWithoutUserInput>
  }

  export type GroupMessageReactionUpdateManyWithWhereWithoutUserInput = {
    where: GroupMessageReactionScalarWhereInput
    data: XOR<GroupMessageReactionUpdateManyMutationInput, GroupMessageReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type GroupMessageReactionScalarWhereInput = {
    AND?: GroupMessageReactionScalarWhereInput | GroupMessageReactionScalarWhereInput[]
    OR?: GroupMessageReactionScalarWhereInput[]
    NOT?: GroupMessageReactionScalarWhereInput | GroupMessageReactionScalarWhereInput[]
    id?: IntFilter<"GroupMessageReaction"> | number
    emoji?: StringFilter<"GroupMessageReaction"> | string
    createdAt?: DateTimeFilter<"GroupMessageReaction"> | Date | string
    messageId?: IntFilter<"GroupMessageReaction"> | number
    userId?: StringFilter<"GroupMessageReaction"> | string
  }

  export type CheckInHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CheckInHistoryWhereUniqueInput
    update: XOR<CheckInHistoryUpdateWithoutUserInput, CheckInHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<CheckInHistoryCreateWithoutUserInput, CheckInHistoryUncheckedCreateWithoutUserInput>
  }

  export type CheckInHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CheckInHistoryWhereUniqueInput
    data: XOR<CheckInHistoryUpdateWithoutUserInput, CheckInHistoryUncheckedUpdateWithoutUserInput>
  }

  export type CheckInHistoryUpdateManyWithWhereWithoutUserInput = {
    where: CheckInHistoryScalarWhereInput
    data: XOR<CheckInHistoryUpdateManyMutationInput, CheckInHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CheckInHistoryScalarWhereInput = {
    AND?: CheckInHistoryScalarWhereInput | CheckInHistoryScalarWhereInput[]
    OR?: CheckInHistoryScalarWhereInput[]
    NOT?: CheckInHistoryScalarWhereInput | CheckInHistoryScalarWhereInput[]
    id?: IntFilter<"CheckInHistory"> | number
    createdAt?: DateTimeFilter<"CheckInHistory"> | Date | string
    userId?: StringFilter<"CheckInHistory"> | string
    venueId?: IntFilter<"CheckInHistory"> | number
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeId?: IntFilter<"UserBadge"> | number
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type ChallengeInstanceUpsertWithWhereUniqueWithoutChallengerInput = {
    where: ChallengeInstanceWhereUniqueInput
    update: XOR<ChallengeInstanceUpdateWithoutChallengerInput, ChallengeInstanceUncheckedUpdateWithoutChallengerInput>
    create: XOR<ChallengeInstanceCreateWithoutChallengerInput, ChallengeInstanceUncheckedCreateWithoutChallengerInput>
  }

  export type ChallengeInstanceUpdateWithWhereUniqueWithoutChallengerInput = {
    where: ChallengeInstanceWhereUniqueInput
    data: XOR<ChallengeInstanceUpdateWithoutChallengerInput, ChallengeInstanceUncheckedUpdateWithoutChallengerInput>
  }

  export type ChallengeInstanceUpdateManyWithWhereWithoutChallengerInput = {
    where: ChallengeInstanceScalarWhereInput
    data: XOR<ChallengeInstanceUpdateManyMutationInput, ChallengeInstanceUncheckedUpdateManyWithoutChallengerInput>
  }

  export type ChallengeInstanceScalarWhereInput = {
    AND?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
    OR?: ChallengeInstanceScalarWhereInput[]
    NOT?: ChallengeInstanceScalarWhereInput | ChallengeInstanceScalarWhereInput[]
    id?: IntFilter<"ChallengeInstance"> | number
    status?: EnumChallengeInstanceStatusFilter<"ChallengeInstance"> | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFilter<"ChallengeInstance"> | Date | string
    templateId?: IntFilter<"ChallengeInstance"> | number
    challengerId?: StringFilter<"ChallengeInstance"> | string
    challengedId?: StringFilter<"ChallengeInstance"> | string
    connectionId?: IntFilter<"ChallengeInstance"> | number
    venueId?: IntFilter<"ChallengeInstance"> | number
    challengerCheckedIn?: BoolFilter<"ChallengeInstance"> | boolean
    challengedCheckedIn?: BoolFilter<"ChallengeInstance"> | boolean
    createdAt?: DateTimeFilter<"ChallengeInstance"> | Date | string
    updatedAt?: DateTimeFilter<"ChallengeInstance"> | Date | string
  }

  export type ChallengeInstanceUpsertWithWhereUniqueWithoutChallengedInput = {
    where: ChallengeInstanceWhereUniqueInput
    update: XOR<ChallengeInstanceUpdateWithoutChallengedInput, ChallengeInstanceUncheckedUpdateWithoutChallengedInput>
    create: XOR<ChallengeInstanceCreateWithoutChallengedInput, ChallengeInstanceUncheckedCreateWithoutChallengedInput>
  }

  export type ChallengeInstanceUpdateWithWhereUniqueWithoutChallengedInput = {
    where: ChallengeInstanceWhereUniqueInput
    data: XOR<ChallengeInstanceUpdateWithoutChallengedInput, ChallengeInstanceUncheckedUpdateWithoutChallengedInput>
  }

  export type ChallengeInstanceUpdateManyWithWhereWithoutChallengedInput = {
    where: ChallengeInstanceScalarWhereInput
    data: XOR<ChallengeInstanceUpdateManyMutationInput, ChallengeInstanceUncheckedUpdateManyWithoutChallengedInput>
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type InterestCreateWithoutProfilesInput = {
    name: string
    category: CategoryCreateNestedOneWithoutInterestsInput
  }

  export type InterestUncheckedCreateWithoutProfilesInput = {
    id?: number
    name: string
    categoryId: number
  }

  export type InterestCreateOrConnectWithoutProfilesInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutProfilesInput, InterestUncheckedCreateWithoutProfilesInput>
  }

  export type PhotoCreateWithoutProfileInput = {
    url: string
    isAvatar?: boolean
    createdAt?: Date | string
  }

  export type PhotoUncheckedCreateWithoutProfileInput = {
    id?: number
    url: string
    isAvatar?: boolean
    createdAt?: Date | string
  }

  export type PhotoCreateOrConnectWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput>
  }

  export type PhotoCreateManyProfileInputEnvelope = {
    data: PhotoCreateManyProfileInput | PhotoCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileOptionCreateWithoutProfilesByOrientationInput = {
    type: $Enums.OptionType
    code: string
    name: string
    profilesByGoal?: ProfileCreateNestedManyWithoutRelationshipGoalInput
  }

  export type ProfileOptionUncheckedCreateWithoutProfilesByOrientationInput = {
    id?: number
    type: $Enums.OptionType
    code: string
    name: string
    profilesByGoal?: ProfileUncheckedCreateNestedManyWithoutRelationshipGoalInput
  }

  export type ProfileOptionCreateOrConnectWithoutProfilesByOrientationInput = {
    where: ProfileOptionWhereUniqueInput
    create: XOR<ProfileOptionCreateWithoutProfilesByOrientationInput, ProfileOptionUncheckedCreateWithoutProfilesByOrientationInput>
  }

  export type ProfileOptionCreateWithoutProfilesByGoalInput = {
    type: $Enums.OptionType
    code: string
    name: string
    profilesByOrientation?: ProfileCreateNestedManyWithoutSexualOrientationInput
  }

  export type ProfileOptionUncheckedCreateWithoutProfilesByGoalInput = {
    id?: number
    type: $Enums.OptionType
    code: string
    name: string
    profilesByOrientation?: ProfileUncheckedCreateNestedManyWithoutSexualOrientationInput
  }

  export type ProfileOptionCreateOrConnectWithoutProfilesByGoalInput = {
    where: ProfileOptionWhereUniqueInput
    create: XOR<ProfileOptionCreateWithoutProfilesByGoalInput, ProfileOptionUncheckedCreateWithoutProfilesByGoalInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type InterestUpsertWithWhereUniqueWithoutProfilesInput = {
    where: InterestWhereUniqueInput
    update: XOR<InterestUpdateWithoutProfilesInput, InterestUncheckedUpdateWithoutProfilesInput>
    create: XOR<InterestCreateWithoutProfilesInput, InterestUncheckedCreateWithoutProfilesInput>
  }

  export type InterestUpdateWithWhereUniqueWithoutProfilesInput = {
    where: InterestWhereUniqueInput
    data: XOR<InterestUpdateWithoutProfilesInput, InterestUncheckedUpdateWithoutProfilesInput>
  }

  export type InterestUpdateManyWithWhereWithoutProfilesInput = {
    where: InterestScalarWhereInput
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyWithoutProfilesInput>
  }

  export type InterestScalarWhereInput = {
    AND?: InterestScalarWhereInput | InterestScalarWhereInput[]
    OR?: InterestScalarWhereInput[]
    NOT?: InterestScalarWhereInput | InterestScalarWhereInput[]
    id?: IntFilter<"Interest"> | number
    name?: StringFilter<"Interest"> | string
    categoryId?: IntFilter<"Interest"> | number
  }

  export type PhotoUpsertWithWhereUniqueWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    update: XOR<PhotoUpdateWithoutProfileInput, PhotoUncheckedUpdateWithoutProfileInput>
    create: XOR<PhotoCreateWithoutProfileInput, PhotoUncheckedCreateWithoutProfileInput>
  }

  export type PhotoUpdateWithWhereUniqueWithoutProfileInput = {
    where: PhotoWhereUniqueInput
    data: XOR<PhotoUpdateWithoutProfileInput, PhotoUncheckedUpdateWithoutProfileInput>
  }

  export type PhotoUpdateManyWithWhereWithoutProfileInput = {
    where: PhotoScalarWhereInput
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyWithoutProfileInput>
  }

  export type PhotoScalarWhereInput = {
    AND?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    OR?: PhotoScalarWhereInput[]
    NOT?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    id?: IntFilter<"Photo"> | number
    url?: StringFilter<"Photo"> | string
    isAvatar?: BoolFilter<"Photo"> | boolean
    createdAt?: DateTimeFilter<"Photo"> | Date | string
    profileId?: StringFilter<"Photo"> | string
  }

  export type ProfileOptionUpsertWithoutProfilesByOrientationInput = {
    update: XOR<ProfileOptionUpdateWithoutProfilesByOrientationInput, ProfileOptionUncheckedUpdateWithoutProfilesByOrientationInput>
    create: XOR<ProfileOptionCreateWithoutProfilesByOrientationInput, ProfileOptionUncheckedCreateWithoutProfilesByOrientationInput>
    where?: ProfileOptionWhereInput
  }

  export type ProfileOptionUpdateToOneWithWhereWithoutProfilesByOrientationInput = {
    where?: ProfileOptionWhereInput
    data: XOR<ProfileOptionUpdateWithoutProfilesByOrientationInput, ProfileOptionUncheckedUpdateWithoutProfilesByOrientationInput>
  }

  export type ProfileOptionUpdateWithoutProfilesByOrientationInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profilesByGoal?: ProfileUpdateManyWithoutRelationshipGoalNestedInput
  }

  export type ProfileOptionUncheckedUpdateWithoutProfilesByOrientationInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profilesByGoal?: ProfileUncheckedUpdateManyWithoutRelationshipGoalNestedInput
  }

  export type ProfileOptionUpsertWithoutProfilesByGoalInput = {
    update: XOR<ProfileOptionUpdateWithoutProfilesByGoalInput, ProfileOptionUncheckedUpdateWithoutProfilesByGoalInput>
    create: XOR<ProfileOptionCreateWithoutProfilesByGoalInput, ProfileOptionUncheckedCreateWithoutProfilesByGoalInput>
    where?: ProfileOptionWhereInput
  }

  export type ProfileOptionUpdateToOneWithWhereWithoutProfilesByGoalInput = {
    where?: ProfileOptionWhereInput
    data: XOR<ProfileOptionUpdateWithoutProfilesByGoalInput, ProfileOptionUncheckedUpdateWithoutProfilesByGoalInput>
  }

  export type ProfileOptionUpdateWithoutProfilesByGoalInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profilesByOrientation?: ProfileUpdateManyWithoutSexualOrientationNestedInput
  }

  export type ProfileOptionUncheckedUpdateWithoutProfilesByGoalInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumOptionTypeFieldUpdateOperationsInput | $Enums.OptionType
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profilesByOrientation?: ProfileUncheckedUpdateManyWithoutSexualOrientationNestedInput
  }

  export type InterestCreateWithoutCategoryInput = {
    name: string
    profiles?: ProfileCreateNestedManyWithoutInterestsInput
  }

  export type InterestUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    profiles?: ProfileUncheckedCreateNestedManyWithoutInterestsInput
  }

  export type InterestCreateOrConnectWithoutCategoryInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutCategoryInput, InterestUncheckedCreateWithoutCategoryInput>
  }

  export type InterestCreateManyCategoryInputEnvelope = {
    data: InterestCreateManyCategoryInput | InterestCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type InterestUpsertWithWhereUniqueWithoutCategoryInput = {
    where: InterestWhereUniqueInput
    update: XOR<InterestUpdateWithoutCategoryInput, InterestUncheckedUpdateWithoutCategoryInput>
    create: XOR<InterestCreateWithoutCategoryInput, InterestUncheckedCreateWithoutCategoryInput>
  }

  export type InterestUpdateWithWhereUniqueWithoutCategoryInput = {
    where: InterestWhereUniqueInput
    data: XOR<InterestUpdateWithoutCategoryInput, InterestUncheckedUpdateWithoutCategoryInput>
  }

  export type InterestUpdateManyWithWhereWithoutCategoryInput = {
    where: InterestScalarWhereInput
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CategoryCreateWithoutInterestsInput = {
    name: string
  }

  export type CategoryUncheckedCreateWithoutInterestsInput = {
    id?: number
    name: string
  }

  export type CategoryCreateOrConnectWithoutInterestsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutInterestsInput, CategoryUncheckedCreateWithoutInterestsInput>
  }

  export type ProfileCreateWithoutInterestsInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
    photos?: PhotoCreateNestedManyWithoutProfileInput
    sexualOrientation?: ProfileOptionCreateNestedOneWithoutProfilesByOrientationInput
    relationshipGoal?: ProfileOptionCreateNestedOneWithoutProfilesByGoalInput
  }

  export type ProfileUncheckedCreateWithoutInterestsInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
    relationshipGoalId?: number | null
    photos?: PhotoUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutInterestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
  }

  export type CategoryUpsertWithoutInterestsInput = {
    update: XOR<CategoryUpdateWithoutInterestsInput, CategoryUncheckedUpdateWithoutInterestsInput>
    create: XOR<CategoryCreateWithoutInterestsInput, CategoryUncheckedCreateWithoutInterestsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutInterestsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutInterestsInput, CategoryUncheckedUpdateWithoutInterestsInput>
  }

  export type CategoryUpdateWithoutInterestsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutInterestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUpsertWithWhereUniqueWithoutInterestsInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutInterestsInput, ProfileUncheckedUpdateWithoutInterestsInput>
    create: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutInterestsInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutInterestsInput, ProfileUncheckedUpdateWithoutInterestsInput>
  }

  export type ProfileUpdateManyWithWhereWithoutInterestsInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutInterestsInput>
  }

  export type ActiveSessionCreateWithoutVenueInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    user: UserCreateNestedOneWithoutActiveSessionInput
  }

  export type ActiveSessionUncheckedCreateWithoutVenueInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    userId: string
  }

  export type ActiveSessionCreateOrConnectWithoutVenueInput = {
    where: ActiveSessionWhereUniqueInput
    create: XOR<ActiveSessionCreateWithoutVenueInput, ActiveSessionUncheckedCreateWithoutVenueInput>
  }

  export type ActiveSessionCreateManyVenueInputEnvelope = {
    data: ActiveSessionCreateManyVenueInput | ActiveSessionCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type VenueGroupMessageCreateWithoutVenueInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    reports?: ReportCreateNestedManyWithoutReportedGroupMessageInput
    reactions?: GroupMessageReactionCreateNestedManyWithoutMessageInput
    sender: UserCreateNestedOneWithoutVenueGroupMessagesInput
  }

  export type VenueGroupMessageUncheckedCreateWithoutVenueInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    senderId: string
    reports?: ReportUncheckedCreateNestedManyWithoutReportedGroupMessageInput
    reactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type VenueGroupMessageCreateOrConnectWithoutVenueInput = {
    where: VenueGroupMessageWhereUniqueInput
    create: XOR<VenueGroupMessageCreateWithoutVenueInput, VenueGroupMessageUncheckedCreateWithoutVenueInput>
  }

  export type VenueGroupMessageCreateManyVenueInputEnvelope = {
    data: VenueGroupMessageCreateManyVenueInput | VenueGroupMessageCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type CheckInHistoryCreateWithoutVenueInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCheckInHistoryInput
  }

  export type CheckInHistoryUncheckedCreateWithoutVenueInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type CheckInHistoryCreateOrConnectWithoutVenueInput = {
    where: CheckInHistoryWhereUniqueInput
    create: XOR<CheckInHistoryCreateWithoutVenueInput, CheckInHistoryUncheckedCreateWithoutVenueInput>
  }

  export type CheckInHistoryCreateManyVenueInputEnvelope = {
    data: CheckInHistoryCreateManyVenueInput | CheckInHistoryCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeInstanceCreateWithoutVenueInput = {
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template: ChallengeTemplateCreateNestedOneWithoutInstancesInput
    challenger: UserCreateNestedOneWithoutSentChallengesInput
    challenged: UserCreateNestedOneWithoutReceivedChallengesInput
    connection: ConnectionCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeInstanceUncheckedCreateWithoutVenueInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    challengedId: string
    connectionId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceCreateOrConnectWithoutVenueInput = {
    where: ChallengeInstanceWhereUniqueInput
    create: XOR<ChallengeInstanceCreateWithoutVenueInput, ChallengeInstanceUncheckedCreateWithoutVenueInput>
  }

  export type ChallengeInstanceCreateManyVenueInputEnvelope = {
    data: ChallengeInstanceCreateManyVenueInput | ChallengeInstanceCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ActiveSessionUpsertWithWhereUniqueWithoutVenueInput = {
    where: ActiveSessionWhereUniqueInput
    update: XOR<ActiveSessionUpdateWithoutVenueInput, ActiveSessionUncheckedUpdateWithoutVenueInput>
    create: XOR<ActiveSessionCreateWithoutVenueInput, ActiveSessionUncheckedCreateWithoutVenueInput>
  }

  export type ActiveSessionUpdateWithWhereUniqueWithoutVenueInput = {
    where: ActiveSessionWhereUniqueInput
    data: XOR<ActiveSessionUpdateWithoutVenueInput, ActiveSessionUncheckedUpdateWithoutVenueInput>
  }

  export type ActiveSessionUpdateManyWithWhereWithoutVenueInput = {
    where: ActiveSessionScalarWhereInput
    data: XOR<ActiveSessionUpdateManyMutationInput, ActiveSessionUncheckedUpdateManyWithoutVenueInput>
  }

  export type ActiveSessionScalarWhereInput = {
    AND?: ActiveSessionScalarWhereInput | ActiveSessionScalarWhereInput[]
    OR?: ActiveSessionScalarWhereInput[]
    NOT?: ActiveSessionScalarWhereInput | ActiveSessionScalarWhereInput[]
    id?: StringFilter<"ActiveSession"> | string
    createdAt?: DateTimeFilter<"ActiveSession"> | Date | string
    expiresAt?: DateTimeFilter<"ActiveSession"> | Date | string
    isIncognito?: BoolFilter<"ActiveSession"> | boolean
    userId?: StringFilter<"ActiveSession"> | string
    venueId?: IntFilter<"ActiveSession"> | number
  }

  export type VenueGroupMessageUpsertWithWhereUniqueWithoutVenueInput = {
    where: VenueGroupMessageWhereUniqueInput
    update: XOR<VenueGroupMessageUpdateWithoutVenueInput, VenueGroupMessageUncheckedUpdateWithoutVenueInput>
    create: XOR<VenueGroupMessageCreateWithoutVenueInput, VenueGroupMessageUncheckedCreateWithoutVenueInput>
  }

  export type VenueGroupMessageUpdateWithWhereUniqueWithoutVenueInput = {
    where: VenueGroupMessageWhereUniqueInput
    data: XOR<VenueGroupMessageUpdateWithoutVenueInput, VenueGroupMessageUncheckedUpdateWithoutVenueInput>
  }

  export type VenueGroupMessageUpdateManyWithWhereWithoutVenueInput = {
    where: VenueGroupMessageScalarWhereInput
    data: XOR<VenueGroupMessageUpdateManyMutationInput, VenueGroupMessageUncheckedUpdateManyWithoutVenueInput>
  }

  export type CheckInHistoryUpsertWithWhereUniqueWithoutVenueInput = {
    where: CheckInHistoryWhereUniqueInput
    update: XOR<CheckInHistoryUpdateWithoutVenueInput, CheckInHistoryUncheckedUpdateWithoutVenueInput>
    create: XOR<CheckInHistoryCreateWithoutVenueInput, CheckInHistoryUncheckedCreateWithoutVenueInput>
  }

  export type CheckInHistoryUpdateWithWhereUniqueWithoutVenueInput = {
    where: CheckInHistoryWhereUniqueInput
    data: XOR<CheckInHistoryUpdateWithoutVenueInput, CheckInHistoryUncheckedUpdateWithoutVenueInput>
  }

  export type CheckInHistoryUpdateManyWithWhereWithoutVenueInput = {
    where: CheckInHistoryScalarWhereInput
    data: XOR<CheckInHistoryUpdateManyMutationInput, CheckInHistoryUncheckedUpdateManyWithoutVenueInput>
  }

  export type ChallengeInstanceUpsertWithWhereUniqueWithoutVenueInput = {
    where: ChallengeInstanceWhereUniqueInput
    update: XOR<ChallengeInstanceUpdateWithoutVenueInput, ChallengeInstanceUncheckedUpdateWithoutVenueInput>
    create: XOR<ChallengeInstanceCreateWithoutVenueInput, ChallengeInstanceUncheckedCreateWithoutVenueInput>
  }

  export type ChallengeInstanceUpdateWithWhereUniqueWithoutVenueInput = {
    where: ChallengeInstanceWhereUniqueInput
    data: XOR<ChallengeInstanceUpdateWithoutVenueInput, ChallengeInstanceUncheckedUpdateWithoutVenueInput>
  }

  export type ChallengeInstanceUpdateManyWithWhereWithoutVenueInput = {
    where: ChallengeInstanceScalarWhereInput
    data: XOR<ChallengeInstanceUpdateManyMutationInput, ChallengeInstanceUncheckedUpdateManyWithoutVenueInput>
  }

  export type UserCreateWithoutActiveSessionInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutActiveSessionInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutActiveSessionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActiveSessionInput, UserUncheckedCreateWithoutActiveSessionInput>
  }

  export type VenueCreateWithoutActiveSessionsInput = {
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    groupMessages?: VenueGroupMessageCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutActiveSessionsInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    groupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutActiveSessionsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutActiveSessionsInput, VenueUncheckedCreateWithoutActiveSessionsInput>
  }

  export type UserUpsertWithoutActiveSessionInput = {
    update: XOR<UserUpdateWithoutActiveSessionInput, UserUncheckedUpdateWithoutActiveSessionInput>
    create: XOR<UserCreateWithoutActiveSessionInput, UserUncheckedCreateWithoutActiveSessionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActiveSessionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActiveSessionInput, UserUncheckedUpdateWithoutActiveSessionInput>
  }

  export type UserUpdateWithoutActiveSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutActiveSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type VenueUpsertWithoutActiveSessionsInput = {
    update: XOR<VenueUpdateWithoutActiveSessionsInput, VenueUncheckedUpdateWithoutActiveSessionsInput>
    create: XOR<VenueCreateWithoutActiveSessionsInput, VenueUncheckedCreateWithoutActiveSessionsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutActiveSessionsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutActiveSessionsInput, VenueUncheckedUpdateWithoutActiveSessionsInput>
  }

  export type VenueUpdateWithoutActiveSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    groupMessages?: VenueGroupMessageUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutActiveSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    groupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserCreateWithoutSentSignalsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutSentSignalsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutSentSignalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentSignalsInput, UserUncheckedCreateWithoutSentSignalsInput>
  }

  export type UserCreateWithoutReceivedSignalsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutReceivedSignalsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutReceivedSignalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedSignalsInput, UserUncheckedCreateWithoutReceivedSignalsInput>
  }

  export type UserUpsertWithoutSentSignalsInput = {
    update: XOR<UserUpdateWithoutSentSignalsInput, UserUncheckedUpdateWithoutSentSignalsInput>
    create: XOR<UserCreateWithoutSentSignalsInput, UserUncheckedCreateWithoutSentSignalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentSignalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentSignalsInput, UserUncheckedUpdateWithoutSentSignalsInput>
  }

  export type UserUpdateWithoutSentSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutSentSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUpsertWithoutReceivedSignalsInput = {
    update: XOR<UserUpdateWithoutReceivedSignalsInput, UserUncheckedUpdateWithoutReceivedSignalsInput>
    create: XOR<UserCreateWithoutReceivedSignalsInput, UserUncheckedCreateWithoutReceivedSignalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedSignalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedSignalsInput, UserUncheckedUpdateWithoutReceivedSignalsInput>
  }

  export type UserUpdateWithoutReceivedSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutConnectionsAInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutConnectionsAInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutConnectionsAInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectionsAInput, UserUncheckedCreateWithoutConnectionsAInput>
  }

  export type UserCreateWithoutConnectionsBInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutConnectionsBInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutConnectionsBInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectionsBInput, UserUncheckedCreateWithoutConnectionsBInput>
  }

  export type MessageCreateWithoutConnectionInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutMessagesInput
    reports?: ReportCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageUncheckedCreateWithoutConnectionInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    senderId: string
    isRead?: boolean
    reports?: ReportUncheckedCreateNestedManyWithoutReportedMessageInput
  }

  export type MessageCreateOrConnectWithoutConnectionInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConnectionInput, MessageUncheckedCreateWithoutConnectionInput>
  }

  export type MessageCreateManyConnectionInputEnvelope = {
    data: MessageCreateManyConnectionInput | MessageCreateManyConnectionInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeInstanceCreateWithoutConnectionInput = {
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template: ChallengeTemplateCreateNestedOneWithoutInstancesInput
    challenger: UserCreateNestedOneWithoutSentChallengesInput
    challenged: UserCreateNestedOneWithoutReceivedChallengesInput
    venue: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeInstanceUncheckedCreateWithoutConnectionInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    challengedId: string
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceCreateOrConnectWithoutConnectionInput = {
    where: ChallengeInstanceWhereUniqueInput
    create: XOR<ChallengeInstanceCreateWithoutConnectionInput, ChallengeInstanceUncheckedCreateWithoutConnectionInput>
  }

  export type ChallengeInstanceCreateManyConnectionInputEnvelope = {
    data: ChallengeInstanceCreateManyConnectionInput | ChallengeInstanceCreateManyConnectionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConnectionsAInput = {
    update: XOR<UserUpdateWithoutConnectionsAInput, UserUncheckedUpdateWithoutConnectionsAInput>
    create: XOR<UserCreateWithoutConnectionsAInput, UserUncheckedCreateWithoutConnectionsAInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectionsAInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectionsAInput, UserUncheckedUpdateWithoutConnectionsAInput>
  }

  export type UserUpdateWithoutConnectionsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectionsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUpsertWithoutConnectionsBInput = {
    update: XOR<UserUpdateWithoutConnectionsBInput, UserUncheckedUpdateWithoutConnectionsBInput>
    create: XOR<UserCreateWithoutConnectionsBInput, UserUncheckedCreateWithoutConnectionsBInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectionsBInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectionsBInput, UserUncheckedUpdateWithoutConnectionsBInput>
  }

  export type UserUpdateWithoutConnectionsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectionsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConnectionInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConnectionInput, MessageUncheckedUpdateWithoutConnectionInput>
    create: XOR<MessageCreateWithoutConnectionInput, MessageUncheckedCreateWithoutConnectionInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConnectionInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConnectionInput, MessageUncheckedUpdateWithoutConnectionInput>
  }

  export type MessageUpdateManyWithWhereWithoutConnectionInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConnectionInput>
  }

  export type ChallengeInstanceUpsertWithWhereUniqueWithoutConnectionInput = {
    where: ChallengeInstanceWhereUniqueInput
    update: XOR<ChallengeInstanceUpdateWithoutConnectionInput, ChallengeInstanceUncheckedUpdateWithoutConnectionInput>
    create: XOR<ChallengeInstanceCreateWithoutConnectionInput, ChallengeInstanceUncheckedCreateWithoutConnectionInput>
  }

  export type ChallengeInstanceUpdateWithWhereUniqueWithoutConnectionInput = {
    where: ChallengeInstanceWhereUniqueInput
    data: XOR<ChallengeInstanceUpdateWithoutConnectionInput, ChallengeInstanceUncheckedUpdateWithoutConnectionInput>
  }

  export type ChallengeInstanceUpdateManyWithWhereWithoutConnectionInput = {
    where: ChallengeInstanceScalarWhereInput
    data: XOR<ChallengeInstanceUpdateManyMutationInput, ChallengeInstanceUncheckedUpdateManyWithoutConnectionInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type ConnectionCreateWithoutMessagesInput = {
    createdAt?: Date | string
    userA: UserCreateNestedOneWithoutConnectionsAInput
    userB: UserCreateNestedOneWithoutConnectionsBInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionUncheckedCreateWithoutMessagesInput = {
    id?: number
    createdAt?: Date | string
    userAId: string
    userBId: string
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionCreateOrConnectWithoutMessagesInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutMessagesInput, ConnectionUncheckedCreateWithoutMessagesInput>
  }

  export type ReportCreateWithoutReportedMessageInput = {
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    reportedGroupMessage?: VenueGroupMessageCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedMessageInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedUserId: string
    reportedGroupMessageId?: number | null
  }

  export type ReportCreateOrConnectWithoutReportedMessageInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput>
  }

  export type ReportCreateManyReportedMessageInputEnvelope = {
    data: ReportCreateManyReportedMessageInput | ReportCreateManyReportedMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type ConnectionUpsertWithoutMessagesInput = {
    update: XOR<ConnectionUpdateWithoutMessagesInput, ConnectionUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConnectionCreateWithoutMessagesInput, ConnectionUncheckedCreateWithoutMessagesInput>
    where?: ConnectionWhereInput
  }

  export type ConnectionUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConnectionWhereInput
    data: XOR<ConnectionUpdateWithoutMessagesInput, ConnectionUncheckedUpdateWithoutMessagesInput>
  }

  export type ConnectionUpdateWithoutMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutConnectionsANestedInput
    userB?: UserUpdateOneRequiredWithoutConnectionsBNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedMessageInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedMessageInput, ReportUncheckedUpdateWithoutReportedMessageInput>
    create: XOR<ReportCreateWithoutReportedMessageInput, ReportUncheckedCreateWithoutReportedMessageInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedMessageInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedMessageInput, ReportUncheckedUpdateWithoutReportedMessageInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedMessageInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedMessageInput>
  }

  export type UserCreateWithoutBlockingInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutBlockingInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutBlockingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockingInput, UserUncheckedCreateWithoutBlockingInput>
  }

  export type UserCreateWithoutBlockedByInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutBlockedByInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutBlockedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
  }

  export type UserUpsertWithoutBlockingInput = {
    update: XOR<UserUpdateWithoutBlockingInput, UserUncheckedUpdateWithoutBlockingInput>
    create: XOR<UserCreateWithoutBlockingInput, UserUncheckedCreateWithoutBlockingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockingInput, UserUncheckedUpdateWithoutBlockingInput>
  }

  export type UserUpdateWithoutBlockingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUpsertWithoutBlockedByInput = {
    update: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutReportsMadeInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutReportsMadeInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutReportsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
  }

  export type UserCreateWithoutReportsReceivedInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutReportsReceivedInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutReportsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
  }

  export type MessageCreateWithoutReportsInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    isRead?: boolean
    sender: UserCreateNestedOneWithoutMessagesInput
    connection: ConnectionCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutReportsInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    senderId: string
    connectionId: number
    isRead?: boolean
  }

  export type MessageCreateOrConnectWithoutReportsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
  }

  export type VenueGroupMessageCreateWithoutReportsInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    reactions?: GroupMessageReactionCreateNestedManyWithoutMessageInput
    venue: VenueCreateNestedOneWithoutGroupMessagesInput
    sender: UserCreateNestedOneWithoutVenueGroupMessagesInput
  }

  export type VenueGroupMessageUncheckedCreateWithoutReportsInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    venueId: number
    senderId: string
    reactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type VenueGroupMessageCreateOrConnectWithoutReportsInput = {
    where: VenueGroupMessageWhereUniqueInput
    create: XOR<VenueGroupMessageCreateWithoutReportsInput, VenueGroupMessageUncheckedCreateWithoutReportsInput>
  }

  export type UserUpsertWithoutReportsMadeInput = {
    update: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type UserUpdateWithoutReportsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUpsertWithoutReportsReceivedInput = {
    update: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
    create: XOR<UserCreateWithoutReportsReceivedInput, UserUncheckedCreateWithoutReportsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsReceivedInput, UserUncheckedUpdateWithoutReportsReceivedInput>
  }

  export type UserUpdateWithoutReportsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type MessageUpsertWithoutReportsInput = {
    update: XOR<MessageUpdateWithoutReportsInput, MessageUncheckedUpdateWithoutReportsInput>
    create: XOR<MessageCreateWithoutReportsInput, MessageUncheckedCreateWithoutReportsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReportsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReportsInput, MessageUncheckedUpdateWithoutReportsInput>
  }

  export type MessageUpdateWithoutReportsInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VenueGroupMessageUpsertWithoutReportsInput = {
    update: XOR<VenueGroupMessageUpdateWithoutReportsInput, VenueGroupMessageUncheckedUpdateWithoutReportsInput>
    create: XOR<VenueGroupMessageCreateWithoutReportsInput, VenueGroupMessageUncheckedCreateWithoutReportsInput>
    where?: VenueGroupMessageWhereInput
  }

  export type VenueGroupMessageUpdateToOneWithWhereWithoutReportsInput = {
    where?: VenueGroupMessageWhereInput
    data: XOR<VenueGroupMessageUpdateWithoutReportsInput, VenueGroupMessageUncheckedUpdateWithoutReportsInput>
  }

  export type VenueGroupMessageUpdateWithoutReportsInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: GroupMessageReactionUpdateManyWithoutMessageNestedInput
    venue?: VenueUpdateOneRequiredWithoutGroupMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutVenueGroupMessagesNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    reactions?: GroupMessageReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserCreateWithoutDevicesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutFeedbacksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
  }

  export type UserUpsertWithoutFeedbacksInput = {
    update: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<UserCreateWithoutFeedbacksInput, UserUncheckedCreateWithoutFeedbacksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedbacksInput, UserUncheckedUpdateWithoutFeedbacksInput>
  }

  export type UserUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    googleId?: StringNullableFilter<"User"> | string | null
    appleId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    roleId?: IntFilter<"User"> | number
    isActive?: BoolFilter<"User"> | boolean
    subscription?: EnumSubscriptionPlanFilter<"User"> | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    premiumExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutSentBroadcastsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutSentBroadcastsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutSentBroadcastsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentBroadcastsInput, UserUncheckedCreateWithoutSentBroadcastsInput>
  }

  export type UserUpsertWithoutSentBroadcastsInput = {
    update: XOR<UserUpdateWithoutSentBroadcastsInput, UserUncheckedUpdateWithoutSentBroadcastsInput>
    create: XOR<UserCreateWithoutSentBroadcastsInput, UserUncheckedCreateWithoutSentBroadcastsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentBroadcastsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentBroadcastsInput, UserUncheckedUpdateWithoutSentBroadcastsInput>
  }

  export type UserUpdateWithoutSentBroadcastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutSentBroadcastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type ProfileCreateWithoutPhotosInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutProfileInput
    interests?: InterestCreateNestedManyWithoutProfilesInput
    sexualOrientation?: ProfileOptionCreateNestedOneWithoutProfilesByOrientationInput
    relationshipGoal?: ProfileOptionCreateNestedOneWithoutProfilesByGoalInput
  }

  export type ProfileUncheckedCreateWithoutPhotosInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
    relationshipGoalId?: number | null
    interests?: InterestUncheckedCreateNestedManyWithoutProfilesInput
  }

  export type ProfileCreateOrConnectWithoutPhotosInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
  }

  export type ProfileUpsertWithoutPhotosInput = {
    update: XOR<ProfileUpdateWithoutPhotosInput, ProfileUncheckedUpdateWithoutPhotosInput>
    create: XOR<ProfileCreateWithoutPhotosInput, ProfileUncheckedCreateWithoutPhotosInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPhotosInput, ProfileUncheckedUpdateWithoutPhotosInput>
  }

  export type ProfileUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    interests?: InterestUpdateManyWithoutProfilesNestedInput
    sexualOrientation?: ProfileOptionUpdateOneWithoutProfilesByOrientationNestedInput
    relationshipGoal?: ProfileOptionUpdateOneWithoutProfilesByGoalNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: InterestUncheckedUpdateManyWithoutProfilesNestedInput
  }

  export type UserCreateWithoutViewsMadeInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutViewsMadeInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutViewsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewsMadeInput, UserUncheckedCreateWithoutViewsMadeInput>
  }

  export type UserCreateWithoutViewsReceivedInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutViewsReceivedInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutViewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutViewsReceivedInput, UserUncheckedCreateWithoutViewsReceivedInput>
  }

  export type UserUpsertWithoutViewsMadeInput = {
    update: XOR<UserUpdateWithoutViewsMadeInput, UserUncheckedUpdateWithoutViewsMadeInput>
    create: XOR<UserCreateWithoutViewsMadeInput, UserUncheckedCreateWithoutViewsMadeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewsMadeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewsMadeInput, UserUncheckedUpdateWithoutViewsMadeInput>
  }

  export type UserUpdateWithoutViewsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutViewsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUpsertWithoutViewsReceivedInput = {
    update: XOR<UserUpdateWithoutViewsReceivedInput, UserUncheckedUpdateWithoutViewsReceivedInput>
    create: XOR<UserCreateWithoutViewsReceivedInput, UserUncheckedCreateWithoutViewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutViewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutViewsReceivedInput, UserUncheckedUpdateWithoutViewsReceivedInput>
  }

  export type UserUpdateWithoutViewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutViewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type ReportCreateWithoutReportedGroupMessageInput = {
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportsMadeInput
    reportedUser: UserCreateNestedOneWithoutReportsReceivedInput
    reportedMessage?: MessageCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedGroupMessageInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedUserId: string
    reportedMessageId?: number | null
  }

  export type ReportCreateOrConnectWithoutReportedGroupMessageInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedGroupMessageInput, ReportUncheckedCreateWithoutReportedGroupMessageInput>
  }

  export type ReportCreateManyReportedGroupMessageInputEnvelope = {
    data: ReportCreateManyReportedGroupMessageInput | ReportCreateManyReportedGroupMessageInput[]
    skipDuplicates?: boolean
  }

  export type GroupMessageReactionCreateWithoutMessageInput = {
    emoji: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGroupMessageReactionsInput
  }

  export type GroupMessageReactionUncheckedCreateWithoutMessageInput = {
    id?: number
    emoji: string
    createdAt?: Date | string
    userId: string
  }

  export type GroupMessageReactionCreateOrConnectWithoutMessageInput = {
    where: GroupMessageReactionWhereUniqueInput
    create: XOR<GroupMessageReactionCreateWithoutMessageInput, GroupMessageReactionUncheckedCreateWithoutMessageInput>
  }

  export type GroupMessageReactionCreateManyMessageInputEnvelope = {
    data: GroupMessageReactionCreateManyMessageInput | GroupMessageReactionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type VenueCreateWithoutGroupMessagesInput = {
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutGroupMessagesInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutGroupMessagesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutGroupMessagesInput, VenueUncheckedCreateWithoutGroupMessagesInput>
  }

  export type UserCreateWithoutVenueGroupMessagesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutVenueGroupMessagesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutVenueGroupMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVenueGroupMessagesInput, UserUncheckedCreateWithoutVenueGroupMessagesInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedGroupMessageInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedGroupMessageInput, ReportUncheckedUpdateWithoutReportedGroupMessageInput>
    create: XOR<ReportCreateWithoutReportedGroupMessageInput, ReportUncheckedCreateWithoutReportedGroupMessageInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedGroupMessageInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedGroupMessageInput, ReportUncheckedUpdateWithoutReportedGroupMessageInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedGroupMessageInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportedGroupMessageInput>
  }

  export type GroupMessageReactionUpsertWithWhereUniqueWithoutMessageInput = {
    where: GroupMessageReactionWhereUniqueInput
    update: XOR<GroupMessageReactionUpdateWithoutMessageInput, GroupMessageReactionUncheckedUpdateWithoutMessageInput>
    create: XOR<GroupMessageReactionCreateWithoutMessageInput, GroupMessageReactionUncheckedCreateWithoutMessageInput>
  }

  export type GroupMessageReactionUpdateWithWhereUniqueWithoutMessageInput = {
    where: GroupMessageReactionWhereUniqueInput
    data: XOR<GroupMessageReactionUpdateWithoutMessageInput, GroupMessageReactionUncheckedUpdateWithoutMessageInput>
  }

  export type GroupMessageReactionUpdateManyWithWhereWithoutMessageInput = {
    where: GroupMessageReactionScalarWhereInput
    data: XOR<GroupMessageReactionUpdateManyMutationInput, GroupMessageReactionUncheckedUpdateManyWithoutMessageInput>
  }

  export type VenueUpsertWithoutGroupMessagesInput = {
    update: XOR<VenueUpdateWithoutGroupMessagesInput, VenueUncheckedUpdateWithoutGroupMessagesInput>
    create: XOR<VenueCreateWithoutGroupMessagesInput, VenueUncheckedCreateWithoutGroupMessagesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutGroupMessagesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutGroupMessagesInput, VenueUncheckedUpdateWithoutGroupMessagesInput>
  }

  export type VenueUpdateWithoutGroupMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutGroupMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type UserUpsertWithoutVenueGroupMessagesInput = {
    update: XOR<UserUpdateWithoutVenueGroupMessagesInput, UserUncheckedUpdateWithoutVenueGroupMessagesInput>
    create: XOR<UserCreateWithoutVenueGroupMessagesInput, UserUncheckedCreateWithoutVenueGroupMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVenueGroupMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVenueGroupMessagesInput, UserUncheckedUpdateWithoutVenueGroupMessagesInput>
  }

  export type UserUpdateWithoutVenueGroupMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutVenueGroupMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutAccountDeletionTokenInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutAccountDeletionTokenInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutAccountDeletionTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountDeletionTokenInput, UserUncheckedCreateWithoutAccountDeletionTokenInput>
  }

  export type UserUpsertWithoutAccountDeletionTokenInput = {
    update: XOR<UserUpdateWithoutAccountDeletionTokenInput, UserUncheckedUpdateWithoutAccountDeletionTokenInput>
    create: XOR<UserCreateWithoutAccountDeletionTokenInput, UserUncheckedCreateWithoutAccountDeletionTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountDeletionTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountDeletionTokenInput, UserUncheckedUpdateWithoutAccountDeletionTokenInput>
  }

  export type UserUpdateWithoutAccountDeletionTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountDeletionTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutEmailChangeTokenInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutEmailChangeTokenInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutEmailChangeTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailChangeTokenInput, UserUncheckedCreateWithoutEmailChangeTokenInput>
  }

  export type UserUpsertWithoutEmailChangeTokenInput = {
    update: XOR<UserUpdateWithoutEmailChangeTokenInput, UserUncheckedUpdateWithoutEmailChangeTokenInput>
    create: XOR<UserCreateWithoutEmailChangeTokenInput, UserUncheckedCreateWithoutEmailChangeTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailChangeTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailChangeTokenInput, UserUncheckedUpdateWithoutEmailChangeTokenInput>
  }

  export type UserUpdateWithoutEmailChangeTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailChangeTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type VenueGroupMessageCreateWithoutReactionsInput = {
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    reports?: ReportCreateNestedManyWithoutReportedGroupMessageInput
    venue: VenueCreateNestedOneWithoutGroupMessagesInput
    sender: UserCreateNestedOneWithoutVenueGroupMessagesInput
  }

  export type VenueGroupMessageUncheckedCreateWithoutReactionsInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    venueId: number
    senderId: string
    reports?: ReportUncheckedCreateNestedManyWithoutReportedGroupMessageInput
  }

  export type VenueGroupMessageCreateOrConnectWithoutReactionsInput = {
    where: VenueGroupMessageWhereUniqueInput
    create: XOR<VenueGroupMessageCreateWithoutReactionsInput, VenueGroupMessageUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutGroupMessageReactionsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutGroupMessageReactionsInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutGroupMessageReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupMessageReactionsInput, UserUncheckedCreateWithoutGroupMessageReactionsInput>
  }

  export type VenueGroupMessageUpsertWithoutReactionsInput = {
    update: XOR<VenueGroupMessageUpdateWithoutReactionsInput, VenueGroupMessageUncheckedUpdateWithoutReactionsInput>
    create: XOR<VenueGroupMessageCreateWithoutReactionsInput, VenueGroupMessageUncheckedCreateWithoutReactionsInput>
    where?: VenueGroupMessageWhereInput
  }

  export type VenueGroupMessageUpdateToOneWithWhereWithoutReactionsInput = {
    where?: VenueGroupMessageWhereInput
    data: XOR<VenueGroupMessageUpdateWithoutReactionsInput, VenueGroupMessageUncheckedUpdateWithoutReactionsInput>
  }

  export type VenueGroupMessageUpdateWithoutReactionsInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutReportedGroupMessageNestedInput
    venue?: VenueUpdateOneRequiredWithoutGroupMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutVenueGroupMessagesNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
    senderId?: StringFieldUpdateOperationsInput | string
    reports?: ReportUncheckedUpdateManyWithoutReportedGroupMessageNestedInput
  }

  export type UserUpsertWithoutGroupMessageReactionsInput = {
    update: XOR<UserUpdateWithoutGroupMessageReactionsInput, UserUncheckedUpdateWithoutGroupMessageReactionsInput>
    create: XOR<UserCreateWithoutGroupMessageReactionsInput, UserUncheckedCreateWithoutGroupMessageReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupMessageReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupMessageReactionsInput, UserUncheckedUpdateWithoutGroupMessageReactionsInput>
  }

  export type UserUpdateWithoutGroupMessageReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupMessageReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserCreateWithoutCheckInHistoryInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutCheckInHistoryInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutCheckInHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCheckInHistoryInput, UserUncheckedCreateWithoutCheckInHistoryInput>
  }

  export type VenueCreateWithoutCheckInHistoryInput = {
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionCreateNestedManyWithoutVenueInput
    groupMessages?: VenueGroupMessageCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutCheckInHistoryInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedCreateNestedManyWithoutVenueInput
    groupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutVenueInput
    challenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutCheckInHistoryInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutCheckInHistoryInput, VenueUncheckedCreateWithoutCheckInHistoryInput>
  }

  export type UserUpsertWithoutCheckInHistoryInput = {
    update: XOR<UserUpdateWithoutCheckInHistoryInput, UserUncheckedUpdateWithoutCheckInHistoryInput>
    create: XOR<UserCreateWithoutCheckInHistoryInput, UserUncheckedCreateWithoutCheckInHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCheckInHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCheckInHistoryInput, UserUncheckedUpdateWithoutCheckInHistoryInput>
  }

  export type UserUpdateWithoutCheckInHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutCheckInHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type VenueUpsertWithoutCheckInHistoryInput = {
    update: XOR<VenueUpdateWithoutCheckInHistoryInput, VenueUncheckedUpdateWithoutCheckInHistoryInput>
    create: XOR<VenueCreateWithoutCheckInHistoryInput, VenueUncheckedCreateWithoutCheckInHistoryInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutCheckInHistoryInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutCheckInHistoryInput, VenueUncheckedUpdateWithoutCheckInHistoryInput>
  }

  export type VenueUpdateWithoutCheckInHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUpdateManyWithoutVenueNestedInput
    groupMessages?: VenueGroupMessageUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutCheckInHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedUpdateManyWithoutVenueNestedInput
    groupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutVenueNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type BadgeRuleCreateWithoutBadgesInput = {
    code: string
    name: string
    description: string
    triggerAction: string
  }

  export type BadgeRuleUncheckedCreateWithoutBadgesInput = {
    id?: number
    code: string
    name: string
    description: string
    triggerAction: string
  }

  export type BadgeRuleCreateOrConnectWithoutBadgesInput = {
    where: BadgeRuleWhereUniqueInput
    create: XOR<BadgeRuleCreateWithoutBadgesInput, BadgeRuleUncheckedCreateWithoutBadgesInput>
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type BadgeRuleUpsertWithoutBadgesInput = {
    update: XOR<BadgeRuleUpdateWithoutBadgesInput, BadgeRuleUncheckedUpdateWithoutBadgesInput>
    create: XOR<BadgeRuleCreateWithoutBadgesInput, BadgeRuleUncheckedCreateWithoutBadgesInput>
    where?: BadgeRuleWhereInput
  }

  export type BadgeRuleUpdateToOneWithWhereWithoutBadgesInput = {
    where?: BadgeRuleWhereInput
    data: XOR<BadgeRuleUpdateWithoutBadgesInput, BadgeRuleUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeRuleUpdateWithoutBadgesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    triggerAction?: StringFieldUpdateOperationsInput | string
  }

  export type BadgeRuleUncheckedUpdateWithoutBadgesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    triggerAction?: StringFieldUpdateOperationsInput | string
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type BadgeCreateWithoutUsersInput = {
    code: string
    name: string
    description: string
    iconUrl: string
    checkValue?: number | null
    createdAt?: Date | string
    rule?: BadgeRuleCreateNestedOneWithoutBadgesInput
  }

  export type BadgeUncheckedCreateWithoutUsersInput = {
    id?: number
    code: string
    name: string
    description: string
    iconUrl: string
    ruleId?: number | null
    checkValue?: number | null
    createdAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutUsersInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type BadgeUpsertWithoutUsersInput = {
    update: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<BadgeCreateWithoutUsersInput, BadgeUncheckedCreateWithoutUsersInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutUsersInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutUsersInput, BadgeUncheckedUpdateWithoutUsersInput>
  }

  export type BadgeUpdateWithoutUsersInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rule?: BadgeRuleUpdateOneWithoutBadgesNestedInput
  }

  export type BadgeUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    ruleId?: NullableIntFieldUpdateOperationsInput | number | null
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateWithoutRuleInput = {
    code: string
    name: string
    description: string
    iconUrl: string
    checkValue?: number | null
    createdAt?: Date | string
    users?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateWithoutRuleInput = {
    id?: number
    code: string
    name: string
    description: string
    iconUrl: string
    checkValue?: number | null
    createdAt?: Date | string
    users?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeCreateOrConnectWithoutRuleInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutRuleInput, BadgeUncheckedCreateWithoutRuleInput>
  }

  export type BadgeCreateManyRuleInputEnvelope = {
    data: BadgeCreateManyRuleInput | BadgeCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type BadgeUpsertWithWhereUniqueWithoutRuleInput = {
    where: BadgeWhereUniqueInput
    update: XOR<BadgeUpdateWithoutRuleInput, BadgeUncheckedUpdateWithoutRuleInput>
    create: XOR<BadgeCreateWithoutRuleInput, BadgeUncheckedCreateWithoutRuleInput>
  }

  export type BadgeUpdateWithWhereUniqueWithoutRuleInput = {
    where: BadgeWhereUniqueInput
    data: XOR<BadgeUpdateWithoutRuleInput, BadgeUncheckedUpdateWithoutRuleInput>
  }

  export type BadgeUpdateManyWithWhereWithoutRuleInput = {
    where: BadgeScalarWhereInput
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyWithoutRuleInput>
  }

  export type BadgeScalarWhereInput = {
    AND?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    OR?: BadgeScalarWhereInput[]
    NOT?: BadgeScalarWhereInput | BadgeScalarWhereInput[]
    id?: IntFilter<"Badge"> | number
    code?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    description?: StringFilter<"Badge"> | string
    iconUrl?: StringFilter<"Badge"> | string
    ruleId?: IntNullableFilter<"Badge"> | number | null
    checkValue?: IntNullableFilter<"Badge"> | number | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
  }

  export type ChallengeInstanceCreateWithoutTemplateInput = {
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    challenger: UserCreateNestedOneWithoutSentChallengesInput
    challenged: UserCreateNestedOneWithoutReceivedChallengesInput
    connection: ConnectionCreateNestedOneWithoutChallengesInput
    venue: VenueCreateNestedOneWithoutChallengesInput
  }

  export type ChallengeInstanceUncheckedCreateWithoutTemplateInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerId: string
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceCreateOrConnectWithoutTemplateInput = {
    where: ChallengeInstanceWhereUniqueInput
    create: XOR<ChallengeInstanceCreateWithoutTemplateInput, ChallengeInstanceUncheckedCreateWithoutTemplateInput>
  }

  export type ChallengeInstanceCreateManyTemplateInputEnvelope = {
    data: ChallengeInstanceCreateManyTemplateInput | ChallengeInstanceCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeInstanceUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ChallengeInstanceWhereUniqueInput
    update: XOR<ChallengeInstanceUpdateWithoutTemplateInput, ChallengeInstanceUncheckedUpdateWithoutTemplateInput>
    create: XOR<ChallengeInstanceCreateWithoutTemplateInput, ChallengeInstanceUncheckedCreateWithoutTemplateInput>
  }

  export type ChallengeInstanceUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ChallengeInstanceWhereUniqueInput
    data: XOR<ChallengeInstanceUpdateWithoutTemplateInput, ChallengeInstanceUncheckedUpdateWithoutTemplateInput>
  }

  export type ChallengeInstanceUpdateManyWithWhereWithoutTemplateInput = {
    where: ChallengeInstanceScalarWhereInput
    data: XOR<ChallengeInstanceUpdateManyMutationInput, ChallengeInstanceUncheckedUpdateManyWithoutTemplateInput>
  }

  export type ChallengeTemplateCreateWithoutInstancesInput = {
    name: string
    description: string
    iconUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChallengeTemplateUncheckedCreateWithoutInstancesInput = {
    id?: number
    name: string
    description: string
    iconUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ChallengeTemplateCreateOrConnectWithoutInstancesInput = {
    where: ChallengeTemplateWhereUniqueInput
    create: XOR<ChallengeTemplateCreateWithoutInstancesInput, ChallengeTemplateUncheckedCreateWithoutInstancesInput>
  }

  export type UserCreateWithoutSentChallengesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    receivedChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengedInput
  }

  export type UserUncheckedCreateWithoutSentChallengesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    receivedChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengedInput
  }

  export type UserCreateOrConnectWithoutSentChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentChallengesInput, UserUncheckedCreateWithoutSentChallengesInput>
  }

  export type UserCreateWithoutReceivedChallengesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionCreateNestedOneWithoutUserInput
    sentSignals?: SignalCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionCreateNestedManyWithoutUserBInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    blockedBy?: BlockCreateNestedManyWithoutBlockedInput
    blocking?: BlockCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportCreateNestedManyWithoutReportedUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackCreateNestedManyWithoutAuthorInput
    role?: RoleCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceCreateNestedManyWithoutChallengerInput
  }

  export type UserUncheckedCreateWithoutReceivedChallengesInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roleId?: number
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    activeSession?: ActiveSessionUncheckedCreateNestedOneWithoutUserInput
    sentSignals?: SignalUncheckedCreateNestedManyWithoutSenderInput
    receivedSignals?: SignalUncheckedCreateNestedManyWithoutReceiverInput
    connectionsA?: ConnectionUncheckedCreateNestedManyWithoutUserAInput
    connectionsB?: ConnectionUncheckedCreateNestedManyWithoutUserBInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    blockedBy?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocking?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReporterInput
    reportsReceived?: ReportUncheckedCreateNestedManyWithoutReportedUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    feedbacks?: FeedbackUncheckedCreateNestedManyWithoutAuthorInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    sentBroadcasts?: BroadcastNotificationUncheckedCreateNestedManyWithoutSentByInput
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    viewsMade?: ProfileViewUncheckedCreateNestedManyWithoutViewerInput
    viewsReceived?: ProfileViewUncheckedCreateNestedManyWithoutViewedInput
    venueGroupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutSenderInput
    accountDeletionToken?: AccountDeletionTokenUncheckedCreateNestedOneWithoutUserInput
    emailChangeToken?: EmailChangeTokenUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    groupMessageReactions?: GroupMessageReactionUncheckedCreateNestedManyWithoutUserInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    sentChallenges?: ChallengeInstanceUncheckedCreateNestedManyWithoutChallengerInput
  }

  export type UserCreateOrConnectWithoutReceivedChallengesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedChallengesInput, UserUncheckedCreateWithoutReceivedChallengesInput>
  }

  export type ConnectionCreateWithoutChallengesInput = {
    createdAt?: Date | string
    userA: UserCreateNestedOneWithoutConnectionsAInput
    userB: UserCreateNestedOneWithoutConnectionsBInput
    messages?: MessageCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionUncheckedCreateWithoutChallengesInput = {
    id?: number
    createdAt?: Date | string
    userAId: string
    userBId: string
    messages?: MessageUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type ConnectionCreateOrConnectWithoutChallengesInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutChallengesInput, ConnectionUncheckedCreateWithoutChallengesInput>
  }

  export type VenueCreateWithoutChallengesInput = {
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionCreateNestedManyWithoutVenueInput
    groupMessages?: VenueGroupMessageCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutChallengesInput = {
    id?: number
    name: string
    address?: string | null
    description?: string | null
    latitude: number
    longitude: number
    isActive?: boolean
    isFeatured?: boolean
    category?: $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedCreateNestedManyWithoutVenueInput
    groupMessages?: VenueGroupMessageUncheckedCreateNestedManyWithoutVenueInput
    checkInHistory?: CheckInHistoryUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutChallengesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
  }

  export type ChallengeTemplateUpsertWithoutInstancesInput = {
    update: XOR<ChallengeTemplateUpdateWithoutInstancesInput, ChallengeTemplateUncheckedUpdateWithoutInstancesInput>
    create: XOR<ChallengeTemplateCreateWithoutInstancesInput, ChallengeTemplateUncheckedCreateWithoutInstancesInput>
    where?: ChallengeTemplateWhereInput
  }

  export type ChallengeTemplateUpdateToOneWithWhereWithoutInstancesInput = {
    where?: ChallengeTemplateWhereInput
    data: XOR<ChallengeTemplateUpdateWithoutInstancesInput, ChallengeTemplateUncheckedUpdateWithoutInstancesInput>
  }

  export type ChallengeTemplateUpdateWithoutInstancesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeTemplateUncheckedUpdateWithoutInstancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSentChallengesInput = {
    update: XOR<UserUpdateWithoutSentChallengesInput, UserUncheckedUpdateWithoutSentChallengesInput>
    create: XOR<UserCreateWithoutSentChallengesInput, UserUncheckedCreateWithoutSentChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentChallengesInput, UserUncheckedUpdateWithoutSentChallengesInput>
  }

  export type UserUpdateWithoutSentChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutSentChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUpsertWithoutReceivedChallengesInput = {
    update: XOR<UserUpdateWithoutReceivedChallengesInput, UserUncheckedUpdateWithoutReceivedChallengesInput>
    create: XOR<UserCreateWithoutReceivedChallengesInput, UserUncheckedCreateWithoutReceivedChallengesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedChallengesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedChallengesInput, UserUncheckedUpdateWithoutReceivedChallengesInput>
  }

  export type UserUpdateWithoutReceivedChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roleId?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
  }

  export type ConnectionUpsertWithoutChallengesInput = {
    update: XOR<ConnectionUpdateWithoutChallengesInput, ConnectionUncheckedUpdateWithoutChallengesInput>
    create: XOR<ConnectionCreateWithoutChallengesInput, ConnectionUncheckedCreateWithoutChallengesInput>
    where?: ConnectionWhereInput
  }

  export type ConnectionUpdateToOneWithWhereWithoutChallengesInput = {
    where?: ConnectionWhereInput
    data: XOR<ConnectionUpdateWithoutChallengesInput, ConnectionUncheckedUpdateWithoutChallengesInput>
  }

  export type ConnectionUpdateWithoutChallengesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutConnectionsANestedInput
    userB?: UserUpdateOneRequiredWithoutConnectionsBNestedInput
    messages?: MessageUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type VenueUpsertWithoutChallengesInput = {
    update: XOR<VenueUpdateWithoutChallengesInput, VenueUncheckedUpdateWithoutChallengesInput>
    create: XOR<VenueCreateWithoutChallengesInput, VenueUncheckedCreateWithoutChallengesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutChallengesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutChallengesInput, VenueUncheckedUpdateWithoutChallengesInput>
  }

  export type VenueUpdateWithoutChallengesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUpdateManyWithoutVenueNestedInput
    groupMessages?: VenueGroupMessageUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutChallengesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    category?: EnumVenueCategoryFieldUpdateOperationsInput | $Enums.VenueCategory
    statsSummary?: NullableJsonNullValueInput | InputJsonValue
    activeSessions?: ActiveSessionUncheckedUpdateManyWithoutVenueNestedInput
    groupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutVenueNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProfileCreateManySexualOrientationInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    relationshipGoalId?: number | null
  }

  export type ProfileCreateManyRelationshipGoalInput = {
    id?: string
    name: string
    age: number
    gender: string
    bio?: string | null
    university?: string | null
    city?: string | null
    personality?: $Enums.PersonalityType | null
    userId: string
    phoneNumber?: string | null
    extraSignalCredits?: number
    hideViewFootprints?: boolean
    preferredMinAge?: number | null
    preferredMaxAge?: number | null
    notifyOnNewSignal?: boolean
    notifyOnNewMatch?: boolean
    notifyOnNewMessage?: boolean
    isVerified?: boolean
    verificationStatus?: $Enums.VerificationStatus
    verificationPhotoUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string | null
    provisionalSignalsUsed?: number
    currentStatus?: string | null
    statusExpiresAt?: Date | string | null
    sexualOrientationId?: number | null
  }

  export type ProfileUpdateWithoutSexualOrientationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    interests?: InterestUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    relationshipGoal?: ProfileOptionUpdateOneWithoutProfilesByGoalNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSexualOrientationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: InterestUncheckedUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutSexualOrientationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileUpdateWithoutRelationshipGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    interests?: InterestUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    sexualOrientation?: ProfileOptionUpdateOneWithoutProfilesByOrientationNestedInput
  }

  export type ProfileUncheckedUpdateWithoutRelationshipGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    interests?: InterestUncheckedUpdateManyWithoutProfilesNestedInput
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutRelationshipGoalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SignalCreateManySenderInput = {
    id?: number
    createdAt?: Date | string
    receiverId: string
  }

  export type SignalCreateManyReceiverInput = {
    id?: number
    createdAt?: Date | string
    senderId: string
  }

  export type ConnectionCreateManyUserAInput = {
    id?: number
    createdAt?: Date | string
    userBId: string
  }

  export type ConnectionCreateManyUserBInput = {
    id?: number
    createdAt?: Date | string
    userAId: string
  }

  export type MessageCreateManySenderInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    connectionId: number
    isRead?: boolean
  }

  export type BlockCreateManyBlockedInput = {
    id?: number
    createdAt?: Date | string
    blockerId: string
  }

  export type BlockCreateManyBlockerInput = {
    id?: number
    createdAt?: Date | string
    blockedId: string
  }

  export type ReportCreateManyReporterInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportedUserId: string
    reportedMessageId?: number | null
    reportedGroupMessageId?: number | null
  }

  export type ReportCreateManyReportedUserInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedMessageId?: number | null
    reportedGroupMessageId?: number | null
  }

  export type DeviceCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: string
    content: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type FeedbackCreateManyAuthorInput = {
    id?: number
    description: string
    screenshotUrl?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: number
    action: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type BroadcastNotificationCreateManySentByInput = {
    id?: number
    title: string
    body: string
    createdAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ProfileViewCreateManyViewerInput = {
    id?: number
    viewedId: string
    createdAt?: Date | string
  }

  export type ProfileViewCreateManyViewedInput = {
    id?: number
    viewerId: string
    createdAt?: Date | string
  }

  export type VenueGroupMessageCreateManySenderInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    venueId: number
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type GroupMessageReactionCreateManyUserInput = {
    id?: number
    emoji: string
    createdAt?: Date | string
    messageId: number
  }

  export type CheckInHistoryCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    venueId: number
  }

  export type UserBadgeCreateManyUserInput = {
    badgeId: number
    createdAt?: Date | string
  }

  export type ChallengeInstanceCreateManyChallengerInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceCreateManyChallengedInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SignalUpdateWithoutSenderInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutReceivedSignalsNestedInput
  }

  export type SignalUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type SignalUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type SignalUpdateWithoutReceiverInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentSignalsNestedInput
  }

  export type SignalUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type SignalUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionUpdateWithoutUserAInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userB?: UserUpdateOneRequiredWithoutConnectionsBNestedInput
    messages?: MessageUpdateManyWithoutConnectionNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutUserAInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutConnectionNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateManyWithoutUserAInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userBId?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionUpdateWithoutUserBInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: UserUpdateOneRequiredWithoutConnectionsANestedInput
    messages?: MessageUpdateManyWithoutConnectionNestedInput
    challenges?: ChallengeInstanceUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutUserBInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutConnectionNestedInput
    challenges?: ChallengeInstanceUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type ConnectionUncheckedUpdateManyWithoutUserBInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutSenderInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    connection?: ConnectionUpdateOneRequiredWithoutMessagesNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectionId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    connectionId?: IntFieldUpdateOperationsInput | number
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BlockUpdateWithoutBlockedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: UserUpdateOneRequiredWithoutBlockingNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUpdateWithoutBlockerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedId?: StringFieldUpdateOperationsInput | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockerInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUpdateWithoutReporterInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reportedGroupMessage?: VenueGroupMessageUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUncheckedUpdateManyWithoutReporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUpdateWithoutReportedUserInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
    reportedGroupMessage?: VenueGroupMessageUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUncheckedUpdateManyWithoutReportedUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeviceUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutAuthorInput = {
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    screenshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BroadcastNotificationUpdateWithoutSentByInput = {
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BroadcastNotificationUncheckedUpdateWithoutSentByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BroadcastNotificationUncheckedUpdateManyWithoutSentByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUpdateWithoutViewerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewed?: UserUpdateOneRequiredWithoutViewsReceivedNestedInput
  }

  export type ProfileViewUncheckedUpdateWithoutViewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    viewedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUncheckedUpdateManyWithoutViewerInput = {
    id?: IntFieldUpdateOperationsInput | number
    viewedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUpdateWithoutViewedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    viewer?: UserUpdateOneRequiredWithoutViewsMadeNestedInput
  }

  export type ProfileViewUncheckedUpdateWithoutViewedInput = {
    id?: IntFieldUpdateOperationsInput | number
    viewerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileViewUncheckedUpdateManyWithoutViewedInput = {
    id?: IntFieldUpdateOperationsInput | number
    viewerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueGroupMessageUpdateWithoutSenderInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutReportedGroupMessageNestedInput
    reactions?: GroupMessageReactionUpdateManyWithoutMessageNestedInput
    venue?: VenueUpdateOneRequiredWithoutGroupMessagesNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
    reports?: ReportUncheckedUpdateManyWithoutReportedGroupMessageNestedInput
    reactions?: GroupMessageReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupMessageReactionUpdateWithoutUserInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: VenueGroupMessageUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type GroupMessageReactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupMessageReactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInHistoryUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutCheckInHistoryNestedInput
  }

  export type CheckInHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type CheckInHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venueId?: IntFieldUpdateOperationsInput | number
  }

  export type UserBadgeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    badgeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    badgeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUpdateWithoutChallengerInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ChallengeTemplateUpdateOneRequiredWithoutInstancesNestedInput
    challenged?: UserUpdateOneRequiredWithoutReceivedChallengesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutChallengesNestedInput
    venue?: VenueUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeInstanceUncheckedUpdateWithoutChallengerInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutChallengerInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUpdateWithoutChallengedInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ChallengeTemplateUpdateOneRequiredWithoutInstancesNestedInput
    challenger?: UserUpdateOneRequiredWithoutSentChallengesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutChallengesNestedInput
    venue?: VenueUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeInstanceUncheckedUpdateWithoutChallengedInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutChallengedInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyProfileInput = {
    id?: number
    url: string
    isAvatar?: boolean
    createdAt?: Date | string
  }

  export type InterestUpdateWithoutProfilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type InterestUncheckedUpdateWithoutProfilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type InterestUncheckedUpdateManyWithoutProfilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type PhotoUpdateWithoutProfileInput = {
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isAvatar?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateManyCategoryInput = {
    id?: number
    name: string
  }

  export type InterestUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUpdateManyWithoutInterestsNestedInput
  }

  export type InterestUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    profiles?: ProfileUncheckedUpdateManyWithoutInterestsNestedInput
  }

  export type InterestUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    photos?: PhotoUpdateManyWithoutProfileNestedInput
    sexualOrientation?: ProfileOptionUpdateOneWithoutProfilesByOrientationNestedInput
    relationshipGoal?: ProfileOptionUpdateOneWithoutProfilesByGoalNestedInput
  }

  export type ProfileUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
    photos?: PhotoUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    university?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    personality?: NullableEnumPersonalityTypeFieldUpdateOperationsInput | $Enums.PersonalityType | null
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    extraSignalCredits?: IntFieldUpdateOperationsInput | number
    hideViewFootprints?: BoolFieldUpdateOperationsInput | boolean
    preferredMinAge?: NullableIntFieldUpdateOperationsInput | number | null
    preferredMaxAge?: NullableIntFieldUpdateOperationsInput | number | null
    notifyOnNewSignal?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMatch?: BoolFieldUpdateOperationsInput | boolean
    notifyOnNewMessage?: BoolFieldUpdateOperationsInput | boolean
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    verificationPhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provisionalSignalsUsed?: IntFieldUpdateOperationsInput | number
    currentStatus?: NullableStringFieldUpdateOperationsInput | string | null
    statusExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexualOrientationId?: NullableIntFieldUpdateOperationsInput | number | null
    relationshipGoalId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActiveSessionCreateManyVenueInput = {
    id?: string
    createdAt?: Date | string
    expiresAt: Date | string
    isIncognito?: boolean
    userId: string
  }

  export type VenueGroupMessageCreateManyVenueInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    videoUrl?: string | null
    createdAt?: Date | string
    senderId: string
  }

  export type CheckInHistoryCreateManyVenueInput = {
    id?: number
    createdAt?: Date | string
    userId: string
  }

  export type ChallengeInstanceCreateManyVenueInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    challengedId: string
    connectionId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiveSessionUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutActiveSessionNestedInput
  }

  export type ActiveSessionUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ActiveSessionUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isIncognito?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VenueGroupMessageUpdateWithoutVenueInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutReportedGroupMessageNestedInput
    reactions?: GroupMessageReactionUpdateManyWithoutMessageNestedInput
    sender?: UserUpdateOneRequiredWithoutVenueGroupMessagesNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    reports?: ReportUncheckedUpdateManyWithoutReportedGroupMessageNestedInput
    reactions?: GroupMessageReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type VenueGroupMessageUncheckedUpdateManyWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckInHistoryUpdateWithoutVenueInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCheckInHistoryNestedInput
  }

  export type CheckInHistoryUncheckedUpdateWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CheckInHistoryUncheckedUpdateManyWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeInstanceUpdateWithoutVenueInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ChallengeTemplateUpdateOneRequiredWithoutInstancesNestedInput
    challenger?: UserUpdateOneRequiredWithoutSentChallengesNestedInput
    challenged?: UserUpdateOneRequiredWithoutReceivedChallengesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeInstanceUncheckedUpdateWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutVenueInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConnectionInput = {
    id?: number
    content?: string | null
    imageUrl?: string | null
    audioUrl?: string | null
    createdAt?: Date | string
    senderId: string
    isRead?: boolean
  }

  export type ChallengeInstanceCreateManyConnectionInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    templateId: number
    challengerId: string
    challengedId: string
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutConnectionInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
    reports?: ReportUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConnectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    reports?: ReportUncheckedUpdateManyWithoutReportedMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConnectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    senderId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ChallengeInstanceUpdateWithoutConnectionInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ChallengeTemplateUpdateOneRequiredWithoutInstancesNestedInput
    challenger?: UserUpdateOneRequiredWithoutSentChallengesNestedInput
    challenged?: UserUpdateOneRequiredWithoutReceivedChallengesNestedInput
    venue?: VenueUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeInstanceUncheckedUpdateWithoutConnectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutConnectionInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    templateId?: IntFieldUpdateOperationsInput | number
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyReportedMessageInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedUserId: string
    reportedGroupMessageId?: number | null
  }

  export type ReportUpdateWithoutReportedMessageInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    reportedGroupMessage?: VenueGroupMessageUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUncheckedUpdateManyWithoutReportedMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedGroupMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    password?: string | null
    authProvider?: $Enums.AuthProvider
    googleId?: string | null
    appleId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    subscription?: $Enums.SubscriptionPlan
    subscriptionExpiresAt?: Date | string | null
    premiumExpiresAt?: Date | string | null
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUpdateManyWithoutUserBNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    activeSession?: ActiveSessionUncheckedUpdateOneWithoutUserNestedInput
    sentSignals?: SignalUncheckedUpdateManyWithoutSenderNestedInput
    receivedSignals?: SignalUncheckedUpdateManyWithoutReceiverNestedInput
    connectionsA?: ConnectionUncheckedUpdateManyWithoutUserANestedInput
    connectionsB?: ConnectionUncheckedUpdateManyWithoutUserBNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    blockedBy?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocking?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReporterNestedInput
    reportsReceived?: ReportUncheckedUpdateManyWithoutReportedUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    feedbacks?: FeedbackUncheckedUpdateManyWithoutAuthorNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    sentBroadcasts?: BroadcastNotificationUncheckedUpdateManyWithoutSentByNestedInput
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    viewsMade?: ProfileViewUncheckedUpdateManyWithoutViewerNestedInput
    viewsReceived?: ProfileViewUncheckedUpdateManyWithoutViewedNestedInput
    venueGroupMessages?: VenueGroupMessageUncheckedUpdateManyWithoutSenderNestedInput
    accountDeletionToken?: AccountDeletionTokenUncheckedUpdateOneWithoutUserNestedInput
    emailChangeToken?: EmailChangeTokenUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    groupMessageReactions?: GroupMessageReactionUncheckedUpdateManyWithoutUserNestedInput
    checkInHistory?: CheckInHistoryUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    sentChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengerNestedInput
    receivedChallenges?: ChallengeInstanceUncheckedUpdateManyWithoutChallengedNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    appleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    subscription?: EnumSubscriptionPlanFieldUpdateOperationsInput | $Enums.SubscriptionPlan
    subscriptionExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    premiumExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportCreateManyReportedGroupMessageInput = {
    id?: number
    reason: string
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporterId: string
    reportedUserId: string
    reportedMessageId?: number | null
  }

  export type GroupMessageReactionCreateManyMessageInput = {
    id?: number
    emoji: string
    createdAt?: Date | string
    userId: string
  }

  export type ReportUpdateWithoutReportedGroupMessageInput = {
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
    reportedUser?: UserUpdateOneRequiredWithoutReportsReceivedNestedInput
    reportedMessage?: MessageUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedGroupMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUncheckedUpdateManyWithoutReportedGroupMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporterId?: StringFieldUpdateOperationsInput | string
    reportedUserId?: StringFieldUpdateOperationsInput | string
    reportedMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GroupMessageReactionUpdateWithoutMessageInput = {
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupMessageReactionsNestedInput
  }

  export type GroupMessageReactionUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type GroupMessageReactionUncheckedUpdateManyWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserBadgeCreateManyBadgeInput = {
    userId: string
    createdAt?: Date | string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeCreateManyRuleInput = {
    id?: number
    code: string
    name: string
    description: string
    iconUrl: string
    checkValue?: number | null
    createdAt?: Date | string
  }

  export type BadgeUpdateWithoutRuleInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateManyWithoutRuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iconUrl?: StringFieldUpdateOperationsInput | string
    checkValue?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceCreateManyTemplateInput = {
    id?: number
    status?: $Enums.ChallengeInstanceStatus
    challengeTime: Date | string
    challengerId: string
    challengedId: string
    connectionId: number
    venueId: number
    challengerCheckedIn?: boolean
    challengedCheckedIn?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeInstanceUpdateWithoutTemplateInput = {
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenger?: UserUpdateOneRequiredWithoutSentChallengesNestedInput
    challenged?: UserUpdateOneRequiredWithoutReceivedChallengesNestedInput
    connection?: ConnectionUpdateOneRequiredWithoutChallengesNestedInput
    venue?: VenueUpdateOneRequiredWithoutChallengesNestedInput
  }

  export type ChallengeInstanceUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeInstanceUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumChallengeInstanceStatusFieldUpdateOperationsInput | $Enums.ChallengeInstanceStatus
    challengeTime?: DateTimeFieldUpdateOperationsInput | Date | string
    challengerId?: StringFieldUpdateOperationsInput | string
    challengedId?: StringFieldUpdateOperationsInput | string
    connectionId?: IntFieldUpdateOperationsInput | number
    venueId?: IntFieldUpdateOperationsInput | number
    challengerCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    challengedCheckedIn?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}